
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00400000 <_vector_table>:
  400000:	40 13 40 20 e5 32 40 00 2b 65 40 00 b9 32 40 00     @.@ .2@.+e@..2@.
  400010:	b9 32 40 00 b9 32 40 00 b9 32 40 00 00 00 00 00     .2@..2@..2@.....
	...
  40002c:	35 2c 40 00 b9 32 40 00 00 00 00 00 e1 2b 40 00     5,@..2@......+@.
  40003c:	89 47 40 00                                         .G@.

00400040 <_irq_vector_table>:
  400040:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400050:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400060:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400070:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400080:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400090:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  4000a0:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  4000b0:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  4000c0:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  4000d0:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  4000e0:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  4000f0:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400100:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400110:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400120:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400130:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400140:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00 d9 2c 40 00     .,@..,@..,@..,@.
  400150:	d9 2c 40 00 d9 2c 40 00 d9 2c 40 00                 .,@..,@..,@.

Disassembly of section text:

00400160 <__aeabi_drsub>:
  400160:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  400164:	e002      	b.n	40016c <__adddf3>
  400166:	bf00      	nop

00400168 <__aeabi_dsub>:
  400168:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0040016c <__adddf3>:
  40016c:	b530      	push	{r4, r5, lr}
  40016e:	ea4f 0441 	mov.w	r4, r1, lsl #1
  400172:	ea4f 0543 	mov.w	r5, r3, lsl #1
  400176:	ea94 0f05 	teq	r4, r5
  40017a:	bf08      	it	eq
  40017c:	ea90 0f02 	teqeq	r0, r2
  400180:	bf1f      	itttt	ne
  400182:	ea54 0c00 	orrsne.w	ip, r4, r0
  400186:	ea55 0c02 	orrsne.w	ip, r5, r2
  40018a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  40018e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  400192:	f000 80e2 	beq.w	40035a <__adddf3+0x1ee>
  400196:	ea4f 5454 	mov.w	r4, r4, lsr #21
  40019a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  40019e:	bfb8      	it	lt
  4001a0:	426d      	neglt	r5, r5
  4001a2:	dd0c      	ble.n	4001be <__adddf3+0x52>
  4001a4:	442c      	add	r4, r5
  4001a6:	ea80 0202 	eor.w	r2, r0, r2
  4001aa:	ea81 0303 	eor.w	r3, r1, r3
  4001ae:	ea82 0000 	eor.w	r0, r2, r0
  4001b2:	ea83 0101 	eor.w	r1, r3, r1
  4001b6:	ea80 0202 	eor.w	r2, r0, r2
  4001ba:	ea81 0303 	eor.w	r3, r1, r3
  4001be:	2d36      	cmp	r5, #54	; 0x36
  4001c0:	bf88      	it	hi
  4001c2:	bd30      	pophi	{r4, r5, pc}
  4001c4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4001c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4001cc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4001d0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4001d4:	d002      	beq.n	4001dc <__adddf3+0x70>
  4001d6:	4240      	negs	r0, r0
  4001d8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4001dc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  4001e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
  4001e4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  4001e8:	d002      	beq.n	4001f0 <__adddf3+0x84>
  4001ea:	4252      	negs	r2, r2
  4001ec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4001f0:	ea94 0f05 	teq	r4, r5
  4001f4:	f000 80a7 	beq.w	400346 <__adddf3+0x1da>
  4001f8:	f1a4 0401 	sub.w	r4, r4, #1
  4001fc:	f1d5 0e20 	rsbs	lr, r5, #32
  400200:	db0d      	blt.n	40021e <__adddf3+0xb2>
  400202:	fa02 fc0e 	lsl.w	ip, r2, lr
  400206:	fa22 f205 	lsr.w	r2, r2, r5
  40020a:	1880      	adds	r0, r0, r2
  40020c:	f141 0100 	adc.w	r1, r1, #0
  400210:	fa03 f20e 	lsl.w	r2, r3, lr
  400214:	1880      	adds	r0, r0, r2
  400216:	fa43 f305 	asr.w	r3, r3, r5
  40021a:	4159      	adcs	r1, r3
  40021c:	e00e      	b.n	40023c <__adddf3+0xd0>
  40021e:	f1a5 0520 	sub.w	r5, r5, #32
  400222:	f10e 0e20 	add.w	lr, lr, #32
  400226:	2a01      	cmp	r2, #1
  400228:	fa03 fc0e 	lsl.w	ip, r3, lr
  40022c:	bf28      	it	cs
  40022e:	f04c 0c02 	orrcs.w	ip, ip, #2
  400232:	fa43 f305 	asr.w	r3, r3, r5
  400236:	18c0      	adds	r0, r0, r3
  400238:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  40023c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  400240:	d507      	bpl.n	400252 <__adddf3+0xe6>
  400242:	f04f 0e00 	mov.w	lr, #0
  400246:	f1dc 0c00 	rsbs	ip, ip, #0
  40024a:	eb7e 0000 	sbcs.w	r0, lr, r0
  40024e:	eb6e 0101 	sbc.w	r1, lr, r1
  400252:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  400256:	d31b      	bcc.n	400290 <__adddf3+0x124>
  400258:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  40025c:	d30c      	bcc.n	400278 <__adddf3+0x10c>
  40025e:	0849      	lsrs	r1, r1, #1
  400260:	ea5f 0030 	movs.w	r0, r0, rrx
  400264:	ea4f 0c3c 	mov.w	ip, ip, rrx
  400268:	f104 0401 	add.w	r4, r4, #1
  40026c:	ea4f 5244 	mov.w	r2, r4, lsl #21
  400270:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  400274:	f080 809a 	bcs.w	4003ac <__adddf3+0x240>
  400278:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  40027c:	bf08      	it	eq
  40027e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  400282:	f150 0000 	adcs.w	r0, r0, #0
  400286:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40028a:	ea41 0105 	orr.w	r1, r1, r5
  40028e:	bd30      	pop	{r4, r5, pc}
  400290:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  400294:	4140      	adcs	r0, r0
  400296:	eb41 0101 	adc.w	r1, r1, r1
  40029a:	3c01      	subs	r4, #1
  40029c:	bf28      	it	cs
  40029e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
  4002a2:	d2e9      	bcs.n	400278 <__adddf3+0x10c>
  4002a4:	f091 0f00 	teq	r1, #0
  4002a8:	bf04      	itt	eq
  4002aa:	4601      	moveq	r1, r0
  4002ac:	2000      	moveq	r0, #0
  4002ae:	fab1 f381 	clz	r3, r1
  4002b2:	bf08      	it	eq
  4002b4:	3320      	addeq	r3, #32
  4002b6:	f1a3 030b 	sub.w	r3, r3, #11
  4002ba:	f1b3 0220 	subs.w	r2, r3, #32
  4002be:	da0c      	bge.n	4002da <__adddf3+0x16e>
  4002c0:	320c      	adds	r2, #12
  4002c2:	dd08      	ble.n	4002d6 <__adddf3+0x16a>
  4002c4:	f102 0c14 	add.w	ip, r2, #20
  4002c8:	f1c2 020c 	rsb	r2, r2, #12
  4002cc:	fa01 f00c 	lsl.w	r0, r1, ip
  4002d0:	fa21 f102 	lsr.w	r1, r1, r2
  4002d4:	e00c      	b.n	4002f0 <__adddf3+0x184>
  4002d6:	f102 0214 	add.w	r2, r2, #20
  4002da:	bfd8      	it	le
  4002dc:	f1c2 0c20 	rsble	ip, r2, #32
  4002e0:	fa01 f102 	lsl.w	r1, r1, r2
  4002e4:	fa20 fc0c 	lsr.w	ip, r0, ip
  4002e8:	bfdc      	itt	le
  4002ea:	ea41 010c 	orrle.w	r1, r1, ip
  4002ee:	4090      	lslle	r0, r2
  4002f0:	1ae4      	subs	r4, r4, r3
  4002f2:	bfa2      	ittt	ge
  4002f4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  4002f8:	4329      	orrge	r1, r5
  4002fa:	bd30      	popge	{r4, r5, pc}
  4002fc:	ea6f 0404 	mvn.w	r4, r4
  400300:	3c1f      	subs	r4, #31
  400302:	da1c      	bge.n	40033e <__adddf3+0x1d2>
  400304:	340c      	adds	r4, #12
  400306:	dc0e      	bgt.n	400326 <__adddf3+0x1ba>
  400308:	f104 0414 	add.w	r4, r4, #20
  40030c:	f1c4 0220 	rsb	r2, r4, #32
  400310:	fa20 f004 	lsr.w	r0, r0, r4
  400314:	fa01 f302 	lsl.w	r3, r1, r2
  400318:	ea40 0003 	orr.w	r0, r0, r3
  40031c:	fa21 f304 	lsr.w	r3, r1, r4
  400320:	ea45 0103 	orr.w	r1, r5, r3
  400324:	bd30      	pop	{r4, r5, pc}
  400326:	f1c4 040c 	rsb	r4, r4, #12
  40032a:	f1c4 0220 	rsb	r2, r4, #32
  40032e:	fa20 f002 	lsr.w	r0, r0, r2
  400332:	fa01 f304 	lsl.w	r3, r1, r4
  400336:	ea40 0003 	orr.w	r0, r0, r3
  40033a:	4629      	mov	r1, r5
  40033c:	bd30      	pop	{r4, r5, pc}
  40033e:	fa21 f004 	lsr.w	r0, r1, r4
  400342:	4629      	mov	r1, r5
  400344:	bd30      	pop	{r4, r5, pc}
  400346:	f094 0f00 	teq	r4, #0
  40034a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  40034e:	bf06      	itte	eq
  400350:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  400354:	3401      	addeq	r4, #1
  400356:	3d01      	subne	r5, #1
  400358:	e74e      	b.n	4001f8 <__adddf3+0x8c>
  40035a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40035e:	bf18      	it	ne
  400360:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  400364:	d029      	beq.n	4003ba <__adddf3+0x24e>
  400366:	ea94 0f05 	teq	r4, r5
  40036a:	bf08      	it	eq
  40036c:	ea90 0f02 	teqeq	r0, r2
  400370:	d005      	beq.n	40037e <__adddf3+0x212>
  400372:	ea54 0c00 	orrs.w	ip, r4, r0
  400376:	bf04      	itt	eq
  400378:	4619      	moveq	r1, r3
  40037a:	4610      	moveq	r0, r2
  40037c:	bd30      	pop	{r4, r5, pc}
  40037e:	ea91 0f03 	teq	r1, r3
  400382:	bf1e      	ittt	ne
  400384:	2100      	movne	r1, #0
  400386:	2000      	movne	r0, #0
  400388:	bd30      	popne	{r4, r5, pc}
  40038a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  40038e:	d105      	bne.n	40039c <__adddf3+0x230>
  400390:	0040      	lsls	r0, r0, #1
  400392:	4149      	adcs	r1, r1
  400394:	bf28      	it	cs
  400396:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  40039a:	bd30      	pop	{r4, r5, pc}
  40039c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  4003a0:	bf3c      	itt	cc
  4003a2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  4003a6:	bd30      	popcc	{r4, r5, pc}
  4003a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  4003ac:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  4003b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4003b4:	f04f 0000 	mov.w	r0, #0
  4003b8:	bd30      	pop	{r4, r5, pc}
  4003ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4003be:	bf1a      	itte	ne
  4003c0:	4619      	movne	r1, r3
  4003c2:	4610      	movne	r0, r2
  4003c4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  4003c8:	bf1c      	itt	ne
  4003ca:	460b      	movne	r3, r1
  4003cc:	4602      	movne	r2, r0
  4003ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4003d2:	bf06      	itte	eq
  4003d4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4003d8:	ea91 0f03 	teqeq	r1, r3
  4003dc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  4003e0:	bd30      	pop	{r4, r5, pc}
  4003e2:	bf00      	nop

004003e4 <__aeabi_ui2d>:
  4003e4:	f090 0f00 	teq	r0, #0
  4003e8:	bf04      	itt	eq
  4003ea:	2100      	moveq	r1, #0
  4003ec:	4770      	bxeq	lr
  4003ee:	b530      	push	{r4, r5, lr}
  4003f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4003f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4003f8:	f04f 0500 	mov.w	r5, #0
  4003fc:	f04f 0100 	mov.w	r1, #0
  400400:	e750      	b.n	4002a4 <__adddf3+0x138>
  400402:	bf00      	nop

00400404 <__aeabi_i2d>:
  400404:	f090 0f00 	teq	r0, #0
  400408:	bf04      	itt	eq
  40040a:	2100      	moveq	r1, #0
  40040c:	4770      	bxeq	lr
  40040e:	b530      	push	{r4, r5, lr}
  400410:	f44f 6480 	mov.w	r4, #1024	; 0x400
  400414:	f104 0432 	add.w	r4, r4, #50	; 0x32
  400418:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  40041c:	bf48      	it	mi
  40041e:	4240      	negmi	r0, r0
  400420:	f04f 0100 	mov.w	r1, #0
  400424:	e73e      	b.n	4002a4 <__adddf3+0x138>
  400426:	bf00      	nop

00400428 <__aeabi_f2d>:
  400428:	0042      	lsls	r2, r0, #1
  40042a:	ea4f 01e2 	mov.w	r1, r2, asr #3
  40042e:	ea4f 0131 	mov.w	r1, r1, rrx
  400432:	ea4f 7002 	mov.w	r0, r2, lsl #28
  400436:	bf1f      	itttt	ne
  400438:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  40043c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  400440:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  400444:	4770      	bxne	lr
  400446:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
  40044a:	bf08      	it	eq
  40044c:	4770      	bxeq	lr
  40044e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
  400452:	bf04      	itt	eq
  400454:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
  400458:	4770      	bxeq	lr
  40045a:	b530      	push	{r4, r5, lr}
  40045c:	f44f 7460 	mov.w	r4, #896	; 0x380
  400460:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  400464:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  400468:	e71c      	b.n	4002a4 <__adddf3+0x138>
  40046a:	bf00      	nop

0040046c <__aeabi_ul2d>:
  40046c:	ea50 0201 	orrs.w	r2, r0, r1
  400470:	bf08      	it	eq
  400472:	4770      	bxeq	lr
  400474:	b530      	push	{r4, r5, lr}
  400476:	f04f 0500 	mov.w	r5, #0
  40047a:	e00a      	b.n	400492 <__aeabi_l2d+0x16>

0040047c <__aeabi_l2d>:
  40047c:	ea50 0201 	orrs.w	r2, r0, r1
  400480:	bf08      	it	eq
  400482:	4770      	bxeq	lr
  400484:	b530      	push	{r4, r5, lr}
  400486:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  40048a:	d502      	bpl.n	400492 <__aeabi_l2d+0x16>
  40048c:	4240      	negs	r0, r0
  40048e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  400492:	f44f 6480 	mov.w	r4, #1024	; 0x400
  400496:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40049a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  40049e:	f43f aed8 	beq.w	400252 <__adddf3+0xe6>
  4004a2:	f04f 0203 	mov.w	r2, #3
  4004a6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4004aa:	bf18      	it	ne
  4004ac:	3203      	addne	r2, #3
  4004ae:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4004b2:	bf18      	it	ne
  4004b4:	3203      	addne	r2, #3
  4004b6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  4004ba:	f1c2 0320 	rsb	r3, r2, #32
  4004be:	fa00 fc03 	lsl.w	ip, r0, r3
  4004c2:	fa20 f002 	lsr.w	r0, r0, r2
  4004c6:	fa01 fe03 	lsl.w	lr, r1, r3
  4004ca:	ea40 000e 	orr.w	r0, r0, lr
  4004ce:	fa21 f102 	lsr.w	r1, r1, r2
  4004d2:	4414      	add	r4, r2
  4004d4:	e6bd      	b.n	400252 <__adddf3+0xe6>
  4004d6:	bf00      	nop

004004d8 <__aeabi_dmul>:
  4004d8:	b570      	push	{r4, r5, r6, lr}
  4004da:	f04f 0cff 	mov.w	ip, #255	; 0xff
  4004de:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  4004e2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  4004e6:	bf1d      	ittte	ne
  4004e8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  4004ec:	ea94 0f0c 	teqne	r4, ip
  4004f0:	ea95 0f0c 	teqne	r5, ip
  4004f4:	f000 f8de 	bleq	4006b4 <__aeabi_dmul+0x1dc>
  4004f8:	442c      	add	r4, r5
  4004fa:	ea81 0603 	eor.w	r6, r1, r3
  4004fe:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  400502:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  400506:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  40050a:	bf18      	it	ne
  40050c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  400510:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  400514:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  400518:	d038      	beq.n	40058c <__aeabi_dmul+0xb4>
  40051a:	fba0 ce02 	umull	ip, lr, r0, r2
  40051e:	f04f 0500 	mov.w	r5, #0
  400522:	fbe1 e502 	umlal	lr, r5, r1, r2
  400526:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  40052a:	fbe0 e503 	umlal	lr, r5, r0, r3
  40052e:	f04f 0600 	mov.w	r6, #0
  400532:	fbe1 5603 	umlal	r5, r6, r1, r3
  400536:	f09c 0f00 	teq	ip, #0
  40053a:	bf18      	it	ne
  40053c:	f04e 0e01 	orrne.w	lr, lr, #1
  400540:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  400544:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  400548:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  40054c:	d204      	bcs.n	400558 <__aeabi_dmul+0x80>
  40054e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  400552:	416d      	adcs	r5, r5
  400554:	eb46 0606 	adc.w	r6, r6, r6
  400558:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  40055c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  400560:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  400564:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  400568:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  40056c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  400570:	bf88      	it	hi
  400572:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  400576:	d81e      	bhi.n	4005b6 <__aeabi_dmul+0xde>
  400578:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  40057c:	bf08      	it	eq
  40057e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  400582:	f150 0000 	adcs.w	r0, r0, #0
  400586:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40058a:	bd70      	pop	{r4, r5, r6, pc}
  40058c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  400590:	ea46 0101 	orr.w	r1, r6, r1
  400594:	ea40 0002 	orr.w	r0, r0, r2
  400598:	ea81 0103 	eor.w	r1, r1, r3
  40059c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  4005a0:	bfc2      	ittt	gt
  4005a2:	ebd4 050c 	rsbsgt	r5, r4, ip
  4005a6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  4005aa:	bd70      	popgt	{r4, r5, r6, pc}
  4005ac:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4005b0:	f04f 0e00 	mov.w	lr, #0
  4005b4:	3c01      	subs	r4, #1
  4005b6:	f300 80ab 	bgt.w	400710 <__aeabi_dmul+0x238>
  4005ba:	f114 0f36 	cmn.w	r4, #54	; 0x36
  4005be:	bfde      	ittt	le
  4005c0:	2000      	movle	r0, #0
  4005c2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  4005c6:	bd70      	pople	{r4, r5, r6, pc}
  4005c8:	f1c4 0400 	rsb	r4, r4, #0
  4005cc:	3c20      	subs	r4, #32
  4005ce:	da35      	bge.n	40063c <__aeabi_dmul+0x164>
  4005d0:	340c      	adds	r4, #12
  4005d2:	dc1b      	bgt.n	40060c <__aeabi_dmul+0x134>
  4005d4:	f104 0414 	add.w	r4, r4, #20
  4005d8:	f1c4 0520 	rsb	r5, r4, #32
  4005dc:	fa00 f305 	lsl.w	r3, r0, r5
  4005e0:	fa20 f004 	lsr.w	r0, r0, r4
  4005e4:	fa01 f205 	lsl.w	r2, r1, r5
  4005e8:	ea40 0002 	orr.w	r0, r0, r2
  4005ec:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  4005f0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  4005f4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  4005f8:	fa21 f604 	lsr.w	r6, r1, r4
  4005fc:	eb42 0106 	adc.w	r1, r2, r6
  400600:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  400604:	bf08      	it	eq
  400606:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40060a:	bd70      	pop	{r4, r5, r6, pc}
  40060c:	f1c4 040c 	rsb	r4, r4, #12
  400610:	f1c4 0520 	rsb	r5, r4, #32
  400614:	fa00 f304 	lsl.w	r3, r0, r4
  400618:	fa20 f005 	lsr.w	r0, r0, r5
  40061c:	fa01 f204 	lsl.w	r2, r1, r4
  400620:	ea40 0002 	orr.w	r0, r0, r2
  400624:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  400628:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  40062c:	f141 0100 	adc.w	r1, r1, #0
  400630:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  400634:	bf08      	it	eq
  400636:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40063a:	bd70      	pop	{r4, r5, r6, pc}
  40063c:	f1c4 0520 	rsb	r5, r4, #32
  400640:	fa00 f205 	lsl.w	r2, r0, r5
  400644:	ea4e 0e02 	orr.w	lr, lr, r2
  400648:	fa20 f304 	lsr.w	r3, r0, r4
  40064c:	fa01 f205 	lsl.w	r2, r1, r5
  400650:	ea43 0302 	orr.w	r3, r3, r2
  400654:	fa21 f004 	lsr.w	r0, r1, r4
  400658:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40065c:	fa21 f204 	lsr.w	r2, r1, r4
  400660:	ea20 0002 	bic.w	r0, r0, r2
  400664:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  400668:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40066c:	bf08      	it	eq
  40066e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  400672:	bd70      	pop	{r4, r5, r6, pc}
  400674:	f094 0f00 	teq	r4, #0
  400678:	d10f      	bne.n	40069a <__aeabi_dmul+0x1c2>
  40067a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  40067e:	0040      	lsls	r0, r0, #1
  400680:	eb41 0101 	adc.w	r1, r1, r1
  400684:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  400688:	bf08      	it	eq
  40068a:	3c01      	subeq	r4, #1
  40068c:	d0f7      	beq.n	40067e <__aeabi_dmul+0x1a6>
  40068e:	ea41 0106 	orr.w	r1, r1, r6
  400692:	f095 0f00 	teq	r5, #0
  400696:	bf18      	it	ne
  400698:	4770      	bxne	lr
  40069a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  40069e:	0052      	lsls	r2, r2, #1
  4006a0:	eb43 0303 	adc.w	r3, r3, r3
  4006a4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  4006a8:	bf08      	it	eq
  4006aa:	3d01      	subeq	r5, #1
  4006ac:	d0f7      	beq.n	40069e <__aeabi_dmul+0x1c6>
  4006ae:	ea43 0306 	orr.w	r3, r3, r6
  4006b2:	4770      	bx	lr
  4006b4:	ea94 0f0c 	teq	r4, ip
  4006b8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  4006bc:	bf18      	it	ne
  4006be:	ea95 0f0c 	teqne	r5, ip
  4006c2:	d00c      	beq.n	4006de <__aeabi_dmul+0x206>
  4006c4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4006c8:	bf18      	it	ne
  4006ca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4006ce:	d1d1      	bne.n	400674 <__aeabi_dmul+0x19c>
  4006d0:	ea81 0103 	eor.w	r1, r1, r3
  4006d4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4006d8:	f04f 0000 	mov.w	r0, #0
  4006dc:	bd70      	pop	{r4, r5, r6, pc}
  4006de:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4006e2:	bf06      	itte	eq
  4006e4:	4610      	moveq	r0, r2
  4006e6:	4619      	moveq	r1, r3
  4006e8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4006ec:	d019      	beq.n	400722 <__aeabi_dmul+0x24a>
  4006ee:	ea94 0f0c 	teq	r4, ip
  4006f2:	d102      	bne.n	4006fa <__aeabi_dmul+0x222>
  4006f4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  4006f8:	d113      	bne.n	400722 <__aeabi_dmul+0x24a>
  4006fa:	ea95 0f0c 	teq	r5, ip
  4006fe:	d105      	bne.n	40070c <__aeabi_dmul+0x234>
  400700:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  400704:	bf1c      	itt	ne
  400706:	4610      	movne	r0, r2
  400708:	4619      	movne	r1, r3
  40070a:	d10a      	bne.n	400722 <__aeabi_dmul+0x24a>
  40070c:	ea81 0103 	eor.w	r1, r1, r3
  400710:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  400714:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  400718:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  40071c:	f04f 0000 	mov.w	r0, #0
  400720:	bd70      	pop	{r4, r5, r6, pc}
  400722:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  400726:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  40072a:	bd70      	pop	{r4, r5, r6, pc}

0040072c <__aeabi_ddiv>:
  40072c:	b570      	push	{r4, r5, r6, lr}
  40072e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  400732:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  400736:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  40073a:	bf1d      	ittte	ne
  40073c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  400740:	ea94 0f0c 	teqne	r4, ip
  400744:	ea95 0f0c 	teqne	r5, ip
  400748:	f000 f8a7 	bleq	40089a <__aeabi_ddiv+0x16e>
  40074c:	eba4 0405 	sub.w	r4, r4, r5
  400750:	ea81 0e03 	eor.w	lr, r1, r3
  400754:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  400758:	ea4f 3101 	mov.w	r1, r1, lsl #12
  40075c:	f000 8088 	beq.w	400870 <__aeabi_ddiv+0x144>
  400760:	ea4f 3303 	mov.w	r3, r3, lsl #12
  400764:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  400768:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  40076c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  400770:	ea4f 2202 	mov.w	r2, r2, lsl #8
  400774:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  400778:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  40077c:	ea4f 2600 	mov.w	r6, r0, lsl #8
  400780:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  400784:	429d      	cmp	r5, r3
  400786:	bf08      	it	eq
  400788:	4296      	cmpeq	r6, r2
  40078a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  40078e:	f504 7440 	add.w	r4, r4, #768	; 0x300
  400792:	d202      	bcs.n	40079a <__aeabi_ddiv+0x6e>
  400794:	085b      	lsrs	r3, r3, #1
  400796:	ea4f 0232 	mov.w	r2, r2, rrx
  40079a:	1ab6      	subs	r6, r6, r2
  40079c:	eb65 0503 	sbc.w	r5, r5, r3
  4007a0:	085b      	lsrs	r3, r3, #1
  4007a2:	ea4f 0232 	mov.w	r2, r2, rrx
  4007a6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  4007aa:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  4007ae:	ebb6 0e02 	subs.w	lr, r6, r2
  4007b2:	eb75 0e03 	sbcs.w	lr, r5, r3
  4007b6:	bf22      	ittt	cs
  4007b8:	1ab6      	subcs	r6, r6, r2
  4007ba:	4675      	movcs	r5, lr
  4007bc:	ea40 000c 	orrcs.w	r0, r0, ip
  4007c0:	085b      	lsrs	r3, r3, #1
  4007c2:	ea4f 0232 	mov.w	r2, r2, rrx
  4007c6:	ebb6 0e02 	subs.w	lr, r6, r2
  4007ca:	eb75 0e03 	sbcs.w	lr, r5, r3
  4007ce:	bf22      	ittt	cs
  4007d0:	1ab6      	subcs	r6, r6, r2
  4007d2:	4675      	movcs	r5, lr
  4007d4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  4007d8:	085b      	lsrs	r3, r3, #1
  4007da:	ea4f 0232 	mov.w	r2, r2, rrx
  4007de:	ebb6 0e02 	subs.w	lr, r6, r2
  4007e2:	eb75 0e03 	sbcs.w	lr, r5, r3
  4007e6:	bf22      	ittt	cs
  4007e8:	1ab6      	subcs	r6, r6, r2
  4007ea:	4675      	movcs	r5, lr
  4007ec:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  4007f0:	085b      	lsrs	r3, r3, #1
  4007f2:	ea4f 0232 	mov.w	r2, r2, rrx
  4007f6:	ebb6 0e02 	subs.w	lr, r6, r2
  4007fa:	eb75 0e03 	sbcs.w	lr, r5, r3
  4007fe:	bf22      	ittt	cs
  400800:	1ab6      	subcs	r6, r6, r2
  400802:	4675      	movcs	r5, lr
  400804:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  400808:	ea55 0e06 	orrs.w	lr, r5, r6
  40080c:	d018      	beq.n	400840 <__aeabi_ddiv+0x114>
  40080e:	ea4f 1505 	mov.w	r5, r5, lsl #4
  400812:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  400816:	ea4f 1606 	mov.w	r6, r6, lsl #4
  40081a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  40081e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  400822:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  400826:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  40082a:	d1c0      	bne.n	4007ae <__aeabi_ddiv+0x82>
  40082c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  400830:	d10b      	bne.n	40084a <__aeabi_ddiv+0x11e>
  400832:	ea41 0100 	orr.w	r1, r1, r0
  400836:	f04f 0000 	mov.w	r0, #0
  40083a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  40083e:	e7b6      	b.n	4007ae <__aeabi_ddiv+0x82>
  400840:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  400844:	bf04      	itt	eq
  400846:	4301      	orreq	r1, r0
  400848:	2000      	moveq	r0, #0
  40084a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  40084e:	bf88      	it	hi
  400850:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  400854:	f63f aeaf 	bhi.w	4005b6 <__aeabi_dmul+0xde>
  400858:	ebb5 0c03 	subs.w	ip, r5, r3
  40085c:	bf04      	itt	eq
  40085e:	ebb6 0c02 	subseq.w	ip, r6, r2
  400862:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  400866:	f150 0000 	adcs.w	r0, r0, #0
  40086a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40086e:	bd70      	pop	{r4, r5, r6, pc}
  400870:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  400874:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  400878:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  40087c:	bfc2      	ittt	gt
  40087e:	ebd4 050c 	rsbsgt	r5, r4, ip
  400882:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  400886:	bd70      	popgt	{r4, r5, r6, pc}
  400888:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40088c:	f04f 0e00 	mov.w	lr, #0
  400890:	3c01      	subs	r4, #1
  400892:	e690      	b.n	4005b6 <__aeabi_dmul+0xde>
  400894:	ea45 0e06 	orr.w	lr, r5, r6
  400898:	e68d      	b.n	4005b6 <__aeabi_dmul+0xde>
  40089a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  40089e:	ea94 0f0c 	teq	r4, ip
  4008a2:	bf08      	it	eq
  4008a4:	ea95 0f0c 	teqeq	r5, ip
  4008a8:	f43f af3b 	beq.w	400722 <__aeabi_dmul+0x24a>
  4008ac:	ea94 0f0c 	teq	r4, ip
  4008b0:	d10a      	bne.n	4008c8 <__aeabi_ddiv+0x19c>
  4008b2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4008b6:	f47f af34 	bne.w	400722 <__aeabi_dmul+0x24a>
  4008ba:	ea95 0f0c 	teq	r5, ip
  4008be:	f47f af25 	bne.w	40070c <__aeabi_dmul+0x234>
  4008c2:	4610      	mov	r0, r2
  4008c4:	4619      	mov	r1, r3
  4008c6:	e72c      	b.n	400722 <__aeabi_dmul+0x24a>
  4008c8:	ea95 0f0c 	teq	r5, ip
  4008cc:	d106      	bne.n	4008dc <__aeabi_ddiv+0x1b0>
  4008ce:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  4008d2:	f43f aefd 	beq.w	4006d0 <__aeabi_dmul+0x1f8>
  4008d6:	4610      	mov	r0, r2
  4008d8:	4619      	mov	r1, r3
  4008da:	e722      	b.n	400722 <__aeabi_dmul+0x24a>
  4008dc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4008e0:	bf18      	it	ne
  4008e2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4008e6:	f47f aec5 	bne.w	400674 <__aeabi_dmul+0x19c>
  4008ea:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  4008ee:	f47f af0d 	bne.w	40070c <__aeabi_dmul+0x234>
  4008f2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  4008f6:	f47f aeeb 	bne.w	4006d0 <__aeabi_dmul+0x1f8>
  4008fa:	e712      	b.n	400722 <__aeabi_dmul+0x24a>

004008fc <__aeabi_d2f>:
  4008fc:	ea4f 0241 	mov.w	r2, r1, lsl #1
  400900:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  400904:	bf24      	itt	cs
  400906:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  40090a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  40090e:	d90d      	bls.n	40092c <__aeabi_d2f+0x30>
  400910:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  400914:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  400918:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  40091c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  400920:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  400924:	bf08      	it	eq
  400926:	f020 0001 	biceq.w	r0, r0, #1
  40092a:	4770      	bx	lr
  40092c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  400930:	d121      	bne.n	400976 <__aeabi_d2f+0x7a>
  400932:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  400936:	bfbc      	itt	lt
  400938:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  40093c:	4770      	bxlt	lr
  40093e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  400942:	ea4f 5252 	mov.w	r2, r2, lsr #21
  400946:	f1c2 0218 	rsb	r2, r2, #24
  40094a:	f1c2 0c20 	rsb	ip, r2, #32
  40094e:	fa10 f30c 	lsls.w	r3, r0, ip
  400952:	fa20 f002 	lsr.w	r0, r0, r2
  400956:	bf18      	it	ne
  400958:	f040 0001 	orrne.w	r0, r0, #1
  40095c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  400960:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  400964:	fa03 fc0c 	lsl.w	ip, r3, ip
  400968:	ea40 000c 	orr.w	r0, r0, ip
  40096c:	fa23 f302 	lsr.w	r3, r3, r2
  400970:	ea4f 0343 	mov.w	r3, r3, lsl #1
  400974:	e7cc      	b.n	400910 <__aeabi_d2f+0x14>
  400976:	ea7f 5362 	mvns.w	r3, r2, asr #21
  40097a:	d107      	bne.n	40098c <__aeabi_d2f+0x90>
  40097c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  400980:	bf1e      	ittt	ne
  400982:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  400986:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  40098a:	4770      	bxne	lr
  40098c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  400990:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  400994:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  400998:	4770      	bx	lr
  40099a:	bf00      	nop

0040099c <__aeabi_frsub>:
  40099c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  4009a0:	e002      	b.n	4009a8 <__addsf3>
  4009a2:	bf00      	nop

004009a4 <__aeabi_fsub>:
  4009a4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

004009a8 <__addsf3>:
  4009a8:	0042      	lsls	r2, r0, #1
  4009aa:	bf1f      	itttt	ne
  4009ac:	ea5f 0341 	movsne.w	r3, r1, lsl #1
  4009b0:	ea92 0f03 	teqne	r2, r3
  4009b4:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
  4009b8:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  4009bc:	d06a      	beq.n	400a94 <__addsf3+0xec>
  4009be:	ea4f 6212 	mov.w	r2, r2, lsr #24
  4009c2:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
  4009c6:	bfc1      	itttt	gt
  4009c8:	18d2      	addgt	r2, r2, r3
  4009ca:	4041      	eorgt	r1, r0
  4009cc:	4048      	eorgt	r0, r1
  4009ce:	4041      	eorgt	r1, r0
  4009d0:	bfb8      	it	lt
  4009d2:	425b      	neglt	r3, r3
  4009d4:	2b19      	cmp	r3, #25
  4009d6:	bf88      	it	hi
  4009d8:	4770      	bxhi	lr
  4009da:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  4009de:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  4009e2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  4009e6:	bf18      	it	ne
  4009e8:	4240      	negne	r0, r0
  4009ea:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4009ee:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  4009f2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  4009f6:	bf18      	it	ne
  4009f8:	4249      	negne	r1, r1
  4009fa:	ea92 0f03 	teq	r2, r3
  4009fe:	d03f      	beq.n	400a80 <__addsf3+0xd8>
  400a00:	f1a2 0201 	sub.w	r2, r2, #1
  400a04:	fa41 fc03 	asr.w	ip, r1, r3
  400a08:	eb10 000c 	adds.w	r0, r0, ip
  400a0c:	f1c3 0320 	rsb	r3, r3, #32
  400a10:	fa01 f103 	lsl.w	r1, r1, r3
  400a14:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  400a18:	d502      	bpl.n	400a20 <__addsf3+0x78>
  400a1a:	4249      	negs	r1, r1
  400a1c:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
  400a20:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
  400a24:	d313      	bcc.n	400a4e <__addsf3+0xa6>
  400a26:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  400a2a:	d306      	bcc.n	400a3a <__addsf3+0x92>
  400a2c:	0840      	lsrs	r0, r0, #1
  400a2e:	ea4f 0131 	mov.w	r1, r1, rrx
  400a32:	f102 0201 	add.w	r2, r2, #1
  400a36:	2afe      	cmp	r2, #254	; 0xfe
  400a38:	d251      	bcs.n	400ade <__addsf3+0x136>
  400a3a:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
  400a3e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  400a42:	bf08      	it	eq
  400a44:	f020 0001 	biceq.w	r0, r0, #1
  400a48:	ea40 0003 	orr.w	r0, r0, r3
  400a4c:	4770      	bx	lr
  400a4e:	0049      	lsls	r1, r1, #1
  400a50:	eb40 0000 	adc.w	r0, r0, r0
  400a54:	3a01      	subs	r2, #1
  400a56:	bf28      	it	cs
  400a58:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
  400a5c:	d2ed      	bcs.n	400a3a <__addsf3+0x92>
  400a5e:	fab0 fc80 	clz	ip, r0
  400a62:	f1ac 0c08 	sub.w	ip, ip, #8
  400a66:	ebb2 020c 	subs.w	r2, r2, ip
  400a6a:	fa00 f00c 	lsl.w	r0, r0, ip
  400a6e:	bfaa      	itet	ge
  400a70:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
  400a74:	4252      	neglt	r2, r2
  400a76:	4318      	orrge	r0, r3
  400a78:	bfbc      	itt	lt
  400a7a:	40d0      	lsrlt	r0, r2
  400a7c:	4318      	orrlt	r0, r3
  400a7e:	4770      	bx	lr
  400a80:	f092 0f00 	teq	r2, #0
  400a84:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
  400a88:	bf06      	itte	eq
  400a8a:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
  400a8e:	3201      	addeq	r2, #1
  400a90:	3b01      	subne	r3, #1
  400a92:	e7b5      	b.n	400a00 <__addsf3+0x58>
  400a94:	ea4f 0341 	mov.w	r3, r1, lsl #1
  400a98:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  400a9c:	bf18      	it	ne
  400a9e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  400aa2:	d021      	beq.n	400ae8 <__addsf3+0x140>
  400aa4:	ea92 0f03 	teq	r2, r3
  400aa8:	d004      	beq.n	400ab4 <__addsf3+0x10c>
  400aaa:	f092 0f00 	teq	r2, #0
  400aae:	bf08      	it	eq
  400ab0:	4608      	moveq	r0, r1
  400ab2:	4770      	bx	lr
  400ab4:	ea90 0f01 	teq	r0, r1
  400ab8:	bf1c      	itt	ne
  400aba:	2000      	movne	r0, #0
  400abc:	4770      	bxne	lr
  400abe:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
  400ac2:	d104      	bne.n	400ace <__addsf3+0x126>
  400ac4:	0040      	lsls	r0, r0, #1
  400ac6:	bf28      	it	cs
  400ac8:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
  400acc:	4770      	bx	lr
  400ace:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
  400ad2:	bf3c      	itt	cc
  400ad4:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
  400ad8:	4770      	bxcc	lr
  400ada:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  400ade:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
  400ae2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  400ae6:	4770      	bx	lr
  400ae8:	ea7f 6222 	mvns.w	r2, r2, asr #24
  400aec:	bf16      	itet	ne
  400aee:	4608      	movne	r0, r1
  400af0:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
  400af4:	4601      	movne	r1, r0
  400af6:	0242      	lsls	r2, r0, #9
  400af8:	bf06      	itte	eq
  400afa:	ea5f 2341 	movseq.w	r3, r1, lsl #9
  400afe:	ea90 0f01 	teqeq	r0, r1
  400b02:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
  400b06:	4770      	bx	lr

00400b08 <__aeabi_ui2f>:
  400b08:	f04f 0300 	mov.w	r3, #0
  400b0c:	e004      	b.n	400b18 <__aeabi_i2f+0x8>
  400b0e:	bf00      	nop

00400b10 <__aeabi_i2f>:
  400b10:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
  400b14:	bf48      	it	mi
  400b16:	4240      	negmi	r0, r0
  400b18:	ea5f 0c00 	movs.w	ip, r0
  400b1c:	bf08      	it	eq
  400b1e:	4770      	bxeq	lr
  400b20:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
  400b24:	4601      	mov	r1, r0
  400b26:	f04f 0000 	mov.w	r0, #0
  400b2a:	e01c      	b.n	400b66 <__aeabi_l2f+0x2a>

00400b2c <__aeabi_ul2f>:
  400b2c:	ea50 0201 	orrs.w	r2, r0, r1
  400b30:	bf08      	it	eq
  400b32:	4770      	bxeq	lr
  400b34:	f04f 0300 	mov.w	r3, #0
  400b38:	e00a      	b.n	400b50 <__aeabi_l2f+0x14>
  400b3a:	bf00      	nop

00400b3c <__aeabi_l2f>:
  400b3c:	ea50 0201 	orrs.w	r2, r0, r1
  400b40:	bf08      	it	eq
  400b42:	4770      	bxeq	lr
  400b44:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
  400b48:	d502      	bpl.n	400b50 <__aeabi_l2f+0x14>
  400b4a:	4240      	negs	r0, r0
  400b4c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  400b50:	ea5f 0c01 	movs.w	ip, r1
  400b54:	bf02      	ittt	eq
  400b56:	4684      	moveq	ip, r0
  400b58:	4601      	moveq	r1, r0
  400b5a:	2000      	moveq	r0, #0
  400b5c:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
  400b60:	bf08      	it	eq
  400b62:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
  400b66:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
  400b6a:	fabc f28c 	clz	r2, ip
  400b6e:	3a08      	subs	r2, #8
  400b70:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
  400b74:	db10      	blt.n	400b98 <__aeabi_l2f+0x5c>
  400b76:	fa01 fc02 	lsl.w	ip, r1, r2
  400b7a:	4463      	add	r3, ip
  400b7c:	fa00 fc02 	lsl.w	ip, r0, r2
  400b80:	f1c2 0220 	rsb	r2, r2, #32
  400b84:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  400b88:	fa20 f202 	lsr.w	r2, r0, r2
  400b8c:	eb43 0002 	adc.w	r0, r3, r2
  400b90:	bf08      	it	eq
  400b92:	f020 0001 	biceq.w	r0, r0, #1
  400b96:	4770      	bx	lr
  400b98:	f102 0220 	add.w	r2, r2, #32
  400b9c:	fa01 fc02 	lsl.w	ip, r1, r2
  400ba0:	f1c2 0220 	rsb	r2, r2, #32
  400ba4:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
  400ba8:	fa21 f202 	lsr.w	r2, r1, r2
  400bac:	eb43 0002 	adc.w	r0, r3, r2
  400bb0:	bf08      	it	eq
  400bb2:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  400bb6:	4770      	bx	lr

00400bb8 <__aeabi_fmul>:
  400bb8:	f04f 0cff 	mov.w	ip, #255	; 0xff
  400bbc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
  400bc0:	bf1e      	ittt	ne
  400bc2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
  400bc6:	ea92 0f0c 	teqne	r2, ip
  400bca:	ea93 0f0c 	teqne	r3, ip
  400bce:	d06f      	beq.n	400cb0 <__aeabi_fmul+0xf8>
  400bd0:	441a      	add	r2, r3
  400bd2:	ea80 0c01 	eor.w	ip, r0, r1
  400bd6:	0240      	lsls	r0, r0, #9
  400bd8:	bf18      	it	ne
  400bda:	ea5f 2141 	movsne.w	r1, r1, lsl #9
  400bde:	d01e      	beq.n	400c1e <__aeabi_fmul+0x66>
  400be0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  400be4:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
  400be8:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
  400bec:	fba0 3101 	umull	r3, r1, r0, r1
  400bf0:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
  400bf4:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
  400bf8:	bf3e      	ittt	cc
  400bfa:	0049      	lslcc	r1, r1, #1
  400bfc:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
  400c00:	005b      	lslcc	r3, r3, #1
  400c02:	ea40 0001 	orr.w	r0, r0, r1
  400c06:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
  400c0a:	2afd      	cmp	r2, #253	; 0xfd
  400c0c:	d81d      	bhi.n	400c4a <__aeabi_fmul+0x92>
  400c0e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
  400c12:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  400c16:	bf08      	it	eq
  400c18:	f020 0001 	biceq.w	r0, r0, #1
  400c1c:	4770      	bx	lr
  400c1e:	f090 0f00 	teq	r0, #0
  400c22:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
  400c26:	bf08      	it	eq
  400c28:	0249      	lsleq	r1, r1, #9
  400c2a:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
  400c2e:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
  400c32:	3a7f      	subs	r2, #127	; 0x7f
  400c34:	bfc2      	ittt	gt
  400c36:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
  400c3a:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
  400c3e:	4770      	bxgt	lr
  400c40:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  400c44:	f04f 0300 	mov.w	r3, #0
  400c48:	3a01      	subs	r2, #1
  400c4a:	dc5d      	bgt.n	400d08 <__aeabi_fmul+0x150>
  400c4c:	f112 0f19 	cmn.w	r2, #25
  400c50:	bfdc      	itt	le
  400c52:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
  400c56:	4770      	bxle	lr
  400c58:	f1c2 0200 	rsb	r2, r2, #0
  400c5c:	0041      	lsls	r1, r0, #1
  400c5e:	fa21 f102 	lsr.w	r1, r1, r2
  400c62:	f1c2 0220 	rsb	r2, r2, #32
  400c66:	fa00 fc02 	lsl.w	ip, r0, r2
  400c6a:	ea5f 0031 	movs.w	r0, r1, rrx
  400c6e:	f140 0000 	adc.w	r0, r0, #0
  400c72:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
  400c76:	bf08      	it	eq
  400c78:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  400c7c:	4770      	bx	lr
  400c7e:	f092 0f00 	teq	r2, #0
  400c82:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
  400c86:	bf02      	ittt	eq
  400c88:	0040      	lsleq	r0, r0, #1
  400c8a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
  400c8e:	3a01      	subeq	r2, #1
  400c90:	d0f9      	beq.n	400c86 <__aeabi_fmul+0xce>
  400c92:	ea40 000c 	orr.w	r0, r0, ip
  400c96:	f093 0f00 	teq	r3, #0
  400c9a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  400c9e:	bf02      	ittt	eq
  400ca0:	0049      	lsleq	r1, r1, #1
  400ca2:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
  400ca6:	3b01      	subeq	r3, #1
  400ca8:	d0f9      	beq.n	400c9e <__aeabi_fmul+0xe6>
  400caa:	ea41 010c 	orr.w	r1, r1, ip
  400cae:	e78f      	b.n	400bd0 <__aeabi_fmul+0x18>
  400cb0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
  400cb4:	ea92 0f0c 	teq	r2, ip
  400cb8:	bf18      	it	ne
  400cba:	ea93 0f0c 	teqne	r3, ip
  400cbe:	d00a      	beq.n	400cd6 <__aeabi_fmul+0x11e>
  400cc0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
  400cc4:	bf18      	it	ne
  400cc6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
  400cca:	d1d8      	bne.n	400c7e <__aeabi_fmul+0xc6>
  400ccc:	ea80 0001 	eor.w	r0, r0, r1
  400cd0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  400cd4:	4770      	bx	lr
  400cd6:	f090 0f00 	teq	r0, #0
  400cda:	bf17      	itett	ne
  400cdc:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
  400ce0:	4608      	moveq	r0, r1
  400ce2:	f091 0f00 	teqne	r1, #0
  400ce6:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
  400cea:	d014      	beq.n	400d16 <__aeabi_fmul+0x15e>
  400cec:	ea92 0f0c 	teq	r2, ip
  400cf0:	d101      	bne.n	400cf6 <__aeabi_fmul+0x13e>
  400cf2:	0242      	lsls	r2, r0, #9
  400cf4:	d10f      	bne.n	400d16 <__aeabi_fmul+0x15e>
  400cf6:	ea93 0f0c 	teq	r3, ip
  400cfa:	d103      	bne.n	400d04 <__aeabi_fmul+0x14c>
  400cfc:	024b      	lsls	r3, r1, #9
  400cfe:	bf18      	it	ne
  400d00:	4608      	movne	r0, r1
  400d02:	d108      	bne.n	400d16 <__aeabi_fmul+0x15e>
  400d04:	ea80 0001 	eor.w	r0, r0, r1
  400d08:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  400d0c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  400d10:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  400d14:	4770      	bx	lr
  400d16:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  400d1a:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
  400d1e:	4770      	bx	lr

00400d20 <__aeabi_fdiv>:
  400d20:	f04f 0cff 	mov.w	ip, #255	; 0xff
  400d24:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
  400d28:	bf1e      	ittt	ne
  400d2a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
  400d2e:	ea92 0f0c 	teqne	r2, ip
  400d32:	ea93 0f0c 	teqne	r3, ip
  400d36:	d069      	beq.n	400e0c <__aeabi_fdiv+0xec>
  400d38:	eba2 0203 	sub.w	r2, r2, r3
  400d3c:	ea80 0c01 	eor.w	ip, r0, r1
  400d40:	0249      	lsls	r1, r1, #9
  400d42:	ea4f 2040 	mov.w	r0, r0, lsl #9
  400d46:	d037      	beq.n	400db8 <__aeabi_fdiv+0x98>
  400d48:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  400d4c:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
  400d50:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
  400d54:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
  400d58:	428b      	cmp	r3, r1
  400d5a:	bf38      	it	cc
  400d5c:	005b      	lslcc	r3, r3, #1
  400d5e:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
  400d62:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
  400d66:	428b      	cmp	r3, r1
  400d68:	bf24      	itt	cs
  400d6a:	1a5b      	subcs	r3, r3, r1
  400d6c:	ea40 000c 	orrcs.w	r0, r0, ip
  400d70:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
  400d74:	bf24      	itt	cs
  400d76:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
  400d7a:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  400d7e:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
  400d82:	bf24      	itt	cs
  400d84:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
  400d88:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  400d8c:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
  400d90:	bf24      	itt	cs
  400d92:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
  400d96:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  400d9a:	011b      	lsls	r3, r3, #4
  400d9c:	bf18      	it	ne
  400d9e:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
  400da2:	d1e0      	bne.n	400d66 <__aeabi_fdiv+0x46>
  400da4:	2afd      	cmp	r2, #253	; 0xfd
  400da6:	f63f af50 	bhi.w	400c4a <__aeabi_fmul+0x92>
  400daa:	428b      	cmp	r3, r1
  400dac:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  400db0:	bf08      	it	eq
  400db2:	f020 0001 	biceq.w	r0, r0, #1
  400db6:	4770      	bx	lr
  400db8:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
  400dbc:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
  400dc0:	327f      	adds	r2, #127	; 0x7f
  400dc2:	bfc2      	ittt	gt
  400dc4:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
  400dc8:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
  400dcc:	4770      	bxgt	lr
  400dce:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  400dd2:	f04f 0300 	mov.w	r3, #0
  400dd6:	3a01      	subs	r2, #1
  400dd8:	e737      	b.n	400c4a <__aeabi_fmul+0x92>
  400dda:	f092 0f00 	teq	r2, #0
  400dde:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
  400de2:	bf02      	ittt	eq
  400de4:	0040      	lsleq	r0, r0, #1
  400de6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
  400dea:	3a01      	subeq	r2, #1
  400dec:	d0f9      	beq.n	400de2 <__aeabi_fdiv+0xc2>
  400dee:	ea40 000c 	orr.w	r0, r0, ip
  400df2:	f093 0f00 	teq	r3, #0
  400df6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  400dfa:	bf02      	ittt	eq
  400dfc:	0049      	lsleq	r1, r1, #1
  400dfe:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
  400e02:	3b01      	subeq	r3, #1
  400e04:	d0f9      	beq.n	400dfa <__aeabi_fdiv+0xda>
  400e06:	ea41 010c 	orr.w	r1, r1, ip
  400e0a:	e795      	b.n	400d38 <__aeabi_fdiv+0x18>
  400e0c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
  400e10:	ea92 0f0c 	teq	r2, ip
  400e14:	d108      	bne.n	400e28 <__aeabi_fdiv+0x108>
  400e16:	0242      	lsls	r2, r0, #9
  400e18:	f47f af7d 	bne.w	400d16 <__aeabi_fmul+0x15e>
  400e1c:	ea93 0f0c 	teq	r3, ip
  400e20:	f47f af70 	bne.w	400d04 <__aeabi_fmul+0x14c>
  400e24:	4608      	mov	r0, r1
  400e26:	e776      	b.n	400d16 <__aeabi_fmul+0x15e>
  400e28:	ea93 0f0c 	teq	r3, ip
  400e2c:	d104      	bne.n	400e38 <__aeabi_fdiv+0x118>
  400e2e:	024b      	lsls	r3, r1, #9
  400e30:	f43f af4c 	beq.w	400ccc <__aeabi_fmul+0x114>
  400e34:	4608      	mov	r0, r1
  400e36:	e76e      	b.n	400d16 <__aeabi_fmul+0x15e>
  400e38:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
  400e3c:	bf18      	it	ne
  400e3e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
  400e42:	d1ca      	bne.n	400dda <__aeabi_fdiv+0xba>
  400e44:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
  400e48:	f47f af5c 	bne.w	400d04 <__aeabi_fmul+0x14c>
  400e4c:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
  400e50:	f47f af3c 	bne.w	400ccc <__aeabi_fmul+0x114>
  400e54:	e75f      	b.n	400d16 <__aeabi_fmul+0x15e>
  400e56:	bf00      	nop

00400e58 <__aeabi_f2iz>:
  400e58:	ea4f 0240 	mov.w	r2, r0, lsl #1
  400e5c:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
  400e60:	d30f      	bcc.n	400e82 <__aeabi_f2iz+0x2a>
  400e62:	f04f 039e 	mov.w	r3, #158	; 0x9e
  400e66:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
  400e6a:	d90d      	bls.n	400e88 <__aeabi_f2iz+0x30>
  400e6c:	ea4f 2300 	mov.w	r3, r0, lsl #8
  400e70:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  400e74:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  400e78:	fa23 f002 	lsr.w	r0, r3, r2
  400e7c:	bf18      	it	ne
  400e7e:	4240      	negne	r0, r0
  400e80:	4770      	bx	lr
  400e82:	f04f 0000 	mov.w	r0, #0
  400e86:	4770      	bx	lr
  400e88:	f112 0f61 	cmn.w	r2, #97	; 0x61
  400e8c:	d101      	bne.n	400e92 <__aeabi_f2iz+0x3a>
  400e8e:	0242      	lsls	r2, r0, #9
  400e90:	d105      	bne.n	400e9e <__aeabi_f2iz+0x46>
  400e92:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
  400e96:	bf08      	it	eq
  400e98:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  400e9c:	4770      	bx	lr
  400e9e:	f04f 0000 	mov.w	r0, #0
  400ea2:	4770      	bx	lr

00400ea4 <__aeabi_f2uiz>:
  400ea4:	0042      	lsls	r2, r0, #1
  400ea6:	d20e      	bcs.n	400ec6 <__aeabi_f2uiz+0x22>
  400ea8:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
  400eac:	d30b      	bcc.n	400ec6 <__aeabi_f2uiz+0x22>
  400eae:	f04f 039e 	mov.w	r3, #158	; 0x9e
  400eb2:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
  400eb6:	d409      	bmi.n	400ecc <__aeabi_f2uiz+0x28>
  400eb8:	ea4f 2300 	mov.w	r3, r0, lsl #8
  400ebc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  400ec0:	fa23 f002 	lsr.w	r0, r3, r2
  400ec4:	4770      	bx	lr
  400ec6:	f04f 0000 	mov.w	r0, #0
  400eca:	4770      	bx	lr
  400ecc:	f112 0f61 	cmn.w	r2, #97	; 0x61
  400ed0:	d101      	bne.n	400ed6 <__aeabi_f2uiz+0x32>
  400ed2:	0242      	lsls	r2, r0, #9
  400ed4:	d102      	bne.n	400edc <__aeabi_f2uiz+0x38>
  400ed6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  400eda:	4770      	bx	lr
  400edc:	f04f 0000 	mov.w	r0, #0
  400ee0:	4770      	bx	lr
  400ee2:	bf00      	nop

00400ee4 <__aeabi_uldivmod>:
  400ee4:	b953      	cbnz	r3, 400efc <__aeabi_uldivmod+0x18>
  400ee6:	b94a      	cbnz	r2, 400efc <__aeabi_uldivmod+0x18>
  400ee8:	2900      	cmp	r1, #0
  400eea:	bf08      	it	eq
  400eec:	2800      	cmpeq	r0, #0
  400eee:	bf1c      	itt	ne
  400ef0:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
  400ef4:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  400ef8:	f000 b80c 	b.w	400f14 <__aeabi_idiv0>
  400efc:	f1ad 0c08 	sub.w	ip, sp, #8
  400f00:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  400f04:	f000 f808 	bl	400f18 <__udivmoddi4>
  400f08:	f8dd e004 	ldr.w	lr, [sp, #4]
  400f0c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  400f10:	b004      	add	sp, #16
  400f12:	4770      	bx	lr

00400f14 <__aeabi_idiv0>:
  400f14:	4770      	bx	lr
  400f16:	bf00      	nop

00400f18 <__udivmoddi4>:
  400f18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400f1c:	4607      	mov	r7, r0
  400f1e:	468c      	mov	ip, r1
  400f20:	4608      	mov	r0, r1
  400f22:	9e09      	ldr	r6, [sp, #36]	; 0x24
  400f24:	4615      	mov	r5, r2
  400f26:	463c      	mov	r4, r7
  400f28:	4619      	mov	r1, r3
  400f2a:	2b00      	cmp	r3, #0
  400f2c:	f040 80c6 	bne.w	4010bc <__udivmoddi4+0x1a4>
  400f30:	4282      	cmp	r2, r0
  400f32:	fab2 f782 	clz	r7, r2
  400f36:	d946      	bls.n	400fc6 <__udivmoddi4+0xae>
  400f38:	b14f      	cbz	r7, 400f4e <__udivmoddi4+0x36>
  400f3a:	f1c7 0e20 	rsb	lr, r7, #32
  400f3e:	fa24 fe0e 	lsr.w	lr, r4, lr
  400f42:	fa00 f307 	lsl.w	r3, r0, r7
  400f46:	40bd      	lsls	r5, r7
  400f48:	ea4e 0c03 	orr.w	ip, lr, r3
  400f4c:	40bc      	lsls	r4, r7
  400f4e:	ea4f 4815 	mov.w	r8, r5, lsr #16
  400f52:	fa1f fe85 	uxth.w	lr, r5
  400f56:	fbbc f9f8 	udiv	r9, ip, r8
  400f5a:	0c22      	lsrs	r2, r4, #16
  400f5c:	fb08 c319 	mls	r3, r8, r9, ip
  400f60:	fb09 fa0e 	mul.w	sl, r9, lr
  400f64:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  400f68:	459a      	cmp	sl, r3
  400f6a:	d928      	bls.n	400fbe <__udivmoddi4+0xa6>
  400f6c:	18eb      	adds	r3, r5, r3
  400f6e:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
  400f72:	d204      	bcs.n	400f7e <__udivmoddi4+0x66>
  400f74:	459a      	cmp	sl, r3
  400f76:	d902      	bls.n	400f7e <__udivmoddi4+0x66>
  400f78:	f1a9 0002 	sub.w	r0, r9, #2
  400f7c:	442b      	add	r3, r5
  400f7e:	eba3 030a 	sub.w	r3, r3, sl
  400f82:	b2a4      	uxth	r4, r4
  400f84:	fbb3 f2f8 	udiv	r2, r3, r8
  400f88:	fb08 3312 	mls	r3, r8, r2, r3
  400f8c:	fb02 fe0e 	mul.w	lr, r2, lr
  400f90:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  400f94:	45a6      	cmp	lr, r4
  400f96:	d914      	bls.n	400fc2 <__udivmoddi4+0xaa>
  400f98:	192c      	adds	r4, r5, r4
  400f9a:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
  400f9e:	d203      	bcs.n	400fa8 <__udivmoddi4+0x90>
  400fa0:	45a6      	cmp	lr, r4
  400fa2:	d901      	bls.n	400fa8 <__udivmoddi4+0x90>
  400fa4:	1e93      	subs	r3, r2, #2
  400fa6:	442c      	add	r4, r5
  400fa8:	eba4 040e 	sub.w	r4, r4, lr
  400fac:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  400fb0:	b11e      	cbz	r6, 400fba <__udivmoddi4+0xa2>
  400fb2:	40fc      	lsrs	r4, r7
  400fb4:	2300      	movs	r3, #0
  400fb6:	6034      	str	r4, [r6, #0]
  400fb8:	6073      	str	r3, [r6, #4]
  400fba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400fbe:	4648      	mov	r0, r9
  400fc0:	e7dd      	b.n	400f7e <__udivmoddi4+0x66>
  400fc2:	4613      	mov	r3, r2
  400fc4:	e7f0      	b.n	400fa8 <__udivmoddi4+0x90>
  400fc6:	b902      	cbnz	r2, 400fca <__udivmoddi4+0xb2>
  400fc8:	deff      	udf	#255	; 0xff
  400fca:	bb87      	cbnz	r7, 40102e <__udivmoddi4+0x116>
  400fcc:	1a83      	subs	r3, r0, r2
  400fce:	2101      	movs	r1, #1
  400fd0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  400fd4:	b2aa      	uxth	r2, r5
  400fd6:	fbb3 fcfe 	udiv	ip, r3, lr
  400fda:	0c20      	lsrs	r0, r4, #16
  400fdc:	fb0e 331c 	mls	r3, lr, ip, r3
  400fe0:	fb0c f802 	mul.w	r8, ip, r2
  400fe4:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
  400fe8:	4598      	cmp	r8, r3
  400fea:	d963      	bls.n	4010b4 <__udivmoddi4+0x19c>
  400fec:	18eb      	adds	r3, r5, r3
  400fee:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
  400ff2:	d204      	bcs.n	400ffe <__udivmoddi4+0xe6>
  400ff4:	4598      	cmp	r8, r3
  400ff6:	d902      	bls.n	400ffe <__udivmoddi4+0xe6>
  400ff8:	f1ac 0002 	sub.w	r0, ip, #2
  400ffc:	442b      	add	r3, r5
  400ffe:	eba3 0308 	sub.w	r3, r3, r8
  401002:	b2a4      	uxth	r4, r4
  401004:	fbb3 fcfe 	udiv	ip, r3, lr
  401008:	fb0e 331c 	mls	r3, lr, ip, r3
  40100c:	fb0c f202 	mul.w	r2, ip, r2
  401010:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  401014:	42a2      	cmp	r2, r4
  401016:	d94f      	bls.n	4010b8 <__udivmoddi4+0x1a0>
  401018:	192c      	adds	r4, r5, r4
  40101a:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
  40101e:	d204      	bcs.n	40102a <__udivmoddi4+0x112>
  401020:	42a2      	cmp	r2, r4
  401022:	d902      	bls.n	40102a <__udivmoddi4+0x112>
  401024:	f1ac 0302 	sub.w	r3, ip, #2
  401028:	442c      	add	r4, r5
  40102a:	1aa4      	subs	r4, r4, r2
  40102c:	e7be      	b.n	400fac <__udivmoddi4+0x94>
  40102e:	f1c7 0c20 	rsb	ip, r7, #32
  401032:	fa20 f80c 	lsr.w	r8, r0, ip
  401036:	fa00 f307 	lsl.w	r3, r0, r7
  40103a:	fa24 fc0c 	lsr.w	ip, r4, ip
  40103e:	40bd      	lsls	r5, r7
  401040:	ea4c 0203 	orr.w	r2, ip, r3
  401044:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  401048:	b2ab      	uxth	r3, r5
  40104a:	fbb8 fcfe 	udiv	ip, r8, lr
  40104e:	0c11      	lsrs	r1, r2, #16
  401050:	fb0e 801c 	mls	r0, lr, ip, r8
  401054:	fb0c f903 	mul.w	r9, ip, r3
  401058:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
  40105c:	4581      	cmp	r9, r0
  40105e:	fa04 f407 	lsl.w	r4, r4, r7
  401062:	d923      	bls.n	4010ac <__udivmoddi4+0x194>
  401064:	1828      	adds	r0, r5, r0
  401066:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
  40106a:	d204      	bcs.n	401076 <__udivmoddi4+0x15e>
  40106c:	4581      	cmp	r9, r0
  40106e:	d902      	bls.n	401076 <__udivmoddi4+0x15e>
  401070:	f1ac 0102 	sub.w	r1, ip, #2
  401074:	4428      	add	r0, r5
  401076:	eba0 0009 	sub.w	r0, r0, r9
  40107a:	b292      	uxth	r2, r2
  40107c:	fbb0 fcfe 	udiv	ip, r0, lr
  401080:	fb0e 001c 	mls	r0, lr, ip, r0
  401084:	fb0c f803 	mul.w	r8, ip, r3
  401088:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
  40108c:	4598      	cmp	r8, r3
  40108e:	d90f      	bls.n	4010b0 <__udivmoddi4+0x198>
  401090:	18eb      	adds	r3, r5, r3
  401092:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
  401096:	d204      	bcs.n	4010a2 <__udivmoddi4+0x18a>
  401098:	4598      	cmp	r8, r3
  40109a:	d902      	bls.n	4010a2 <__udivmoddi4+0x18a>
  40109c:	f1ac 0202 	sub.w	r2, ip, #2
  4010a0:	442b      	add	r3, r5
  4010a2:	eba3 0308 	sub.w	r3, r3, r8
  4010a6:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
  4010aa:	e791      	b.n	400fd0 <__udivmoddi4+0xb8>
  4010ac:	4661      	mov	r1, ip
  4010ae:	e7e2      	b.n	401076 <__udivmoddi4+0x15e>
  4010b0:	4662      	mov	r2, ip
  4010b2:	e7f6      	b.n	4010a2 <__udivmoddi4+0x18a>
  4010b4:	4660      	mov	r0, ip
  4010b6:	e7a2      	b.n	400ffe <__udivmoddi4+0xe6>
  4010b8:	4663      	mov	r3, ip
  4010ba:	e7b6      	b.n	40102a <__udivmoddi4+0x112>
  4010bc:	4283      	cmp	r3, r0
  4010be:	d905      	bls.n	4010cc <__udivmoddi4+0x1b4>
  4010c0:	b10e      	cbz	r6, 4010c6 <__udivmoddi4+0x1ae>
  4010c2:	e9c6 7000 	strd	r7, r0, [r6]
  4010c6:	2100      	movs	r1, #0
  4010c8:	4608      	mov	r0, r1
  4010ca:	e776      	b.n	400fba <__udivmoddi4+0xa2>
  4010cc:	fab3 f183 	clz	r1, r3
  4010d0:	b981      	cbnz	r1, 4010f4 <__udivmoddi4+0x1dc>
  4010d2:	4283      	cmp	r3, r0
  4010d4:	d301      	bcc.n	4010da <__udivmoddi4+0x1c2>
  4010d6:	42ba      	cmp	r2, r7
  4010d8:	d80a      	bhi.n	4010f0 <__udivmoddi4+0x1d8>
  4010da:	1abc      	subs	r4, r7, r2
  4010dc:	eb60 0303 	sbc.w	r3, r0, r3
  4010e0:	2001      	movs	r0, #1
  4010e2:	469c      	mov	ip, r3
  4010e4:	2e00      	cmp	r6, #0
  4010e6:	d068      	beq.n	4011ba <__udivmoddi4+0x2a2>
  4010e8:	e9c6 4c00 	strd	r4, ip, [r6]
  4010ec:	2100      	movs	r1, #0
  4010ee:	e764      	b.n	400fba <__udivmoddi4+0xa2>
  4010f0:	4608      	mov	r0, r1
  4010f2:	e7f7      	b.n	4010e4 <__udivmoddi4+0x1cc>
  4010f4:	f1c1 0c20 	rsb	ip, r1, #32
  4010f8:	408b      	lsls	r3, r1
  4010fa:	fa22 f40c 	lsr.w	r4, r2, ip
  4010fe:	431c      	orrs	r4, r3
  401100:	fa02 f501 	lsl.w	r5, r2, r1
  401104:	fa00 f301 	lsl.w	r3, r0, r1
  401108:	fa27 f20c 	lsr.w	r2, r7, ip
  40110c:	fa20 fb0c 	lsr.w	fp, r0, ip
  401110:	ea4f 4914 	mov.w	r9, r4, lsr #16
  401114:	4313      	orrs	r3, r2
  401116:	fbbb f8f9 	udiv	r8, fp, r9
  40111a:	fa1f fe84 	uxth.w	lr, r4
  40111e:	fb09 bb18 	mls	fp, r9, r8, fp
  401122:	0c1a      	lsrs	r2, r3, #16
  401124:	fb08 fa0e 	mul.w	sl, r8, lr
  401128:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
  40112c:	4592      	cmp	sl, r2
  40112e:	fa07 f701 	lsl.w	r7, r7, r1
  401132:	d93e      	bls.n	4011b2 <__udivmoddi4+0x29a>
  401134:	18a2      	adds	r2, r4, r2
  401136:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
  40113a:	d204      	bcs.n	401146 <__udivmoddi4+0x22e>
  40113c:	4592      	cmp	sl, r2
  40113e:	d902      	bls.n	401146 <__udivmoddi4+0x22e>
  401140:	f1a8 0002 	sub.w	r0, r8, #2
  401144:	4422      	add	r2, r4
  401146:	eba2 020a 	sub.w	r2, r2, sl
  40114a:	b29b      	uxth	r3, r3
  40114c:	fbb2 f8f9 	udiv	r8, r2, r9
  401150:	fb09 2218 	mls	r2, r9, r8, r2
  401154:	fb08 fe0e 	mul.w	lr, r8, lr
  401158:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  40115c:	4596      	cmp	lr, r2
  40115e:	d92a      	bls.n	4011b6 <__udivmoddi4+0x29e>
  401160:	18a2      	adds	r2, r4, r2
  401162:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
  401166:	d204      	bcs.n	401172 <__udivmoddi4+0x25a>
  401168:	4596      	cmp	lr, r2
  40116a:	d902      	bls.n	401172 <__udivmoddi4+0x25a>
  40116c:	f1a8 0302 	sub.w	r3, r8, #2
  401170:	4422      	add	r2, r4
  401172:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  401176:	fba0 9305 	umull	r9, r3, r0, r5
  40117a:	eba2 020e 	sub.w	r2, r2, lr
  40117e:	429a      	cmp	r2, r3
  401180:	46ce      	mov	lr, r9
  401182:	4698      	mov	r8, r3
  401184:	d302      	bcc.n	40118c <__udivmoddi4+0x274>
  401186:	d106      	bne.n	401196 <__udivmoddi4+0x27e>
  401188:	454f      	cmp	r7, r9
  40118a:	d204      	bcs.n	401196 <__udivmoddi4+0x27e>
  40118c:	ebb9 0e05 	subs.w	lr, r9, r5
  401190:	eb63 0804 	sbc.w	r8, r3, r4
  401194:	3801      	subs	r0, #1
  401196:	b186      	cbz	r6, 4011ba <__udivmoddi4+0x2a2>
  401198:	ebb7 030e 	subs.w	r3, r7, lr
  40119c:	eb62 0708 	sbc.w	r7, r2, r8
  4011a0:	fa07 fc0c 	lsl.w	ip, r7, ip
  4011a4:	40cb      	lsrs	r3, r1
  4011a6:	ea4c 0303 	orr.w	r3, ip, r3
  4011aa:	40cf      	lsrs	r7, r1
  4011ac:	e9c6 3700 	strd	r3, r7, [r6]
  4011b0:	e79c      	b.n	4010ec <__udivmoddi4+0x1d4>
  4011b2:	4640      	mov	r0, r8
  4011b4:	e7c7      	b.n	401146 <__udivmoddi4+0x22e>
  4011b6:	4643      	mov	r3, r8
  4011b8:	e7db      	b.n	401172 <__udivmoddi4+0x25a>
  4011ba:	4631      	mov	r1, r6
  4011bc:	e6fd      	b.n	400fba <__udivmoddi4+0xa2>
	...

004011c0 <main>:

const struct device *can_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_canbus));


void main(void)
{
  4011c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4011c4:	b0a9      	sub	sp, #164	; 0xa4
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
  4011c6:	486c      	ldr	r0, [pc, #432]	; (401378 <main+0x1b8>)
  4011c8:	f005 fcd1 	bl	406b6e <z_device_is_ready>
	uint16_t ret;
	float alpha = 7373 / 500;
	float beta = 819;
	float error = 221;

	if (!device_is_ready(i2c_dev)) {
  4011cc:	b928      	cbnz	r0, 4011da <main+0x1a>
		printk("I2C: Device is not ready.\n");
  4011ce:	486b      	ldr	r0, [pc, #428]	; (40137c <main+0x1bc>)
		can_send(can_dev,&frame_data,K_FOREVER,NULL,NULL);	
	
		k_msleep(1);	
	
	}
}
  4011d0:	b029      	add	sp, #164	; 0xa4
  4011d2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		printk("I2C: Device is not ready.\n");
  4011d6:	f004 bd4c 	b.w	405c72 <printk>
	if (!device_is_ready(can_dev)) {
  4011da:	4c69      	ldr	r4, [pc, #420]	; (401380 <main+0x1c0>)
  4011dc:	6820      	ldr	r0, [r4, #0]
  4011de:	f005 fcc6 	bl	406b6e <z_device_is_ready>
  4011e2:	b938      	cbnz	r0, 4011f4 <main+0x34>
		printk("CAN: Device %s not ready.\n", can_dev->name);
  4011e4:	6823      	ldr	r3, [r4, #0]
  4011e6:	4867      	ldr	r0, [pc, #412]	; (401384 <main+0x1c4>)
  4011e8:	6819      	ldr	r1, [r3, #0]
}
  4011ea:	b029      	add	sp, #164	; 0xa4
  4011ec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		printk("CAN: Device %s not ready.\n", can_dev->name);
  4011f0:	f004 bd3f 	b.w	405c72 <printk>
	can_set_mode(can_dev, CAN_NORMAL_MODE);
  4011f4:	6820      	ldr	r0, [r4, #0]

static inline int z_impl_can_set_mode(const struct device *dev, enum can_mode mode)
{
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;

	return api->set_mode(dev, mode);
  4011f6:	6883      	ldr	r3, [r0, #8]
  4011f8:	2100      	movs	r1, #0
  4011fa:	681b      	ldr	r3, [r3, #0]
  4011fc:	4798      	blx	r3
    uint32_t rate =0;
  4011fe:	2300      	movs	r3, #0
	can_calc_timing(can_dev, &timing, 250000, 800);
  401200:	a906      	add	r1, sp, #24
  401202:	4a61      	ldr	r2, [pc, #388]	; (401388 <main+0x1c8>)
    uint32_t rate =0;
  401204:	9303      	str	r3, [sp, #12]
	can_calc_timing(can_dev, &timing, 250000, 800);
  401206:	f44f 7348 	mov.w	r3, #800	; 0x320
  40120a:	6820      	ldr	r0, [r4, #0]
  40120c:	f005 fb88 	bl	406920 <can_calc_timing>
	can_calc_timing(can_dev, &dtiming,4000000, 800);
  401210:	f44f 7348 	mov.w	r3, #800	; 0x320
  401214:	4a5d      	ldr	r2, [pc, #372]	; (40138c <main+0x1cc>)
  401216:	a909      	add	r1, sp, #36	; 0x24
  401218:	6820      	ldr	r0, [r4, #0]
  40121a:	f005 fb81 	bl	406920 <can_calc_timing>
	can_get_core_clock(can_dev, &rate);
  40121e:	6820      	ldr	r0, [r4, #0]
	return api->get_core_clock(dev, rate);
  401220:	6883      	ldr	r3, [r0, #8]
  401222:	a903      	add	r1, sp, #12
		volatile float temperature_C = (200.0 / 2047.0) * (float)temperature_data - 50.0;
  401224:	2600      	movs	r6, #0
  401226:	4f5a      	ldr	r7, [pc, #360]	; (401390 <main+0x1d0>)
  401228:	69db      	ldr	r3, [r3, #28]
		printk("%d\n",(int)pressure_kpa);
  40122a:	f8df a168 	ldr.w	sl, [pc, #360]	; 401394 <main+0x1d4>
  40122e:	4798      	blx	r3
	printk("CAN clock %d \n", rate);
  401230:	9903      	ldr	r1, [sp, #12]
  401232:	4859      	ldr	r0, [pc, #356]	; (401398 <main+0x1d8>)
  401234:	f004 fd1d 	bl	405c72 <printk>
		volatile float temperature_C = (200.0 / 2047.0) * (float)temperature_data - 50.0;
  401238:	f20f 1934 	addw	r9, pc, #308	; 0x134
  40123c:	e9d9 8900 	ldrd	r8, r9, [r9]
static inline int i2c_read(const struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
	struct i2c_msg msg;

	msg.buf = buf;
  401240:	ab0c      	add	r3, sp, #48	; 0x30
  401242:	9316      	str	r3, [sp, #88]	; 0x58
	msg.len = num_bytes;
  401244:	2304      	movs	r3, #4
  401246:	9317      	str	r3, [sp, #92]	; 0x5c
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
  401248:	2303      	movs	r3, #3
  40124a:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
	int res =  api->transfer(dev, msgs, num_msgs, addr);
  40124e:	484a      	ldr	r0, [pc, #296]	; (401378 <main+0x1b8>)
  401250:	2201      	movs	r2, #1
  401252:	a916      	add	r1, sp, #88	; 0x58
  401254:	6883      	ldr	r3, [r0, #8]
  401256:	689d      	ldr	r5, [r3, #8]
  401258:	2338      	movs	r3, #56	; 0x38
  40125a:	47a8      	blx	r5
		uint16_t pressure_data = ((data[0] & 0x3f) << 8) | data[1]; // &0x3f this is 16 bits, last two bits are zero(status bits)
  40125c:	f89d b030 	ldrb.w	fp, [sp, #48]	; 0x30
		uint16_t temperature_data = ((data[2] << 8) | data[3]) >> 5;
  401260:	f8bd 5032 	ldrh.w	r5, [sp, #50]	; 0x32
		uint16_t pressure_data = ((data[0] & 0x3f) << 8) | data[1]; // &0x3f this is 16 bits, last two bits are zero(status bits)
  401264:	ea4f 2b0b 	mov.w	fp, fp, lsl #8
		uint16_t temperature_data = ((data[2] << 8) | data[3]) >> 5;
  401268:	ba6d      	rev16	r5, r5
		uint16_t pressure_data = ((data[0] & 0x3f) << 8) | data[1]; // &0x3f this is 16 bits, last two bits are zero(status bits)
  40126a:	f40b 537c 	and.w	r3, fp, #16128	; 0x3f00
  40126e:	f89d b031 	ldrb.w	fp, [sp, #49]	; 0x31
		uint16_t temperature_data = ((data[2] << 8) | data[3]) >> 5;
  401272:	f3c5 154a 	ubfx	r5, r5, #5, #11
		uint16_t pressure_data = ((data[0] & 0x3f) << 8) | data[1]; // &0x3f this is 16 bits, last two bits are zero(status bits)
  401276:	ea4b 0b03 	orr.w	fp, fp, r3
		/* coverity[OVERRUN] */
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
  40127a:	2100      	movs	r1, #0
  40127c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  401280:	f004 fa12 	bl	4056a8 <z_impl_k_sleep>
		volatile float temperature_C = (200.0 / 2047.0) * (float)temperature_data - 50.0;
  401284:	4628      	mov	r0, r5
  401286:	f7ff fc3f 	bl	400b08 <__aeabi_ui2f>
  40128a:	f7ff f8cd 	bl	400428 <__aeabi_f2d>
  40128e:	4642      	mov	r2, r8
  401290:	464b      	mov	r3, r9
  401292:	f7ff f921 	bl	4004d8 <__aeabi_dmul>
  401296:	4632      	mov	r2, r6
  401298:	463b      	mov	r3, r7
  40129a:	f7fe ff65 	bl	400168 <__aeabi_dsub>
  40129e:	f7ff fb2d 	bl	4008fc <__aeabi_d2f>
  4012a2:	9004      	str	r0, [sp, #16]
		volatile float pressure_kpa = ((float)pressure_data - beta -(error*0)) / alpha;
  4012a4:	4658      	mov	r0, fp
  4012a6:	f7ff fc2f 	bl	400b08 <__aeabi_ui2f>
  4012aa:	493c      	ldr	r1, [pc, #240]	; (40139c <main+0x1dc>)
  4012ac:	f7ff fb7a 	bl	4009a4 <__aeabi_fsub>
  4012b0:	493b      	ldr	r1, [pc, #236]	; (4013a0 <main+0x1e0>)
  4012b2:	f7ff fd35 	bl	400d20 <__aeabi_fdiv>
  4012b6:	9005      	str	r0, [sp, #20]
		printk("%d\n",(int)pressure_kpa);
  4012b8:	9805      	ldr	r0, [sp, #20]
  4012ba:	f7ff fdcd 	bl	400e58 <__aeabi_f2iz>
  4012be:	4601      	mov	r1, r0
  4012c0:	4650      	mov	r0, sl
  4012c2:	f004 fcd6 	bl	405c72 <printk>
		printk("%d\n",(int)temperature_C);
  4012c6:	9804      	ldr	r0, [sp, #16]
  4012c8:	f7ff fdc6 	bl	400e58 <__aeabi_f2iz>
  4012cc:	4601      	mov	r1, r0
  4012ce:	4650      	mov	r0, sl
  4012d0:	f004 fccf 	bl	405c72 <printk>
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  4012d4:	f003 fb0a 	bl	4048ec <sys_clock_cycle_get_32>
		printk("%d\n",(uint32_t)time);
  4012d8:	4601      	mov	r1, r0
  4012da:	4605      	mov	r5, r0
  4012dc:	4650      	mov	r0, sl
  4012de:	f004 fcc8 	bl	405c72 <printk>
  4012e2:	2100      	movs	r1, #0
  4012e4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  4012e8:	f004 f9de 	bl	4056a8 <z_impl_k_sleep>
		struct can_pressure_frame_t Pressure_data = { .length=length_of_dataframe,
  4012ec:	2300      	movs	r3, #0
  4012ee:	2208      	movs	r2, #8
  4012f0:	9805      	ldr	r0, [sp, #20]
  4012f2:	9512      	str	r5, [sp, #72]	; 0x48
  4012f4:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
  4012f8:	f7ff fdd4 	bl	400ea4 <__aeabi_f2uiz>
  4012fc:	9013      	str	r0, [sp, #76]	; 0x4c
  4012fe:	9804      	ldr	r0, [sp, #16]
  401300:	f7ff fdd0 	bl	400ea4 <__aeabi_f2uiz>
		struct zcan_frame frame_data = {
  401304:	2248      	movs	r2, #72	; 0x48
		struct can_pressure_frame_t Pressure_data = { .length=length_of_dataframe,
  401306:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
		struct zcan_frame frame_data = {
  40130a:	2100      	movs	r1, #0
  40130c:	a816      	add	r0, sp, #88	; 0x58
  40130e:	f005 f931 	bl	406574 <memset>
  401312:	4b24      	ldr	r3, [pc, #144]	; (4013a4 <main+0x1e4>)
		memcpy(&frame_data.data[0], &Pressure_data.length, sizeof(struct can_pressure_frame_t ));
  401314:	a910      	add	r1, sp, #64	; 0x40
  401316:	2218      	movs	r2, #24
		struct zcan_frame frame_data = {
  401318:	9316      	str	r3, [sp, #88]	; 0x58
  40131a:	2308      	movs	r3, #8
		memcpy(&frame_data.data[0], &Pressure_data.length, sizeof(struct can_pressure_frame_t ));
  40131c:	a818      	add	r0, sp, #96	; 0x60
		struct zcan_frame frame_data = {
  40131e:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		memcpy(&frame_data.data[0], &Pressure_data.length, sizeof(struct can_pressure_frame_t ));
  401322:	f005 f91c 	bl	40655e <memcpy>
		memcpy(&frame_data.data[1], &Pressure_data.timestamp, sizeof(struct can_pressure_frame_t ));
  401326:	a912      	add	r1, sp, #72	; 0x48
  401328:	2218      	movs	r2, #24
  40132a:	f10d 0061 	add.w	r0, sp, #97	; 0x61
  40132e:	f005 f916 	bl	40655e <memcpy>
		memcpy(&frame_data.data[5], &Pressure_data.pressure, sizeof(struct can_pressure_frame_t ));
  401332:	a913      	add	r1, sp, #76	; 0x4c
  401334:	2218      	movs	r2, #24
  401336:	f10d 0065 	add.w	r0, sp, #101	; 0x65
  40133a:	f005 f910 	bl	40655e <memcpy>
		memcpy(&frame_data.data[7], &Pressure_data.temperature, sizeof(struct can_pressure_frame_t ));
  40133e:	2218      	movs	r2, #24
  401340:	a914      	add	r1, sp, #80	; 0x50
  401342:	f10d 0067 	add.w	r0, sp, #103	; 0x67
  401346:	f005 f90a 	bl	40655e <memcpy>
		can_send(can_dev,&frame_data,K_FOREVER,NULL,NULL);	
  40134a:	6820      	ldr	r0, [r4, #0]
				  k_timeout_t timeout, can_tx_callback_t callback,
				  void *user_data)
{
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;

	return api->send(dev, frame, timeout, callback, user_data);
  40134c:	2300      	movs	r3, #0
  40134e:	6882      	ldr	r2, [r0, #8]
  401350:	a916      	add	r1, sp, #88	; 0x58
  401352:	e9cd 3300 	strd	r3, r3, [sp]
  401356:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  40135a:	6895      	ldr	r5, [r2, #8]
  40135c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  401360:	47a8      	blx	r5
  401362:	2100      	movs	r1, #0
  401364:	200a      	movs	r0, #10
  401366:	f004 f99f 	bl	4056a8 <z_impl_k_sleep>
	while (1) {
  40136a:	e769      	b.n	401240 <main+0x80>
  40136c:	f3af 8000 	nop.w
  401370:	640c8190 	.word	0x640c8190
  401374:	3fb90320 	.word	0x3fb90320
  401378:	00407008 	.word	0x00407008
  40137c:	0040756c 	.word	0x0040756c
  401380:	20400000 	.word	0x20400000
  401384:	00407587 	.word	0x00407587
  401388:	0003d090 	.word	0x0003d090
  40138c:	003d0900 	.word	0x003d0900
  401390:	40490000 	.word	0x40490000
  401394:	004075b1 	.word	0x004075b1
  401398:	004075a2 	.word	0x004075a2
  40139c:	444cc000 	.word	0x444cc000
  4013a0:	41600000 	.word	0x41600000
  4013a4:	20000123 	.word	0x20000123

004013a8 <cbvprintf_package>:

#endif

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
  4013a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4013ac:	4605      	mov	r5, r0
  4013ae:	b08b      	sub	sp, #44	; 0x2c
  4013b0:	4618      	mov	r0, r3
  4013b2:	460e      	mov	r6, r1
	unsigned int i;
	const char *s;
	bool parsing = false;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
  4013b4:	f015 0303 	ands.w	r3, r5, #3
  4013b8:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
{
  4013bc:	9203      	str	r2, [sp, #12]
	if ((uintptr_t)packaged % sizeof(void *)) {
  4013be:	9301      	str	r3, [sp, #4]
  4013c0:	f040 81f5 	bne.w	4017ae <cbvprintf_package+0x406>
	 *
	 * Given the next value to store is the format string pointer
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * a pointer size for the above to preserve alignment.
	 */
	buf += sizeof(char *);
  4013c4:	1d2c      	adds	r4, r5, #4
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  4013c6:	2d00      	cmp	r5, #0
  4013c8:	f040 81f4 	bne.w	4017b4 <cbvprintf_package+0x40c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  4013cc:	f001 0607 	and.w	r6, r1, #7
  4013d0:	1d34      	adds	r4, r6, #4
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  4013d2:	f1c6 0608 	rsb	r6, r6, #8
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  4013d6:	f04f 0a00 	mov.w	sl, #0
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
  4013da:	2704      	movs	r7, #4
	s = fmt--;
  4013dc:	1e41      	subs	r1, r0, #1
	bool parsing = false;
  4013de:	4652      	mov	r2, sl
	size = sizeof(char *);
  4013e0:	46b9      	mov	r9, r7
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  4013e2:	f8cd a008 	str.w	sl, [sp, #8]
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
  4013e6:	f8cd a000 	str.w	sl, [sp]

		/* copy va_list data over to our buffer */
		if (*fmt == 's') {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  4013ea:	b105      	cbz	r5, 4013ee <cbvprintf_package+0x46>
				*(const char **)buf = s;
  4013ec:	6020      	str	r0, [r4, #0]
			}

			bool is_ro = ptr_in_rodata(s);
			bool do_all = !!(flags & CBPRINTF_PACKAGE_ADD_STRING_IDXS);
  4013ee:	9b03      	ldr	r3, [sp, #12]
  4013f0:	f003 0e01 	and.w	lr, r3, #1
	return ((addr >= (const char *)RO_START) &&
  4013f4:	4bce      	ldr	r3, [pc, #824]	; (401730 <cbvprintf_package+0x388>)
  4013f6:	4298      	cmp	r0, r3
  4013f8:	f0c0 812a 	bcc.w	401650 <cbvprintf_package+0x2a8>

			if (is_ro && !do_all) {
  4013fc:	4bcd      	ldr	r3, [pc, #820]	; (401734 <cbvprintf_package+0x38c>)
  4013fe:	4298      	cmp	r0, r3
  401400:	f080 8126 	bcs.w	401650 <cbvprintf_package+0x2a8>
  401404:	f1be 0f00 	cmp.w	lr, #0
  401408:	f000 813c 	beq.w	401684 <cbvprintf_package+0x2dc>
	return ((addr >= (const char *)RO_START) &&
  40140c:	f04f 0c01 	mov.w	ip, #1
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
  401410:	eba4 0b05 	sub.w	fp, r4, r5
				 * In the do_all case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_all && s_ptr_idx > STR_POS_MASK) {
  401414:	f1be 0f00 	cmp.w	lr, #0
  401418:	f000 811d 	beq.w	401656 <cbvprintf_package+0x2ae>
  40141c:	f5bb 7f00 	cmp.w	fp, #512	; 0x200
  401420:	f0c0 8119 	bcc.w	401656 <cbvprintf_package+0x2ae>
					__ASSERT(false, "String with too many arguments");
					return -EINVAL;
  401424:	f06f 0015 	mvn.w	r0, #21
  401428:	e0f5      	b.n	401616 <cbvprintf_package+0x26e>
		if (!parsing) {
  40142a:	b932      	cbnz	r2, 40143a <cbvprintf_package+0x92>
			if (*fmt == '%') {
  40142c:	2b25      	cmp	r3, #37	; 0x25
  40142e:	f040 812c 	bne.w	40168a <cbvprintf_package+0x2e2>
				parsing = true;
  401432:	2201      	movs	r2, #1
			align = VA_STACK_ALIGN(ptrdiff_t);
  401434:	2704      	movs	r7, #4
			size = sizeof(intmax_t);
  401436:	46b9      	mov	r9, r7
  401438:	e127      	b.n	40168a <cbvprintf_package+0x2e2>
		switch (*fmt) {
  40143a:	2b2b      	cmp	r3, #43	; 0x2b
  40143c:	d824      	bhi.n	401488 <cbvprintf_package+0xe0>
  40143e:	2b1f      	cmp	r3, #31
  401440:	d801      	bhi.n	401446 <cbvprintf_package+0x9e>
			parsing = false;
  401442:	2200      	movs	r2, #0
  401444:	e121      	b.n	40168a <cbvprintf_package+0x2e2>
		switch (*fmt) {
  401446:	f1a3 0020 	sub.w	r0, r3, #32
  40144a:	280b      	cmp	r0, #11
  40144c:	d8f9      	bhi.n	401442 <cbvprintf_package+0x9a>
  40144e:	f20f 0c08 	addw	ip, pc, #8
  401452:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
  401456:	bf00      	nop
  401458:	0040168b 	.word	0x0040168b
  40145c:	00401443 	.word	0x00401443
  401460:	00401443 	.word	0x00401443
  401464:	0040168b 	.word	0x0040168b
  401468:	00401443 	.word	0x00401443
  40146c:	00401443 	.word	0x00401443
  401470:	00401443 	.word	0x00401443
  401474:	00401443 	.word	0x00401443
  401478:	00401443 	.word	0x00401443
  40147c:	00401443 	.word	0x00401443
  401480:	0040162f 	.word	0x0040162f
  401484:	0040168b 	.word	0x0040168b
  401488:	f1a3 002d 	sub.w	r0, r3, #45	; 0x2d
  40148c:	fa5f fc80 	uxtb.w	ip, r0
  401490:	f1bc 0f4d 	cmp.w	ip, #77	; 0x4d
  401494:	d8d5      	bhi.n	401442 <cbvprintf_package+0x9a>
  401496:	284d      	cmp	r0, #77	; 0x4d
  401498:	d8d3      	bhi.n	401442 <cbvprintf_package+0x9a>
  40149a:	f20f 0c08 	addw	ip, pc, #8
  40149e:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
  4014a2:	bf00      	nop
  4014a4:	0040168b 	.word	0x0040168b
  4014a8:	0040168b 	.word	0x0040168b
  4014ac:	00401443 	.word	0x00401443
  4014b0:	0040168b 	.word	0x0040168b
  4014b4:	0040168b 	.word	0x0040168b
  4014b8:	0040168b 	.word	0x0040168b
  4014bc:	0040168b 	.word	0x0040168b
  4014c0:	0040168b 	.word	0x0040168b
  4014c4:	0040168b 	.word	0x0040168b
  4014c8:	0040168b 	.word	0x0040168b
  4014cc:	0040168b 	.word	0x0040168b
  4014d0:	0040168b 	.word	0x0040168b
  4014d4:	0040168b 	.word	0x0040168b
  4014d8:	00401443 	.word	0x00401443
  4014dc:	00401443 	.word	0x00401443
  4014e0:	00401443 	.word	0x00401443
  4014e4:	00401443 	.word	0x00401443
  4014e8:	00401443 	.word	0x00401443
  4014ec:	00401443 	.word	0x00401443
  4014f0:	00401443 	.word	0x00401443
  4014f4:	004015f7 	.word	0x004015f7
  4014f8:	00401443 	.word	0x00401443
  4014fc:	00401443 	.word	0x00401443
  401500:	00401443 	.word	0x00401443
  401504:	004015f7 	.word	0x004015f7
  401508:	004015f7 	.word	0x004015f7
  40150c:	004015f7 	.word	0x004015f7
  401510:	00401443 	.word	0x00401443
  401514:	00401443 	.word	0x00401443
  401518:	00401443 	.word	0x00401443
  40151c:	00401443 	.word	0x00401443
  401520:	0040168b 	.word	0x0040168b
  401524:	00401443 	.word	0x00401443
  401528:	00401443 	.word	0x00401443
  40152c:	00401443 	.word	0x00401443
  401530:	00401443 	.word	0x00401443
  401534:	00401443 	.word	0x00401443
  401538:	00401443 	.word	0x00401443
  40153c:	00401443 	.word	0x00401443
  401540:	00401443 	.word	0x00401443
  401544:	00401443 	.word	0x00401443
  401548:	00401443 	.word	0x00401443
  40154c:	00401443 	.word	0x00401443
  401550:	004015dd 	.word	0x004015dd
  401554:	00401443 	.word	0x00401443
  401558:	00401443 	.word	0x00401443
  40155c:	00401443 	.word	0x00401443
  401560:	00401443 	.word	0x00401443
  401564:	00401443 	.word	0x00401443
  401568:	00401443 	.word	0x00401443
  40156c:	00401443 	.word	0x00401443
  401570:	00401443 	.word	0x00401443
  401574:	004015f7 	.word	0x004015f7
  401578:	00401443 	.word	0x00401443
  40157c:	004015dd 	.word	0x004015dd
  401580:	004015dd 	.word	0x004015dd
  401584:	004015f7 	.word	0x004015f7
  401588:	004015f7 	.word	0x004015f7
  40158c:	004015f7 	.word	0x004015f7
  401590:	0040168b 	.word	0x0040168b
  401594:	004015dd 	.word	0x004015dd
  401598:	00401625 	.word	0x00401625
  40159c:	00401443 	.word	0x00401443
  4015a0:	0040168b 	.word	0x0040168b
  4015a4:	00401443 	.word	0x00401443
  4015a8:	00401629 	.word	0x00401629
  4015ac:	004015dd 	.word	0x004015dd
  4015b0:	00401629 	.word	0x00401629
  4015b4:	00401443 	.word	0x00401443
  4015b8:	00401443 	.word	0x00401443
  4015bc:	00401629 	.word	0x00401629
  4015c0:	00401435 	.word	0x00401435
  4015c4:	004015dd 	.word	0x004015dd
  4015c8:	00401443 	.word	0x00401443
  4015cc:	00401443 	.word	0x00401443
  4015d0:	004015dd 	.word	0x004015dd
  4015d4:	00401443 	.word	0x00401443
  4015d8:	00401435 	.word	0x00401435
			if (fmt[-1] == 'l') {
  4015dc:	f811 2c01 	ldrb.w	r2, [r1, #-1]
  4015e0:	2a6c      	cmp	r2, #108	; 0x6c
  4015e2:	d123      	bne.n	40162c <cbvprintf_package+0x284>
				if (fmt[-2] == 'l') {
  4015e4:	f811 2c02 	ldrb.w	r2, [r1, #-2]
  4015e8:	2a6c      	cmp	r2, #108	; 0x6c
			parsing = false;
  4015ea:	f04f 0200 	mov.w	r2, #0
				if (fmt[-2] == 'l') {
  4015ee:	d02d      	beq.n	40164c <cbvprintf_package+0x2a4>
			align = VA_STACK_ALIGN(void *);
  4015f0:	2704      	movs	r7, #4
					size = sizeof(long long);
  4015f2:	46b9      	mov	r9, r7
  4015f4:	e01b      	b.n	40162e <cbvprintf_package+0x286>
				v.ld = va_arg(ap, long double);
  4015f6:	f108 0807 	add.w	r8, r8, #7
			buf = (void *) ROUND_UP(buf, align);
  4015fa:	3407      	adds	r4, #7
				v.ld = va_arg(ap, long double);
  4015fc:	f028 0807 	bic.w	r8, r8, #7
			buf = (void *) ROUND_UP(buf, align);
  401600:	f024 0407 	bic.w	r4, r4, #7
				v.ld = va_arg(ap, long double);
  401604:	e8f8 2302 	ldrd	r2, r3, [r8], #8
			if (buf0 != NULL) {
  401608:	b155      	cbz	r5, 401620 <cbvprintf_package+0x278>
				if (BUF_OFFSET + size > len) {
  40160a:	eb0e 0004 	add.w	r0, lr, r4
  40160e:	42b0      	cmp	r0, r6
  401610:	d904      	bls.n	40161c <cbvprintf_package+0x274>
					return -ENOSPC;
  401612:	f06f 001b 	mvn.w	r0, #27
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
  401616:	b00b      	add	sp, #44	; 0x2c
  401618:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					*(long double *)buf = v.ld;
  40161c:	e9c4 2300 	strd	r2, r3, [r4]
			buf += size;
  401620:	3408      	adds	r4, #8
			parsing = false;
  401622:	2200      	movs	r2, #0
			align = VA_STACK_ALIGN(intmax_t);
  401624:	2708      	movs	r7, #8
  401626:	e706      	b.n	401436 <cbvprintf_package+0x8e>
			parsing = false;
  401628:	2200      	movs	r2, #0
  40162a:	e7e1      	b.n	4015f0 <cbvprintf_package+0x248>
			parsing = false;
  40162c:	2200      	movs	r2, #0
		buf = (void *) ROUND_UP(buf, align);
  40162e:	3c01      	subs	r4, #1
  401630:	4278      	negs	r0, r7
  401632:	443c      	add	r4, r7
  401634:	4004      	ands	r4, r0
		if (buf0 != NULL && BUF_OFFSET + size > len) {
  401636:	b125      	cbz	r5, 401642 <cbvprintf_package+0x29a>
  401638:	eba9 0005 	sub.w	r0, r9, r5
  40163c:	4420      	add	r0, r4
  40163e:	42b0      	cmp	r0, r6
  401640:	d8e7      	bhi.n	401612 <cbvprintf_package+0x26a>
		if (*fmt == 's') {
  401642:	2b73      	cmp	r3, #115	; 0x73
  401644:	d143      	bne.n	4016ce <cbvprintf_package+0x326>
			s = va_arg(ap, char *);
  401646:	f858 0b04 	ldr.w	r0, [r8], #4
  40164a:	e6ce      	b.n	4013ea <cbvprintf_package+0x42>
					align = VA_STACK_ALIGN(long long);
  40164c:	2708      	movs	r7, #8
  40164e:	e7d0      	b.n	4015f2 <cbvprintf_package+0x24a>
	return ((addr >= (const char *)RO_START) &&
  401650:	f04f 0c00 	mov.w	ip, #0
  401654:	e6dc      	b.n	401410 <cbvprintf_package+0x68>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
  401656:	9b00      	ldr	r3, [sp, #0]
  401658:	2b0f      	cmp	r3, #15
  40165a:	f63f aee3 	bhi.w	401424 <cbvprintf_package+0x7c>
				if (buf0 != NULL) {
  40165e:	b345      	cbz	r5, 4016b2 <cbvprintf_package+0x30a>
					str_ptr_pos[s_idx] = s_ptr_idx;
  401660:	a80a      	add	r0, sp, #40	; 0x28
  401662:	f8dd e000 	ldr.w	lr, [sp]
  401666:	f3cb 0387 	ubfx	r3, fp, #2, #8
					if (is_ro) {
  40166a:	4470      	add	r0, lr
  40166c:	f1bc 0f00 	cmp.w	ip, #0
  401670:	d019      	beq.n	4016a6 <cbvprintf_package+0x2fe>
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  401672:	f063 037f 	orn	r3, r3, #127	; 0x7f
						s_ro_cnt++;
  401676:	f10a 0a01 	add.w	sl, sl, #1
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  40167a:	f800 3c10 	strb.w	r3, [r0, #-16]
				s_idx++;
  40167e:	9b00      	ldr	r3, [sp, #0]
  401680:	3301      	adds	r3, #1
  401682:	9300      	str	r3, [sp, #0]
			buf += sizeof(char *);
  401684:	3404      	adds	r4, #4
				if (BUF_OFFSET + size > len) {
  401686:	f1c5 0e08 	rsb	lr, r5, #8
	while (*++fmt != '\0') {
  40168a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  40168e:	2b00      	cmp	r3, #0
  401690:	f47f aecb 	bne.w	40142a <cbvprintf_package+0x82>
	if (BUF_OFFSET / sizeof(int) > 255) {
  401694:	1b60      	subs	r0, r4, r5
  401696:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
  40169a:	f4bf aec3 	bcs.w	401424 <cbvprintf_package+0x7c>
	if (buf0 == NULL) {
  40169e:	bb9d      	cbnz	r5, 401708 <cbvprintf_package+0x360>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
  4016a0:	3e08      	subs	r6, #8
  4016a2:	4430      	add	r0, r6
  4016a4:	e7b7      	b.n	401616 <cbvprintf_package+0x26e>
					str_ptr_pos[s_idx] = s_ptr_idx;
  4016a6:	f800 3c10 	strb.w	r3, [r0, #-16]
						s_rw_cnt++;
  4016aa:	9b02      	ldr	r3, [sp, #8]
  4016ac:	3301      	adds	r3, #1
  4016ae:	9302      	str	r3, [sp, #8]
  4016b0:	e7e5      	b.n	40167e <cbvprintf_package+0x2d6>
				} else if (is_ro) {
  4016b2:	f1bc 0f00 	cmp.w	ip, #0
  4016b6:	d001      	beq.n	4016bc <cbvprintf_package+0x314>
					len += 1;
  4016b8:	3601      	adds	r6, #1
  4016ba:	e7e0      	b.n	40167e <cbvprintf_package+0x2d6>
  4016bc:	3602      	adds	r6, #2
  4016be:	e9cd 1204 	strd	r1, r2, [sp, #16]
					len += strlen(s) + 1 + 1;
  4016c2:	f004 ff3c 	bl	40653e <strlen>
  4016c6:	4406      	add	r6, r0
  4016c8:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
  4016cc:	e7d7      	b.n	40167e <cbvprintf_package+0x2d6>
		} else if (size == sizeof(int)) {
  4016ce:	f1b9 0f04 	cmp.w	r9, #4
  4016d2:	d108      	bne.n	4016e6 <cbvprintf_package+0x33e>
			int v = va_arg(ap, int);
  4016d4:	f108 0004 	add.w	r0, r8, #4
			if (buf0 != NULL) {
  4016d8:	b115      	cbz	r5, 4016e0 <cbvprintf_package+0x338>
			int v = va_arg(ap, int);
  4016da:	f8d8 3000 	ldr.w	r3, [r8]
				*(int *)buf = v;
  4016de:	6023      	str	r3, [r4, #0]
			buf += sizeof(int);
  4016e0:	3404      	adds	r4, #4
			int v = va_arg(ap, int);
  4016e2:	4680      	mov	r8, r0
  4016e4:	e7d1      	b.n	40168a <cbvprintf_package+0x2e2>
		} else if (size == sizeof(long long)) {
  4016e6:	f1b9 0f08 	cmp.w	r9, #8
  4016ea:	f47f ae9b 	bne.w	401424 <cbvprintf_package+0x7c>
			long long v = va_arg(ap, long long);
  4016ee:	f108 0307 	add.w	r3, r8, #7
  4016f2:	f023 0307 	bic.w	r3, r3, #7
  4016f6:	f103 0808 	add.w	r8, r3, #8
			if (buf0 != NULL) {
  4016fa:	b11d      	cbz	r5, 401704 <cbvprintf_package+0x35c>
			long long v = va_arg(ap, long long);
  4016fc:	e9d3 bc00 	ldrd	fp, ip, [r3]
  401700:	e9c4 bc00 	strd	fp, ip, [r4]
			buf += sizeof(long long);
  401704:	3408      	adds	r4, #8
  401706:	e7c0      	b.n	40168a <cbvprintf_package+0x2e2>
	buf0[0] = BUF_OFFSET / sizeof(int);
  401708:	0880      	lsrs	r0, r0, #2
	buf0[1] = s_rw_cnt;
  40170a:	9a02      	ldr	r2, [sp, #8]
	*(char **)buf0 = NULL;
  40170c:	602b      	str	r3, [r5, #0]
	buf0[0] = BUF_OFFSET / sizeof(int);
  40170e:	7028      	strb	r0, [r5, #0]
	buf0[1] = s_rw_cnt;
  401710:	706a      	strb	r2, [r5, #1]
	buf0[2] = s_ro_cnt;
  401712:	f885 a002 	strb.w	sl, [r5, #2]
	if (s_ro_cnt) {
  401716:	f1ba 0f00 	cmp.w	sl, #0
  40171a:	d005      	beq.n	401728 <cbvprintf_package+0x380>
  40171c:	a906      	add	r1, sp, #24
			if (BUF_OFFSET + 1 > len) {
  40171e:	f1c5 0001 	rsb	r0, r5, #1
		for (i = 0; i < s_idx; i++) {
  401722:	9a00      	ldr	r2, [sp, #0]
  401724:	429a      	cmp	r2, r3
  401726:	d107      	bne.n	401738 <cbvprintf_package+0x390>
		if (BUF_OFFSET + 1 + size > len) {
  401728:	f1c5 0901 	rsb	r9, r5, #1
  40172c:	e039      	b.n	4017a2 <cbvprintf_package+0x3fa>
  40172e:	bf00      	nop
  401730:	00406ed0 	.word	0x00406ed0
  401734:	00408020 	.word	0x00408020
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
  401738:	f811 2b01 	ldrb.w	r2, [r1], #1
  40173c:	0617      	lsls	r7, r2, #24
  40173e:	d507      	bpl.n	401750 <cbvprintf_package+0x3a8>
			if (BUF_OFFSET + 1 > len) {
  401740:	1827      	adds	r7, r4, r0
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
  401742:	f002 027f 	and.w	r2, r2, #127	; 0x7f
			if (BUF_OFFSET + 1 > len) {
  401746:	42b7      	cmp	r7, r6
  401748:	f63f af63 	bhi.w	401612 <cbvprintf_package+0x26a>
			*buf++ = pos;
  40174c:	f804 2b01 	strb.w	r2, [r4], #1
		for (i = 0; i < s_idx; i++) {
  401750:	3301      	adds	r3, #1
  401752:	e7e6      	b.n	401722 <cbvprintf_package+0x37a>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
  401754:	9b01      	ldr	r3, [sp, #4]
  401756:	aa06      	add	r2, sp, #24
  401758:	f812 8003 	ldrb.w	r8, [r2, r3]
  40175c:	f1ba 0f00 	cmp.w	sl, #0
  401760:	d002      	beq.n	401768 <cbvprintf_package+0x3c0>
  401762:	f018 0f80 	tst.w	r8, #128	; 0x80
  401766:	d119      	bne.n	40179c <cbvprintf_package+0x3f4>
		s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  401768:	fa0f f288 	sxth.w	r2, r8
		*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  40176c:	2300      	movs	r3, #0
		s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  40176e:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
		*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  401772:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
		size = strlen(s) + 1;
  401776:	4608      	mov	r0, r1
  401778:	9102      	str	r1, [sp, #8]
  40177a:	f004 fee0 	bl	40653e <strlen>
		if (BUF_OFFSET + 1 + size > len) {
  40177e:	eb04 0209 	add.w	r2, r4, r9
		size = strlen(s) + 1;
  401782:	1c47      	adds	r7, r0, #1
		if (BUF_OFFSET + 1 + size > len) {
  401784:	443a      	add	r2, r7
  401786:	42b2      	cmp	r2, r6
  401788:	f63f af43 	bhi.w	401612 <cbvprintf_package+0x26a>
		*buf++ = str_ptr_pos[i];
  40178c:	f804 8b01 	strb.w	r8, [r4], #1
		memcpy(buf, s, size);
  401790:	4620      	mov	r0, r4
		buf += size;
  401792:	443c      	add	r4, r7
		memcpy(buf, s, size);
  401794:	463a      	mov	r2, r7
  401796:	9902      	ldr	r1, [sp, #8]
  401798:	f004 fee1 	bl	40655e <memcpy>
	for (i = 0; i < s_idx; i++) {
  40179c:	9b01      	ldr	r3, [sp, #4]
  40179e:	3301      	adds	r3, #1
  4017a0:	9301      	str	r3, [sp, #4]
  4017a2:	e9dd 2300 	ldrd	r2, r3, [sp]
  4017a6:	429a      	cmp	r2, r3
  4017a8:	d1d4      	bne.n	401754 <cbvprintf_package+0x3ac>
	return BUF_OFFSET;
  4017aa:	1b60      	subs	r0, r4, r5
  4017ac:	e733      	b.n	401616 <cbvprintf_package+0x26e>
		return -EFAULT;
  4017ae:	f06f 000d 	mvn.w	r0, #13
  4017b2:	e730      	b.n	401616 <cbvprintf_package+0x26e>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  4017b4:	2907      	cmp	r1, #7
  4017b6:	f63f ae0e 	bhi.w	4013d6 <cbvprintf_package+0x2e>
  4017ba:	e72a      	b.n	401612 <cbvprintf_package+0x26a>

004017bc <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
  4017bc:	680b      	ldr	r3, [r1, #0]
  4017be:	3301      	adds	r3, #1
  4017c0:	600b      	str	r3, [r1, #0]
	return _char_out(c);
  4017c2:	4b01      	ldr	r3, [pc, #4]	; (4017c8 <char_out+0xc>)
  4017c4:	681b      	ldr	r3, [r3, #0]
  4017c6:	4718      	bx	r3
  4017c8:	20400004 	.word	0x20400004

004017cc <__printk_hook_install>:
	_char_out = fn;
  4017cc:	4b01      	ldr	r3, [pc, #4]	; (4017d4 <__printk_hook_install+0x8>)
  4017ce:	6018      	str	r0, [r3, #0]
}
  4017d0:	4770      	bx	lr
  4017d2:	bf00      	nop
  4017d4:	20400004 	.word	0x20400004

004017d8 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
  4017d8:	b507      	push	{r0, r1, r2, lr}
  4017da:	460b      	mov	r3, r1

		if (ctx.buf_count) {
			buf_flush(&ctx);
		}
	} else {
		struct out_context ctx = { 0 };
  4017dc:	2100      	movs	r1, #0
{
  4017de:	4602      	mov	r2, r0
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
  4017e0:	4803      	ldr	r0, [pc, #12]	; (4017f0 <vprintk+0x18>)
		struct out_context ctx = { 0 };
  4017e2:	9101      	str	r1, [sp, #4]
		cbvprintf(char_out, &ctx, fmt, ap);
  4017e4:	a901      	add	r1, sp, #4
  4017e6:	f000 f819 	bl	40181c <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
  4017ea:	b003      	add	sp, #12
  4017ec:	f85d fb04 	ldr.w	pc, [sp], #4
  4017f0:	004017bd 	.word	0x004017bd

004017f4 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
  4017f4:	b530      	push	{r4, r5, lr}
  4017f6:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
  4017f8:	2500      	movs	r5, #0
{
  4017fa:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
  4017fc:	9503      	str	r5, [sp, #12]
  4017fe:	e9cd 0101 	strd	r0, r1, [sp, #4]

	cbvprintf(str_out, &ctx, fmt, ap);
  401802:	a901      	add	r1, sp, #4
  401804:	4804      	ldr	r0, [pc, #16]	; (401818 <vsnprintk+0x24>)
  401806:	f000 f809 	bl	40181c <cbvprintf>

	if (ctx.count < ctx.max) {
  40180a:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
  40180e:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
  401810:	bfb8      	it	lt
  401812:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
  401814:	b005      	add	sp, #20
  401816:	bd30      	pop	{r4, r5, pc}
  401818:	00405c4f 	.word	0x00405c4f

0040181c <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
  40181c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401820:	468b      	mov	fp, r1
  401822:	b091      	sub	sp, #68	; 0x44
  401824:	4692      	mov	sl, r2
  401826:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  401828:	2500      	movs	r5, #0
{
  40182a:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  40182c:	f89a 0000 	ldrb.w	r0, [sl]
  401830:	b908      	cbnz	r0, 401836 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
  401832:	4628      	mov	r0, r5
  401834:	e360      	b.n	401ef8 <cbvprintf+0x6dc>
		if (*fp != '%') {
  401836:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
  401838:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
  40183c:	d007      	beq.n	40184e <cbvprintf+0x32>
			OUTC('%');
  40183e:	4659      	mov	r1, fp
  401840:	9b02      	ldr	r3, [sp, #8]
  401842:	4798      	blx	r3
  401844:	2800      	cmp	r0, #0
  401846:	f2c0 8357 	blt.w	401ef8 <cbvprintf+0x6dc>
  40184a:	3501      	adds	r5, #1
			break;
  40184c:	e212      	b.n	401c74 <cbvprintf+0x458>
		} state = {
  40184e:	2218      	movs	r2, #24
  401850:	2100      	movs	r1, #0
  401852:	a80a      	add	r0, sp, #40	; 0x28
  401854:	f004 fe8e 	bl	406574 <memset>
	if (*sp == '%') {
  401858:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40185c:	2b25      	cmp	r3, #37	; 0x25
  40185e:	d078      	beq.n	401952 <cbvprintf+0x136>
  401860:	2200      	movs	r2, #0
  401862:	4610      	mov	r0, r2
  401864:	4696      	mov	lr, r2
  401866:	4694      	mov	ip, r2
  401868:	4616      	mov	r6, r2
  40186a:	4639      	mov	r1, r7
		switch (*sp) {
  40186c:	f817 3b01 	ldrb.w	r3, [r7], #1
  401870:	2b2b      	cmp	r3, #43	; 0x2b
  401872:	f000 809d 	beq.w	4019b0 <cbvprintf+0x194>
  401876:	f200 8094 	bhi.w	4019a2 <cbvprintf+0x186>
  40187a:	2b20      	cmp	r3, #32
  40187c:	f000 809b 	beq.w	4019b6 <cbvprintf+0x19a>
  401880:	2b23      	cmp	r3, #35	; 0x23
  401882:	f000 809b 	beq.w	4019bc <cbvprintf+0x1a0>
  401886:	b12e      	cbz	r6, 401894 <cbvprintf+0x78>
  401888:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
  40188c:	f046 0604 	orr.w	r6, r6, #4
  401890:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
  401894:	f1bc 0f00 	cmp.w	ip, #0
  401898:	d005      	beq.n	4018a6 <cbvprintf+0x8a>
  40189a:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
  40189e:	f046 0608 	orr.w	r6, r6, #8
  4018a2:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
  4018a6:	f1be 0f00 	cmp.w	lr, #0
  4018aa:	d005      	beq.n	4018b8 <cbvprintf+0x9c>
  4018ac:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
  4018b0:	f046 0610 	orr.w	r6, r6, #16
  4018b4:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
  4018b8:	b128      	cbz	r0, 4018c6 <cbvprintf+0xaa>
  4018ba:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
  4018be:	f040 0020 	orr.w	r0, r0, #32
  4018c2:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
  4018c6:	b12a      	cbz	r2, 4018d4 <cbvprintf+0xb8>
  4018c8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
  4018cc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  4018d0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
  4018d4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
  4018d8:	f002 0044 	and.w	r0, r2, #68	; 0x44
  4018dc:	2844      	cmp	r0, #68	; 0x44
  4018de:	d103      	bne.n	4018e8 <cbvprintf+0xcc>
		conv->flag_zero = false;
  4018e0:	f36f 1286 	bfc	r2, #6, #1
  4018e4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
  4018e8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
  4018ec:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
  4018ee:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  4018f2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
  4018f6:	d17b      	bne.n	4019f0 <cbvprintf+0x1d4>
		conv->width_star = true;
  4018f8:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
			++sp;
  4018fc:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
  4018fe:	f042 0201 	orr.w	r2, r2, #1
  401902:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
  401906:	781a      	ldrb	r2, [r3, #0]
  401908:	2a2e      	cmp	r2, #46	; 0x2e
  40190a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
  40190e:	bf0c      	ite	eq
  401910:	2101      	moveq	r1, #1
  401912:	2100      	movne	r1, #0
  401914:	f361 0241 	bfi	r2, r1, #1, #1
  401918:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
  40191c:	d174      	bne.n	401a08 <cbvprintf+0x1ec>
	if (*sp == '*') {
  40191e:	785a      	ldrb	r2, [r3, #1]
  401920:	2a2a      	cmp	r2, #42	; 0x2a
  401922:	d06a      	beq.n	4019fa <cbvprintf+0x1de>
	++sp;
  401924:	3301      	adds	r3, #1
	size_t val = 0;
  401926:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
  401928:	260a      	movs	r6, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  40192a:	4618      	mov	r0, r3
  40192c:	f810 2b01 	ldrb.w	r2, [r0], #1
  401930:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
  401934:	2f09      	cmp	r7, #9
  401936:	f240 808e 	bls.w	401a56 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
  40193a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
  40193e:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
  401940:	f3c2 0040 	ubfx	r0, r2, #1, #1
  401944:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
  401948:	f361 0241 	bfi	r2, r1, #1, #1
  40194c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
  401950:	e05a      	b.n	401a08 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
  401952:	f10a 0702 	add.w	r7, sl, #2
  401956:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
  40195a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  40195e:	07d9      	lsls	r1, r3, #31
  401960:	f140 8149 	bpl.w	401bf6 <cbvprintf+0x3da>
			width = va_arg(ap, int);
  401964:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
  401968:	f1b9 0f00 	cmp.w	r9, #0
  40196c:	da07      	bge.n	40197e <cbvprintf+0x162>
				conv->flag_dash = true;
  40196e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
  401972:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
  401976:	f042 0204 	orr.w	r2, r2, #4
  40197a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
  40197e:	075a      	lsls	r2, r3, #29
  401980:	f140 8142 	bpl.w	401c08 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
  401984:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
  401988:	f1b8 0f00 	cmp.w	r8, #0
  40198c:	f280 8141 	bge.w	401c12 <cbvprintf+0x3f6>
				conv->prec_present = false;
  401990:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  401994:	f36f 0341 	bfc	r3, #1, #1
  401998:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
  40199c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  4019a0:	e137      	b.n	401c12 <cbvprintf+0x3f6>
		switch (*sp) {
  4019a2:	2b2d      	cmp	r3, #45	; 0x2d
  4019a4:	d00c      	beq.n	4019c0 <cbvprintf+0x1a4>
  4019a6:	2b30      	cmp	r3, #48	; 0x30
  4019a8:	f47f af6d 	bne.w	401886 <cbvprintf+0x6a>
			conv->flag_zero = true;
  4019ac:	2201      	movs	r2, #1
	} while (loop);
  4019ae:	e75c      	b.n	40186a <cbvprintf+0x4e>
			conv->flag_plus = true;
  4019b0:	f04f 0c01 	mov.w	ip, #1
  4019b4:	e759      	b.n	40186a <cbvprintf+0x4e>
			conv->flag_space = true;
  4019b6:	f04f 0e01 	mov.w	lr, #1
  4019ba:	e756      	b.n	40186a <cbvprintf+0x4e>
			conv->flag_hash = true;
  4019bc:	2001      	movs	r0, #1
  4019be:	e754      	b.n	40186a <cbvprintf+0x4e>
		switch (*sp) {
  4019c0:	2601      	movs	r6, #1
  4019c2:	e752      	b.n	40186a <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
  4019c4:	fb0c 0202 	mla	r2, ip, r2, r0
  4019c8:	4633      	mov	r3, r6
  4019ca:	3a30      	subs	r2, #48	; 0x30
  4019cc:	461e      	mov	r6, r3
  4019ce:	f816 0b01 	ldrb.w	r0, [r6], #1
  4019d2:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
  4019d6:	2f09      	cmp	r7, #9
  4019d8:	d9f4      	bls.n	4019c4 <cbvprintf+0x1a8>
	if (sp != wp) {
  4019da:	4299      	cmp	r1, r3
  4019dc:	d093      	beq.n	401906 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
  4019de:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
  4019e2:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
  4019e4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
  4019e6:	f362 0141 	bfi	r1, r2, #1, #1
  4019ea:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
  4019ee:	e78a      	b.n	401906 <cbvprintf+0xea>
  4019f0:	460b      	mov	r3, r1
	size_t val = 0;
  4019f2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
  4019f4:	f04f 0c0a 	mov.w	ip, #10
  4019f8:	e7e8      	b.n	4019cc <cbvprintf+0x1b0>
		conv->prec_star = true;
  4019fa:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
  4019fe:	3302      	adds	r3, #2
		conv->prec_star = true;
  401a00:	f042 0204 	orr.w	r2, r2, #4
  401a04:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
  401a08:	461f      	mov	r7, r3
  401a0a:	f817 2b01 	ldrb.w	r2, [r7], #1
  401a0e:	2a6c      	cmp	r2, #108	; 0x6c
  401a10:	d041      	beq.n	401a96 <cbvprintf+0x27a>
  401a12:	d825      	bhi.n	401a60 <cbvprintf+0x244>
  401a14:	2a68      	cmp	r2, #104	; 0x68
  401a16:	d02b      	beq.n	401a70 <cbvprintf+0x254>
  401a18:	2a6a      	cmp	r2, #106	; 0x6a
  401a1a:	d046      	beq.n	401aaa <cbvprintf+0x28e>
  401a1c:	2a4c      	cmp	r2, #76	; 0x4c
  401a1e:	d04c      	beq.n	401aba <cbvprintf+0x29e>
  401a20:	461f      	mov	r7, r3
	conv->specifier = *sp++;
  401a22:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
  401a26:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
  401a2a:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
  401a2c:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
  401a30:	f200 80d9 	bhi.w	401be6 <cbvprintf+0x3ca>
  401a34:	2a57      	cmp	r2, #87	; 0x57
  401a36:	d84d      	bhi.n	401ad4 <cbvprintf+0x2b8>
  401a38:	2a41      	cmp	r2, #65	; 0x41
  401a3a:	d003      	beq.n	401a44 <cbvprintf+0x228>
  401a3c:	3a45      	subs	r2, #69	; 0x45
  401a3e:	2a02      	cmp	r2, #2
  401a40:	f200 80d1 	bhi.w	401be6 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
  401a44:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
  401a48:	2204      	movs	r2, #4
  401a4a:	f362 0302 	bfi	r3, r2, #0, #3
  401a4e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
  401a52:	2301      	movs	r3, #1
			break;
  401a54:	e09e      	b.n	401b94 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
  401a56:	fb06 2101 	mla	r1, r6, r1, r2
  401a5a:	4603      	mov	r3, r0
  401a5c:	3930      	subs	r1, #48	; 0x30
  401a5e:	e764      	b.n	40192a <cbvprintf+0x10e>
	switch (*sp) {
  401a60:	2a74      	cmp	r2, #116	; 0x74
  401a62:	d026      	beq.n	401ab2 <cbvprintf+0x296>
  401a64:	2a7a      	cmp	r2, #122	; 0x7a
  401a66:	d1db      	bne.n	401a20 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
  401a68:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  401a6c:	2206      	movs	r2, #6
  401a6e:	e00d      	b.n	401a8c <cbvprintf+0x270>
		if (*++sp == 'h') {
  401a70:	785a      	ldrb	r2, [r3, #1]
  401a72:	2a68      	cmp	r2, #104	; 0x68
  401a74:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
  401a78:	d106      	bne.n	401a88 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
  401a7a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
  401a7c:	f361 02c6 	bfi	r2, r1, #3, #4
			++sp;
  401a80:	1c9f      	adds	r7, r3, #2
			conv->length_mod = LENGTH_LL;
  401a82:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
  401a86:	e7cc      	b.n	401a22 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
  401a88:	4613      	mov	r3, r2
  401a8a:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
  401a8c:	f362 03c6 	bfi	r3, r2, #3, #4
  401a90:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
  401a94:	e7c5      	b.n	401a22 <cbvprintf+0x206>
		if (*++sp == 'l') {
  401a96:	785a      	ldrb	r2, [r3, #1]
  401a98:	2a6c      	cmp	r2, #108	; 0x6c
  401a9a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
  401a9e:	d101      	bne.n	401aa4 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
  401aa0:	2104      	movs	r1, #4
  401aa2:	e7eb      	b.n	401a7c <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
  401aa4:	4613      	mov	r3, r2
  401aa6:	2203      	movs	r2, #3
  401aa8:	e7f0      	b.n	401a8c <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
  401aaa:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  401aae:	2205      	movs	r2, #5
  401ab0:	e7ec      	b.n	401a8c <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
  401ab2:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  401ab6:	2207      	movs	r2, #7
  401ab8:	e7e8      	b.n	401a8c <cbvprintf+0x270>
		conv->unsupported = true;
  401aba:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
  401abe:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
  401ac2:	f023 0302 	bic.w	r3, r3, #2
  401ac6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  401aca:	f043 0302 	orr.w	r3, r3, #2
  401ace:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
  401ad2:	e7a6      	b.n	401a22 <cbvprintf+0x206>
	switch (conv->specifier) {
  401ad4:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
  401ad8:	2920      	cmp	r1, #32
  401ada:	f200 8084 	bhi.w	401be6 <cbvprintf+0x3ca>
  401ade:	a001      	add	r0, pc, #4	; (adr r0, 401ae4 <cbvprintf+0x2c8>)
  401ae0:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
  401ae4:	00401ba9 	.word	0x00401ba9
  401ae8:	00401be7 	.word	0x00401be7
  401aec:	00401be7 	.word	0x00401be7
  401af0:	00401be7 	.word	0x00401be7
  401af4:	00401be7 	.word	0x00401be7
  401af8:	00401be7 	.word	0x00401be7
  401afc:	00401be7 	.word	0x00401be7
  401b00:	00401be7 	.word	0x00401be7
  401b04:	00401be7 	.word	0x00401be7
  401b08:	00401a45 	.word	0x00401a45
  401b0c:	00401be7 	.word	0x00401be7
  401b10:	00401ba9 	.word	0x00401ba9
  401b14:	00401b69 	.word	0x00401b69
  401b18:	00401a45 	.word	0x00401a45
  401b1c:	00401a45 	.word	0x00401a45
  401b20:	00401a45 	.word	0x00401a45
  401b24:	00401be7 	.word	0x00401be7
  401b28:	00401b69 	.word	0x00401b69
  401b2c:	00401be7 	.word	0x00401be7
  401b30:	00401be7 	.word	0x00401be7
  401b34:	00401be7 	.word	0x00401be7
  401b38:	00401be7 	.word	0x00401be7
  401b3c:	00401bb1 	.word	0x00401bb1
  401b40:	00401ba9 	.word	0x00401ba9
  401b44:	00401bcd 	.word	0x00401bcd
  401b48:	00401be7 	.word	0x00401be7
  401b4c:	00401be7 	.word	0x00401be7
  401b50:	00401bcd 	.word	0x00401bcd
  401b54:	00401be7 	.word	0x00401be7
  401b58:	00401ba9 	.word	0x00401ba9
  401b5c:	00401be7 	.word	0x00401be7
  401b60:	00401be7 	.word	0x00401be7
  401b64:	00401ba9 	.word	0x00401ba9
		conv->specifier_cat = SPECIFIER_SINT;
  401b68:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
  401b6c:	2001      	movs	r0, #1
		if (conv->length_mod == LENGTH_UPPER_L) {
  401b6e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
  401b72:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  401b76:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
  401b78:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
  401b7c:	bf02      	ittt	eq
  401b7e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
  401b82:	f041 0101 	orreq.w	r1, r1, #1
  401b86:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
  401b8a:	2a63      	cmp	r2, #99	; 0x63
  401b8c:	d131      	bne.n	401bf2 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
  401b8e:	3b00      	subs	r3, #0
  401b90:	bf18      	it	ne
  401b92:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
  401b94:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
  401b98:	f3c2 0140 	ubfx	r1, r2, #1, #1
  401b9c:	430b      	orrs	r3, r1
  401b9e:	f363 0241 	bfi	r2, r3, #1, #1
  401ba2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
  401ba6:	e6d8      	b.n	40195a <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
  401ba8:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
  401bac:	2002      	movs	r0, #2
  401bae:	e7de      	b.n	401b6e <cbvprintf+0x352>
		if (conv->length_mod == LENGTH_UPPER_L) {
  401bb0:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
  401bb4:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
  401bb8:	2103      	movs	r1, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  401bba:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
  401bbe:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  401bc2:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
  401bc4:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
  401bc8:	4143      	adcs	r3, r0
  401bca:	e7e3      	b.n	401b94 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
  401bcc:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
  401bd0:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
  401bd2:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
  401bd6:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
  401bda:	bf14      	ite	ne
  401bdc:	2301      	movne	r3, #1
  401bde:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
  401be0:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
  401be4:	e7d6      	b.n	401b94 <cbvprintf+0x378>
		conv->invalid = true;
  401be6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
  401bea:	f043 0301 	orr.w	r3, r3, #1
  401bee:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
  401bf2:	2300      	movs	r3, #0
  401bf4:	e7ce      	b.n	401b94 <cbvprintf+0x378>
		} else if (conv->width_present) {
  401bf6:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
  401bfa:	2a00      	cmp	r2, #0
			width = conv->width_value;
  401bfc:	bfb4      	ite	lt
  401bfe:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
		int width = -1;
  401c02:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
  401c06:	e6ba      	b.n	40197e <cbvprintf+0x162>
		} else if (conv->prec_present) {
  401c08:	079b      	lsls	r3, r3, #30
  401c0a:	f57f aec7 	bpl.w	40199c <cbvprintf+0x180>
			precision = conv->prec_value;
  401c0e:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
  401c12:	2300      	movs	r3, #0
			= (enum length_mod_enum)conv->length_mod;
  401c14:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		conv->pad0_pre_exp = 0;
  401c18:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
  401c1c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
  401c20:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		enum specifier_cat_enum specifier_cat
  401c24:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
  401c28:	2b01      	cmp	r3, #1
  401c2a:	d138      	bne.n	401c9e <cbvprintf+0x482>
			switch (length_mod) {
  401c2c:	1ecb      	subs	r3, r1, #3
  401c2e:	2b04      	cmp	r3, #4
  401c30:	d822      	bhi.n	401c78 <cbvprintf+0x45c>
  401c32:	e8df f003 	tbb	[pc, r3]
  401c36:	0903      	.short	0x0903
  401c38:	2109      	.short	0x2109
  401c3a:	21          	.byte	0x21
  401c3b:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
  401c3c:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
  401c40:	17da      	asrs	r2, r3, #31
  401c42:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
  401c46:	e006      	b.n	401c56 <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
  401c48:	3407      	adds	r4, #7
  401c4a:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
  401c4e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
  401c52:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
  401c56:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
  401c5a:	f013 0603 	ands.w	r6, r3, #3
  401c5e:	d056      	beq.n	401d0e <cbvprintf+0x4f2>
			OUTS(sp, fp);
  401c60:	463b      	mov	r3, r7
  401c62:	4652      	mov	r2, sl
  401c64:	4659      	mov	r1, fp
  401c66:	9802      	ldr	r0, [sp, #8]
  401c68:	f004 f949 	bl	405efe <outs>
  401c6c:	2800      	cmp	r0, #0
  401c6e:	f2c0 8143 	blt.w	401ef8 <cbvprintf+0x6dc>
  401c72:	4405      	add	r5, r0
			continue;
  401c74:	46ba      	mov	sl, r7
  401c76:	e5d9      	b.n	40182c <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
  401c78:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
  401c7c:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
  401c7e:	ea4f 72e3 	mov.w	r2, r3, asr #31
  401c82:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
  401c86:	d105      	bne.n	401c94 <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
  401c88:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
  401c8c:	930a      	str	r3, [sp, #40]	; 0x28
  401c8e:	2300      	movs	r3, #0
  401c90:	930b      	str	r3, [sp, #44]	; 0x2c
  401c92:	e7e0      	b.n	401c56 <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
  401c94:	2902      	cmp	r1, #2
  401c96:	d1de      	bne.n	401c56 <cbvprintf+0x43a>
				value->sint = (short)value->sint;
  401c98:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
  401c9c:	e7d0      	b.n	401c40 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
  401c9e:	2b02      	cmp	r3, #2
  401ca0:	d123      	bne.n	401cea <cbvprintf+0x4ce>
			switch (length_mod) {
  401ca2:	1ecb      	subs	r3, r1, #3
  401ca4:	2b04      	cmp	r3, #4
  401ca6:	d813      	bhi.n	401cd0 <cbvprintf+0x4b4>
  401ca8:	e8df f003 	tbb	[pc, r3]
  401cac:	120a0a03 	.word	0x120a0a03
  401cb0:	12          	.byte	0x12
  401cb1:	00          	.byte	0x00
					value->uint = (wchar_t)va_arg(ap,
  401cb2:	6822      	ldr	r2, [r4, #0]
  401cb4:	2300      	movs	r3, #0
				value->sint = va_arg(ap, int);
  401cb6:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
  401cb8:	920a      	str	r2, [sp, #40]	; 0x28
  401cba:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
  401cbc:	4604      	mov	r4, r0
  401cbe:	e7ca      	b.n	401c56 <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
  401cc0:	1de0      	adds	r0, r4, #7
  401cc2:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
  401cc6:	e8f0 2302 	ldrd	r2, r3, [r0], #8
  401cca:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
  401cce:	e7f5      	b.n	401cbc <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
  401cd0:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
  401cd4:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
  401cd6:	930a      	str	r3, [sp, #40]	; 0x28
  401cd8:	f04f 0300 	mov.w	r3, #0
  401cdc:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
  401cde:	d0d3      	beq.n	401c88 <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
  401ce0:	2902      	cmp	r1, #2
  401ce2:	d1b8      	bne.n	401c56 <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
  401ce4:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  401ce8:	e7d0      	b.n	401c8c <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
  401cea:	2b04      	cmp	r3, #4
  401cec:	d109      	bne.n	401d02 <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
  401cee:	1de3      	adds	r3, r4, #7
  401cf0:	f023 0307 	bic.w	r3, r3, #7
  401cf4:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
  401cf8:	e9d3 2300 	ldrd	r2, r3, [r3]
  401cfc:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  401d00:	e7a9      	b.n	401c56 <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
  401d02:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
  401d04:	bf04      	itt	eq
  401d06:	f854 3b04 	ldreq.w	r3, [r4], #4
  401d0a:	930a      	streq	r3, [sp, #40]	; 0x28
  401d0c:	e7a3      	b.n	401c56 <cbvprintf+0x43a>
		switch (conv->specifier) {
  401d0e:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
  401d12:	2878      	cmp	r0, #120	; 0x78
  401d14:	d8ae      	bhi.n	401c74 <cbvprintf+0x458>
  401d16:	2862      	cmp	r0, #98	; 0x62
  401d18:	d822      	bhi.n	401d60 <cbvprintf+0x544>
  401d1a:	2825      	cmp	r0, #37	; 0x25
  401d1c:	f43f ad8f 	beq.w	40183e <cbvprintf+0x22>
  401d20:	2858      	cmp	r0, #88	; 0x58
  401d22:	d1a7      	bne.n	401c74 <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
  401d24:	f10d 0326 	add.w	r3, sp, #38	; 0x26
  401d28:	aa0c      	add	r2, sp, #48	; 0x30
  401d2a:	9300      	str	r3, [sp, #0]
  401d2c:	ab04      	add	r3, sp, #16
  401d2e:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
  401d32:	f004 f89e 	bl	405e72 <encode_uint>
  401d36:	4682      	mov	sl, r0
			if (precision >= 0) {
  401d38:	f1b8 0f00 	cmp.w	r8, #0
  401d3c:	f10d 0026 	add.w	r0, sp, #38	; 0x26
  401d40:	db0c      	blt.n	401d5c <cbvprintf+0x540>
				conv->flag_zero = false;
  401d42:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
  401d46:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
  401d4a:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
  401d4e:	4598      	cmp	r8, r3
				conv->flag_zero = false;
  401d50:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
  401d54:	d902      	bls.n	401d5c <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
  401d56:	eba8 0303 	sub.w	r3, r8, r3
  401d5a:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
  401d5c:	4680      	mov	r8, r0
  401d5e:	e03d      	b.n	401ddc <cbvprintf+0x5c0>
		switch (conv->specifier) {
  401d60:	3863      	subs	r0, #99	; 0x63
  401d62:	2815      	cmp	r0, #21
  401d64:	d886      	bhi.n	401c74 <cbvprintf+0x458>
  401d66:	a201      	add	r2, pc, #4	; (adr r2, 401d6c <cbvprintf+0x550>)
  401d68:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
  401d6c:	00401ded 	.word	0x00401ded
  401d70:	00401e51 	.word	0x00401e51
  401d74:	00401c75 	.word	0x00401c75
  401d78:	00401c75 	.word	0x00401c75
  401d7c:	00401c75 	.word	0x00401c75
  401d80:	00401c75 	.word	0x00401c75
  401d84:	00401e51 	.word	0x00401e51
  401d88:	00401c75 	.word	0x00401c75
  401d8c:	00401c75 	.word	0x00401c75
  401d90:	00401c75 	.word	0x00401c75
  401d94:	00401c75 	.word	0x00401c75
  401d98:	00401ead 	.word	0x00401ead
  401d9c:	00401e7b 	.word	0x00401e7b
  401da0:	00401e7f 	.word	0x00401e7f
  401da4:	00401c75 	.word	0x00401c75
  401da8:	00401c75 	.word	0x00401c75
  401dac:	00401dc5 	.word	0x00401dc5
  401db0:	00401c75 	.word	0x00401c75
  401db4:	00401e7b 	.word	0x00401e7b
  401db8:	00401c75 	.word	0x00401c75
  401dbc:	00401c75 	.word	0x00401c75
  401dc0:	00401e7b 	.word	0x00401e7b
			if (precision >= 0) {
  401dc4:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
  401dc8:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
  401dcc:	db0a      	blt.n	401de4 <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
  401dce:	4641      	mov	r1, r8
  401dd0:	4650      	mov	r0, sl
  401dd2:	f004 fbbb 	bl	40654c <strnlen>
			bpe = bps + len;
  401dd6:	eb0a 0800 	add.w	r8, sl, r0
		char sign = 0;
  401dda:	2600      	movs	r6, #0
		if (bps == NULL) {
  401ddc:	f1ba 0f00 	cmp.w	sl, #0
  401de0:	d10c      	bne.n	401dfc <cbvprintf+0x5e0>
  401de2:	e747      	b.n	401c74 <cbvprintf+0x458>
				len = strlen(bps);
  401de4:	4650      	mov	r0, sl
  401de6:	f004 fbaa 	bl	40653e <strlen>
  401dea:	e7f4      	b.n	401dd6 <cbvprintf+0x5ba>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  401dec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			break;
  401dee:	2600      	movs	r6, #0
			bps = buf;
  401df0:	f10d 0a10 	add.w	sl, sp, #16
			bpe = buf + 1;
  401df4:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  401df8:	f88d 3010 	strb.w	r3, [sp, #16]
		size_t nj_len = (bpe - bps);
  401dfc:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
  401e00:	b106      	cbz	r6, 401e04 <cbvprintf+0x5e8>
			nj_len += 1U;
  401e02:	3301      	adds	r3, #1
		if (conv->altform_0c) {
  401e04:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
  401e08:	06d0      	lsls	r0, r2, #27
  401e0a:	d569      	bpl.n	401ee0 <cbvprintf+0x6c4>
			nj_len += 2U;
  401e0c:	3302      	adds	r3, #2
		if (conv->pad_fp) {
  401e0e:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
  401e10:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
  401e12:	bf48      	it	mi
  401e14:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
  401e16:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
  401e18:	bf48      	it	mi
  401e1a:	189b      	addmi	r3, r3, r2
		if (width > 0) {
  401e1c:	f1b9 0f00 	cmp.w	r9, #0
  401e20:	dd77      	ble.n	401f12 <cbvprintf+0x6f6>
			if (!conv->flag_dash) {
  401e22:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
  401e26:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
  401e2a:	f3c2 0380 	ubfx	r3, r2, #2, #1
  401e2e:	9303      	str	r3, [sp, #12]
  401e30:	0753      	lsls	r3, r2, #29
  401e32:	d46e      	bmi.n	401f12 <cbvprintf+0x6f6>
				if (conv->flag_zero) {
  401e34:	0650      	lsls	r0, r2, #25
  401e36:	d562      	bpl.n	401efe <cbvprintf+0x6e2>
					if (sign != 0) {
  401e38:	b146      	cbz	r6, 401e4c <cbvprintf+0x630>
						OUTC(sign);
  401e3a:	4659      	mov	r1, fp
  401e3c:	4630      	mov	r0, r6
  401e3e:	9b02      	ldr	r3, [sp, #8]
  401e40:	4798      	blx	r3
  401e42:	2800      	cmp	r0, #0
  401e44:	db58      	blt.n	401ef8 <cbvprintf+0x6dc>
						sign = 0;
  401e46:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
  401e48:	3501      	adds	r5, #1
						sign = 0;
  401e4a:	461e      	mov	r6, r3
					pad = '0';
  401e4c:	2330      	movs	r3, #48	; 0x30
  401e4e:	e057      	b.n	401f00 <cbvprintf+0x6e4>
			if (conv->flag_plus) {
  401e50:	071e      	lsls	r6, r3, #28
  401e52:	d410      	bmi.n	401e76 <cbvprintf+0x65a>
				sign = ' ';
  401e54:	f013 0610 	ands.w	r6, r3, #16
  401e58:	bf18      	it	ne
  401e5a:	2620      	movne	r6, #32
			sint = value->sint;
  401e5c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
  401e60:	2b00      	cmp	r3, #0
  401e62:	f6bf af5f 	bge.w	401d24 <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
  401e66:	4252      	negs	r2, r2
				sign = '-';
  401e68:	f04f 062d 	mov.w	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
  401e6c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  401e70:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  401e74:	e756      	b.n	401d24 <cbvprintf+0x508>
				sign = '+';
  401e76:	262b      	movs	r6, #43	; 0x2b
  401e78:	e7f0      	b.n	401e5c <cbvprintf+0x640>
		switch (conv->specifier) {
  401e7a:	2600      	movs	r6, #0
  401e7c:	e752      	b.n	401d24 <cbvprintf+0x508>
			if (value->ptr != NULL) {
  401e7e:	980a      	ldr	r0, [sp, #40]	; 0x28
  401e80:	b340      	cbz	r0, 401ed4 <cbvprintf+0x6b8>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  401e82:	f10d 0326 	add.w	r3, sp, #38	; 0x26
  401e86:	aa0c      	add	r2, sp, #48	; 0x30
  401e88:	2100      	movs	r1, #0
		char sign = 0;
  401e8a:	2600      	movs	r6, #0
				bps = encode_uint((uintptr_t)value->ptr, conv,
  401e8c:	9300      	str	r3, [sp, #0]
  401e8e:	ab04      	add	r3, sp, #16
  401e90:	f003 ffef 	bl	405e72 <encode_uint>
				conv->altform_0c = true;
  401e94:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
  401e98:	4682      	mov	sl, r0
				conv->altform_0c = true;
  401e9a:	f003 03ef 	and.w	r3, r3, #239	; 0xef
  401e9e:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
  401ea2:	f043 0310 	orr.w	r3, r3, #16
  401ea6:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
  401eaa:	e745      	b.n	401d38 <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
  401eac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
  401eae:	2907      	cmp	r1, #7
  401eb0:	f63f aee0 	bhi.w	401c74 <cbvprintf+0x458>
  401eb4:	e8df f001 	tbb	[pc, r1]
  401eb8:	0c06040c 	.word	0x0c06040c
  401ebc:	0c0c0808 	.word	0x0c0c0808
		*(signed char *)dp = (signed char)count;
  401ec0:	701d      	strb	r5, [r3, #0]
		break;
  401ec2:	e6d7      	b.n	401c74 <cbvprintf+0x458>
		*(short *)dp = (short)count;
  401ec4:	801d      	strh	r5, [r3, #0]
		break;
  401ec6:	e6d5      	b.n	401c74 <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
  401ec8:	17ea      	asrs	r2, r5, #31
  401eca:	e9c3 5200 	strd	r5, r2, [r3]
		break;
  401ece:	e6d1      	b.n	401c74 <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  401ed0:	601d      	str	r5, [r3, #0]
		break;
  401ed2:	e6cf      	b.n	401c74 <cbvprintf+0x458>
			bps = "(nil)";
  401ed4:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 401f9c <cbvprintf+0x780>
  401ed8:	4606      	mov	r6, r0
			bpe = bps + 5;
  401eda:	f10a 0805 	add.w	r8, sl, #5
  401ede:	e78d      	b.n	401dfc <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
  401ee0:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
  401ee2:	bf48      	it	mi
  401ee4:	3301      	addmi	r3, #1
  401ee6:	e792      	b.n	401e0e <cbvprintf+0x5f2>
					OUTC(pad);
  401ee8:	4618      	mov	r0, r3
  401eea:	9303      	str	r3, [sp, #12]
  401eec:	4659      	mov	r1, fp
  401eee:	9b02      	ldr	r3, [sp, #8]
  401ef0:	4798      	blx	r3
  401ef2:	2800      	cmp	r0, #0
  401ef4:	9b03      	ldr	r3, [sp, #12]
  401ef6:	da04      	bge.n	401f02 <cbvprintf+0x6e6>
#undef OUTS
#undef OUTC
}
  401ef8:	b011      	add	sp, #68	; 0x44
  401efa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
  401efe:	2320      	movs	r3, #32
  401f00:	444d      	add	r5, r9
  401f02:	464a      	mov	r2, r9
  401f04:	eba5 0109 	sub.w	r1, r5, r9
				while (width-- > 0) {
  401f08:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
  401f0c:	2a00      	cmp	r2, #0
  401f0e:	dceb      	bgt.n	401ee8 <cbvprintf+0x6cc>
  401f10:	460d      	mov	r5, r1
		if (sign != 0) {
  401f12:	b136      	cbz	r6, 401f22 <cbvprintf+0x706>
			OUTC(sign);
  401f14:	4659      	mov	r1, fp
  401f16:	4630      	mov	r0, r6
  401f18:	9b02      	ldr	r3, [sp, #8]
  401f1a:	4798      	blx	r3
  401f1c:	2800      	cmp	r0, #0
  401f1e:	dbeb      	blt.n	401ef8 <cbvprintf+0x6dc>
  401f20:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
  401f22:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
  401f26:	06d9      	lsls	r1, r3, #27
  401f28:	d401      	bmi.n	401f2e <cbvprintf+0x712>
  401f2a:	071a      	lsls	r2, r3, #28
  401f2c:	d506      	bpl.n	401f3c <cbvprintf+0x720>
				OUTC('0');
  401f2e:	4659      	mov	r1, fp
  401f30:	2030      	movs	r0, #48	; 0x30
  401f32:	9b02      	ldr	r3, [sp, #8]
  401f34:	4798      	blx	r3
  401f36:	2800      	cmp	r0, #0
  401f38:	dbde      	blt.n	401ef8 <cbvprintf+0x6dc>
  401f3a:	3501      	adds	r5, #1
			if (conv->altform_0c) {
  401f3c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
  401f40:	06db      	lsls	r3, r3, #27
  401f42:	d507      	bpl.n	401f54 <cbvprintf+0x738>
				OUTC(conv->specifier);
  401f44:	4659      	mov	r1, fp
  401f46:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
  401f4a:	9b02      	ldr	r3, [sp, #8]
  401f4c:	4798      	blx	r3
  401f4e:	2800      	cmp	r0, #0
  401f50:	dbd2      	blt.n	401ef8 <cbvprintf+0x6dc>
  401f52:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
  401f54:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  401f56:	442e      	add	r6, r5
  401f58:	1b73      	subs	r3, r6, r5
  401f5a:	2b00      	cmp	r3, #0
  401f5c:	dc16      	bgt.n	401f8c <cbvprintf+0x770>
			OUTS(bps, bpe);
  401f5e:	4643      	mov	r3, r8
  401f60:	4652      	mov	r2, sl
  401f62:	4659      	mov	r1, fp
  401f64:	9802      	ldr	r0, [sp, #8]
  401f66:	f003 ffca 	bl	405efe <outs>
  401f6a:	2800      	cmp	r0, #0
  401f6c:	dbc4      	blt.n	401ef8 <cbvprintf+0x6dc>
  401f6e:	4405      	add	r5, r0
		while (width > 0) {
  401f70:	44a9      	add	r9, r5
  401f72:	eba9 0305 	sub.w	r3, r9, r5
  401f76:	2b00      	cmp	r3, #0
  401f78:	f77f ae7c 	ble.w	401c74 <cbvprintf+0x458>
			OUTC(' ');
  401f7c:	4659      	mov	r1, fp
  401f7e:	2020      	movs	r0, #32
  401f80:	9b02      	ldr	r3, [sp, #8]
  401f82:	4798      	blx	r3
  401f84:	2800      	cmp	r0, #0
  401f86:	dbb7      	blt.n	401ef8 <cbvprintf+0x6dc>
  401f88:	3501      	adds	r5, #1
			--width;
  401f8a:	e7f2      	b.n	401f72 <cbvprintf+0x756>
				OUTC('0');
  401f8c:	4659      	mov	r1, fp
  401f8e:	2030      	movs	r0, #48	; 0x30
  401f90:	9b02      	ldr	r3, [sp, #8]
  401f92:	4798      	blx	r3
  401f94:	2800      	cmp	r0, #0
  401f96:	dbaf      	blt.n	401ef8 <cbvprintf+0x6dc>
  401f98:	3501      	adds	r5, #1
  401f9a:	e7dd      	b.n	401f58 <cbvprintf+0x73c>
  401f9c:	004075b5 	.word	0x004075b5

00401fa0 <atmel_same70_init>:
 * So the init priority has to be 0 (zero).
 *
 * @return 0
 */
static int atmel_same70_init(const struct device *arg)
{
  401fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
  401fa2:	b083      	sub	sp, #12
  401fa4:	af00      	add	r7, sp, #0
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
  401fa6:	f04f 0320 	mov.w	r3, #32
  401faa:	f3ef 8111 	mrs	r1, BASEPRI
  401fae:	f383 8812 	msr	BASEPRI_MAX, r3
  401fb2:	f3bf 8f6f 	isb	sy
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
  401fb6:	4b50      	ldr	r3, [pc, #320]	; (4020f8 <atmel_same70_init+0x158>)
  401fb8:	695a      	ldr	r2, [r3, #20]
  401fba:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
  401fbe:	d111      	bne.n	401fe4 <atmel_same70_init+0x44>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  401fc0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401fc4:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  401fc8:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  401fcc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401fd0:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  401fd4:	695a      	ldr	r2, [r3, #20]
  401fd6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  401fda:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  401fdc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401fe0:	f3bf 8f6f 	isb	sy

	key = irq_lock();

	SCB_EnableICache();

	if (!(SCB->CCR & SCB_CCR_DC_Msk)) {
  401fe4:	4a44      	ldr	r2, [pc, #272]	; (4020f8 <atmel_same70_init+0x158>)
  401fe6:	6953      	ldr	r3, [r2, #20]
  401fe8:	03dd      	lsls	r5, r3, #15
  401fea:	d427      	bmi.n	40203c <atmel_same70_init+0x9c>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
  401fec:	6953      	ldr	r3, [r2, #20]
  401fee:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
  401ff2:	d123      	bne.n	40203c <atmel_same70_init+0x9c>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
  401ff4:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  401ff8:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  401ffc:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  402000:	f643 75e0 	movw	r5, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  402004:	f3c3 04c9 	ubfx	r4, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  402008:	f3c3 334e 	ubfx	r3, r3, #13, #15
  40200c:	015b      	lsls	r3, r3, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  40200e:	ea03 0c05 	and.w	ip, r3, r5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  402012:	4620      	mov	r0, r4
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  402014:	ea4c 7680 	orr.w	r6, ip, r0, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  402018:	3801      	subs	r0, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  40201a:	f8c2 6260 	str.w	r6, [r2, #608]	; 0x260
      } while (ways-- != 0U);
  40201e:	d2f9      	bcs.n	402014 <atmel_same70_init+0x74>
    } while(sets-- != 0U);
  402020:	3b20      	subs	r3, #32
  402022:	f113 0f20 	cmn.w	r3, #32
  402026:	d1f2      	bne.n	40200e <atmel_same70_init+0x6e>
  402028:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  40202c:	6953      	ldr	r3, [r2, #20]
  40202e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  402032:	6153      	str	r3, [r2, #20]
  402034:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  402038:	f3bf 8f6f 	isb	sy
	 * Set FWS (Flash Wait State) value before increasing Master Clock
	 * (MCK) frequency.
	 * TODO: set FWS based on the actual MCK frequency and VDDIO value
	 * rather than maximum supported 150 MHz at standard VDDIO=2.7V
	 */
	EFC->EEFC_FMR = EEFC_FMR_FWS(5) | EEFC_FMR_CLOE;
  40203c:	4b2f      	ldr	r3, [pc, #188]	; (4020fc <atmel_same70_init+0x15c>)
  40203e:	4a30      	ldr	r2, [pc, #192]	; (402100 <atmel_same70_init+0x160>)
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS)) {
  402040:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
	EFC->EEFC_FMR = EEFC_FMR_FWS(5) | EEFC_FMR_CLOE;
  402044:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS)) {
  402048:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  40204a:	0394      	lsls	r4, r2, #14
  40204c:	d5fc      	bpl.n	402048 <atmel_same70_init+0xa8>
	PMC->CKGR_MOR =   CKGR_MOR_KEY_PASSWD
  40204e:	4a2d      	ldr	r2, [pc, #180]	; (402104 <atmel_same70_init+0x164>)
  402050:	621a      	str	r2, [r3, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS)) {
  402052:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  402054:	0390      	lsls	r0, r2, #14
  402056:	d5fc      	bpl.n	402052 <atmel_same70_init+0xb2>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk;
  402058:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40205a:	f022 0203 	bic.w	r2, r2, #3
	PMC->PMC_MCKR = reg_val | PMC_MCKR_CSS_MAIN_CLK;
  40205e:	f042 0201 	orr.w	r2, r2, #1
  402062:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
  402064:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  402066:	0712      	lsls	r2, r2, #28
  402068:	d5fc      	bpl.n	402064 <atmel_same70_init+0xc4>
	PMC->CKGR_PLLAR =   CKGR_PLLAR_ONE
  40206a:	4a27      	ldr	r2, [pc, #156]	; (402108 <atmel_same70_init+0x168>)
  40206c:	629a      	str	r2, [r3, #40]	; 0x28
	while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
  40206e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  402070:	0796      	lsls	r6, r2, #30
  402072:	d5fc      	bpl.n	40206e <atmel_same70_init+0xce>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_PRES_Msk;
  402074:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402076:	f022 0270 	bic.w	r2, r2, #112	; 0x70
	PMC->PMC_MCKR = reg_val | PMC_MCKR_PRES_CLK_1;
  40207a:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
  40207c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  40207e:	0715      	lsls	r5, r2, #28
  402080:	d5fc      	bpl.n	40207c <atmel_same70_init+0xdc>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_MDIV_Msk;
  402082:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402084:	f422 7240 	bic.w	r2, r2, #768	; 0x300
	PMC->PMC_MCKR = reg_val | SOC_ATMEL_SAME70_MDIV;
  402088:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  40208c:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
  40208e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  402090:	0714      	lsls	r4, r2, #28
  402092:	d5fc      	bpl.n	40208e <atmel_same70_init+0xee>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk;
  402094:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402096:	f022 0203 	bic.w	r2, r2, #3
	PMC->PMC_MCKR = reg_val | PMC_MCKR_CSS_PLLA_CLK;
  40209a:	f042 0202 	orr.w	r2, r2, #2
  40209e:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
  4020a0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  4020a2:	0710      	lsls	r0, r2, #28
  4020a4:	d5fc      	bpl.n	4020a0 <atmel_same70_init+0x100>
	PMC->CKGR_UCKR |= CKGR_UCKR_UPLLEN;
  4020a6:	69da      	ldr	r2, [r3, #28]
  4020a8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  4020ac:	61da      	str	r2, [r3, #28]
	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
  4020ae:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  4020b0:	0652      	lsls	r2, r2, #25
  4020b2:	d5fc      	bpl.n	4020ae <atmel_same70_init+0x10e>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
  4020b4:	f381 8811 	msr	BASEPRI, r1
  4020b8:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	/* Check that the CHIP CIDR matches the HAL one */
	if (CHIPID->CHIPID_CIDR != CHIP_CIDR) {
  4020bc:	4b13      	ldr	r3, [pc, #76]	; (40210c <atmel_same70_init+0x16c>)
  4020be:	4914      	ldr	r1, [pc, #80]	; (402110 <atmel_same70_init+0x170>)
  4020c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  4020c2:	428a      	cmp	r2, r1
  4020c4:	d014      	beq.n	4020f0 <atmel_same70_init+0x150>
		LOG_WRN("CIDR mismatch: chip = 0x%08x vs HAL = 0x%08x",
  4020c6:	466c      	mov	r4, sp
  4020c8:	b088      	sub	sp, #32
  4020ca:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  4020cc:	4811      	ldr	r0, [pc, #68]	; (402114 <atmel_same70_init+0x174>)
  4020ce:	466a      	mov	r2, sp
  4020d0:	6110      	str	r0, [r2, #16]
  4020d2:	6c18      	ldr	r0, [r3, #64]	; 0x40
  4020d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4020d6:	e9c2 3105 	strd	r3, r1, [r2, #20]
  4020da:	2304      	movs	r3, #4
  4020dc:	607b      	str	r3, [r7, #4]
  4020de:	f842 3f0c 	str.w	r3, [r2, #12]!
		arch_syscall_invoke4(*(uintptr_t *)&source, *(uintptr_t *)&desc, *(uintptr_t *)&package, *(uintptr_t *)&data, K_SYSCALL_Z_LOG_MSG2_STATIC_CREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg2_static_create(source, desc, package, data);
  4020e2:	2300      	movs	r3, #0
  4020e4:	f44f 5102 	mov.w	r1, #8320	; 0x2080
  4020e8:	480b      	ldr	r0, [pc, #44]	; (402118 <atmel_same70_init+0x178>)
  4020ea:	f004 f9f6 	bl	4064da <z_impl_z_log_msg2_static_create>
  4020ee:	46a5      	mov	sp, r4
			(uint32_t)CHIPID->CHIPID_CIDR, (uint32_t)CHIP_CIDR);
	}

	return 0;
}
  4020f0:	2000      	movs	r0, #0
  4020f2:	370c      	adds	r7, #12
  4020f4:	46bd      	mov	sp, r7
  4020f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4020f8:	e000ed00 	.word	0xe000ed00
  4020fc:	400e0c00 	.word	0x400e0c00
  402100:	04000500 	.word	0x04000500
  402104:	00370028 	.word	0x00370028
  402108:	20183f01 	.word	0x20183f01
  40210c:	400e0900 	.word	0x400e0900
  402110:	a10d0a00 	.word	0xa10d0a00
  402114:	004075bb 	.word	0x004075bb
  402118:	004072a8 	.word	0x004072a8

0040211c <atmel_same70_config>:
	 * IEEE1149.1 JTAG Boundary scan only. It can not be used as a debug
	 * interface therefore there is no harm done by disabling the JTAG TDI
	 * pin by default.
	 */
	/* Disable TDI function on PB4 pin, this is controlled by Bus Matrix */
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO4;
  40211c:	4b07      	ldr	r3, [pc, #28]	; (40213c <atmel_same70_config+0x20>)
	/* Disable TDO/TRACESWO function on PB5 pin */
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO5;
#endif

	return 0;
}
  40211e:	2000      	movs	r0, #0
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO4;
  402120:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  402124:	f042 0210 	orr.w	r2, r2, #16
  402128:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO5;
  40212c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  402130:	f042 0220 	orr.w	r2, r2, #32
  402134:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
  402138:	4770      	bx	lr
  40213a:	bf00      	nop
  40213c:	40088000 	.word	0x40088000

00402140 <soc_pmc_peripheral_enable>:

void soc_pmc_peripheral_enable(uint32_t id)
{
	__ASSERT(id < ID_PERIPH_COUNT, "Invalid peripheral id");

	if (id < 32) {
  402140:	281f      	cmp	r0, #31
  402142:	d805      	bhi.n	402150 <soc_pmc_peripheral_enable+0x10>
		PMC->PMC_PCER0 = BIT(id);
  402144:	2301      	movs	r3, #1
  402146:	fa03 f000 	lsl.w	r0, r3, r0
  40214a:	4b07      	ldr	r3, [pc, #28]	; (402168 <soc_pmc_peripheral_enable+0x28>)
  40214c:	6118      	str	r0, [r3, #16]
  40214e:	4770      	bx	lr
#if ID_PERIPH_COUNT > 32
	} else if (id < 64) {
  402150:	283f      	cmp	r0, #63	; 0x3f
  402152:	d807      	bhi.n	402164 <soc_pmc_peripheral_enable+0x24>
		PMC->PMC_PCER1 = BIT(id & 0x1F);
  402154:	2301      	movs	r3, #1
  402156:	f000 001f 	and.w	r0, r0, #31
  40215a:	fa03 f000 	lsl.w	r0, r3, r0
  40215e:	4b02      	ldr	r3, [pc, #8]	; (402168 <soc_pmc_peripheral_enable+0x28>)
  402160:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
#if ID_PERIPH_COUNT > 64
	} else {
		/* Nothing to do, thes peripherals can't be enabled */
#endif
	}
}
  402164:	4770      	bx	lr
  402166:	bf00      	nop
  402168:	400e0600 	.word	0x400e0600

0040216c <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
  40216c:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
  40216e:	2200      	movs	r2, #0
{
  402170:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
  402172:	490f      	ldr	r1, [pc, #60]	; (4021b0 <enable_logger+0x44>)
  402174:	480f      	ldr	r0, [pc, #60]	; (4021b4 <enable_logger+0x48>)
  402176:	f004 fe75 	bl	406e64 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40217a:	2200      	movs	r2, #0
  40217c:	2300      	movs	r3, #0
  40217e:	2400      	movs	r4, #0
  402180:	4d0d      	ldr	r5, [pc, #52]	; (4021b8 <enable_logger+0x4c>)
  402182:	490e      	ldr	r1, [pc, #56]	; (4021bc <enable_logger+0x50>)
  402184:	4628      	mov	r0, r5
  402186:	9400      	str	r4, [sp, #0]
  402188:	e9cd 2306 	strd	r2, r3, [sp, #24]
  40218c:	230e      	movs	r3, #14
  40218e:	f44f 7240 	mov.w	r2, #768	; 0x300
  402192:	e9cd 3403 	strd	r3, r4, [sp, #12]
  402196:	e9cd 4401 	strd	r4, r4, [sp, #4]
  40219a:	4b09      	ldr	r3, [pc, #36]	; (4021c0 <enable_logger+0x54>)
  40219c:	f002 fd70 	bl	404c80 <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
  4021a0:	4908      	ldr	r1, [pc, #32]	; (4021c4 <enable_logger+0x58>)
  4021a2:	4628      	mov	r0, r5
  4021a4:	f004 fd0b 	bl	406bbe <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
  4021a8:	4620      	mov	r0, r4
  4021aa:	b009      	add	sp, #36	; 0x24
  4021ac:	bd30      	pop	{r4, r5, pc}
  4021ae:	bf00      	nop
  4021b0:	004021c9 	.word	0x004021c9
  4021b4:	20400450 	.word	0x20400450
  4021b8:	20400488 	.word	0x20400488
  4021bc:	20400c20 	.word	0x20400c20
  4021c0:	004023e1 	.word	0x004023e1
  4021c4:	004075ec 	.word	0x004075ec

004021c8 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  4021c8:	4801      	ldr	r0, [pc, #4]	; (4021d0 <log_process_thread_timer_expiry_fn+0x8>)
  4021ca:	f002 be89 	b.w	404ee0 <z_impl_k_sem_give>
  4021ce:	bf00      	nop
  4021d0:	20400040 	.word	0x20400040

004021d4 <log_init>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  4021d4:	4b12      	ldr	r3, [pc, #72]	; (402220 <log_init+0x4c>)
{
  4021d6:	b570      	push	{r4, r5, r6, lr}
  4021d8:	f3bf 8f5b 	dmb	ish
  4021dc:	e853 5f00 	ldrex	r5, [r3]
  4021e0:	1c6a      	adds	r2, r5, #1
  4021e2:	e843 2100 	strex	r1, r2, [r3]
  4021e6:	2900      	cmp	r1, #0
  4021e8:	d1f8      	bne.n	4021dc <log_init+0x8>
  4021ea:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
  4021ee:	b92d      	cbnz	r5, 4021fc <log_init+0x28>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
  4021f0:	4c0c      	ldr	r4, [pc, #48]	; (402224 <log_init+0x50>)
  4021f2:	4e0d      	ldr	r6, [pc, #52]	; (402228 <log_init+0x54>)
  4021f4:	1b36      	subs	r6, r6, r4
  4021f6:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
  4021f8:	42b5      	cmp	r5, r6
  4021fa:	db00      	blt.n	4021fe <log_init+0x2a>
}
  4021fc:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
  4021fe:	7b23      	ldrb	r3, [r4, #12]
  402200:	b153      	cbz	r3, 402218 <log_init+0x44>
			if (backend->api->init != NULL) {
  402202:	6823      	ldr	r3, [r4, #0]
  402204:	699b      	ldr	r3, [r3, #24]
  402206:	b10b      	cbz	r3, 40220c <log_init+0x38>
				backend->api->init(backend);
  402208:	4620      	mov	r0, r4
  40220a:	4798      	blx	r3
			log_backend_enable(backend,
  40220c:	6863      	ldr	r3, [r4, #4]
  40220e:	2204      	movs	r2, #4
  402210:	4620      	mov	r0, r4
  402212:	6819      	ldr	r1, [r3, #0]
  402214:	f000 f992 	bl	40253c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
  402218:	3501      	adds	r5, #1
  40221a:	3410      	adds	r4, #16
  40221c:	e7ec      	b.n	4021f8 <log_init+0x24>
  40221e:	bf00      	nop
  402220:	204006b8 	.word	0x204006b8
  402224:	004072b8 	.word	0x004072b8
  402228:	004072c8 	.word	0x004072c8

0040222c <z_log_notify_backend_enabled>:
{
  40222c:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
  40222e:	4c04      	ldr	r4, [pc, #16]	; (402240 <z_log_notify_backend_enabled+0x14>)
  402230:	7823      	ldrb	r3, [r4, #0]
  402232:	b913      	cbnz	r3, 40223a <z_log_notify_backend_enabled+0xe>
  402234:	4803      	ldr	r0, [pc, #12]	; (402244 <z_log_notify_backend_enabled+0x18>)
  402236:	f002 fe53 	bl	404ee0 <z_impl_k_sem_give>
	backend_attached = true;
  40223a:	2301      	movs	r3, #1
  40223c:	7023      	strb	r3, [r4, #0]
}
  40223e:	bd10      	pop	{r4, pc}
  402240:	20400c10 	.word	0x20400c10
  402244:	20400040 	.word	0x20400040

00402248 <z_log_dropped>:
  402248:	4b0c      	ldr	r3, [pc, #48]	; (40227c <z_log_dropped+0x34>)
  40224a:	f3bf 8f5b 	dmb	ish
  40224e:	e853 2f00 	ldrex	r2, [r3]
  402252:	3201      	adds	r2, #1
  402254:	e843 2100 	strex	r1, r2, [r3]
  402258:	2900      	cmp	r1, #0
  40225a:	d1f8      	bne.n	40224e <z_log_dropped+0x6>
  40225c:	f3bf 8f5b 	dmb	ish
	if (buffered) {
  402260:	b158      	cbz	r0, 40227a <z_log_dropped+0x32>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  402262:	4b07      	ldr	r3, [pc, #28]	; (402280 <z_log_dropped+0x38>)
  402264:	f3bf 8f5b 	dmb	ish
  402268:	e853 2f00 	ldrex	r2, [r3]
  40226c:	3a01      	subs	r2, #1
  40226e:	e843 2100 	strex	r1, r2, [r3]
  402272:	2900      	cmp	r1, #0
  402274:	d1f8      	bne.n	402268 <z_log_dropped+0x20>
  402276:	f3bf 8f5b 	dmb	ish
}
  40227a:	4770      	bx	lr
  40227c:	204006b4 	.word	0x204006b4
  402280:	204006b0 	.word	0x204006b0

00402284 <z_log_dropped_read_and_clear>:
}
  402284:	2000      	movs	r0, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  402286:	4b06      	ldr	r3, [pc, #24]	; (4022a0 <z_log_dropped_read_and_clear+0x1c>)
  402288:	f3bf 8f5b 	dmb	ish
  40228c:	4602      	mov	r2, r0
  40228e:	e853 0f00 	ldrex	r0, [r3]
  402292:	e843 2100 	strex	r1, r2, [r3]
  402296:	2900      	cmp	r1, #0
  402298:	d1f9      	bne.n	40228e <z_log_dropped_read_and_clear+0xa>
  40229a:	f3bf 8f5b 	dmb	ish
  40229e:	4770      	bx	lr
  4022a0:	204006b4 	.word	0x204006b4

004022a4 <dropped_notify>:
{
  4022a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4022a6:	4c0b      	ldr	r4, [pc, #44]	; (4022d4 <dropped_notify+0x30>)
	uint32_t dropped = z_log_dropped_read_and_clear();
  4022a8:	f7ff ffec 	bl	402284 <z_log_dropped_read_and_clear>
  4022ac:	4d0a      	ldr	r5, [pc, #40]	; (4022d8 <dropped_notify+0x34>)
  4022ae:	4607      	mov	r7, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
  4022b0:	2600      	movs	r6, #0
  4022b2:	1b2d      	subs	r5, r5, r4
  4022b4:	112d      	asrs	r5, r5, #4
  4022b6:	42ae      	cmp	r6, r5
  4022b8:	db00      	blt.n	4022bc <dropped_notify+0x18>
}
  4022ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  4022bc:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
  4022be:	795b      	ldrb	r3, [r3, #5]
  4022c0:	b12b      	cbz	r3, 4022ce <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
  4022c2:	6823      	ldr	r3, [r4, #0]
  4022c4:	691b      	ldr	r3, [r3, #16]
  4022c6:	b113      	cbz	r3, 4022ce <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
  4022c8:	4639      	mov	r1, r7
  4022ca:	4620      	mov	r0, r4
  4022cc:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
  4022ce:	3601      	adds	r6, #1
  4022d0:	3410      	adds	r4, #16
  4022d2:	e7f0      	b.n	4022b6 <dropped_notify+0x12>
  4022d4:	004072b8 	.word	0x004072b8
  4022d8:	004072c8 	.word	0x004072c8

004022dc <z_log_msg2_init>:
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
  4022dc:	4901      	ldr	r1, [pc, #4]	; (4022e4 <z_log_msg2_init+0x8>)
  4022de:	4802      	ldr	r0, [pc, #8]	; (4022e8 <z_log_msg2_init+0xc>)
  4022e0:	f003 beb6 	b.w	406050 <mpsc_pbuf_init>
  4022e4:	0040730c 	.word	0x0040730c
  4022e8:	204006bc 	.word	0x204006bc

004022ec <log_core_init>:
{
  4022ec:	b508      	push	{r3, lr}
	panic_mode = false;
  4022ee:	4a08      	ldr	r2, [pc, #32]	; (402310 <log_core_init+0x24>)
  4022f0:	2300      	movs	r3, #0
	log_output_timestamp_freq_set(freq);
  4022f2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	panic_mode = false;
  4022f6:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
  4022f8:	4a06      	ldr	r2, [pc, #24]	; (402314 <log_core_init+0x28>)
  4022fa:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
  4022fc:	4b06      	ldr	r3, [pc, #24]	; (402318 <log_core_init+0x2c>)
  4022fe:	4a07      	ldr	r2, [pc, #28]	; (40231c <log_core_init+0x30>)
  402300:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
  402302:	f000 faf7 	bl	4028f4 <log_output_timestamp_freq_set>
}
  402306:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		z_log_msg2_init();
  40230a:	f7ff bfe7 	b.w	4022dc <z_log_msg2_init>
  40230e:	bf00      	nop
  402310:	20400c11 	.word	0x20400c11
  402314:	204006b4 	.word	0x204006b4
  402318:	20400008 	.word	0x20400008
  40231c:	004063fb 	.word	0x004063fb

00402320 <z_log_msg2_alloc>:
{
  402320:	4601      	mov	r1, r0
	return (struct log_msg2 *)mpsc_pbuf_alloc(&log_buffer, wlen,
  402322:	2200      	movs	r2, #0
  402324:	2300      	movs	r3, #0
  402326:	4801      	ldr	r0, [pc, #4]	; (40232c <z_log_msg2_alloc+0xc>)
  402328:	f003 beb1 	b.w	40608e <mpsc_pbuf_alloc>
  40232c:	204006bc 	.word	0x204006bc

00402330 <z_log_msg2_claim>:
	return (union log_msg2_generic *)mpsc_pbuf_claim(&log_buffer);
  402330:	4801      	ldr	r0, [pc, #4]	; (402338 <z_log_msg2_claim+0x8>)
  402332:	f003 bf3f 	b.w	4061b4 <mpsc_pbuf_claim>
  402336:	bf00      	nop
  402338:	204006bc 	.word	0x204006bc

0040233c <z_log_msg2_free>:
{
  40233c:	4601      	mov	r1, r0
	mpsc_pbuf_free(&log_buffer, (union mpsc_pbuf_generic *)msg);
  40233e:	4801      	ldr	r0, [pc, #4]	; (402344 <z_log_msg2_free+0x8>)
  402340:	f003 bf84 	b.w	40624c <mpsc_pbuf_free>
  402344:	204006bc 	.word	0x204006bc

00402348 <z_log_msg2_pending>:
	return mpsc_pbuf_is_pending(&log_buffer);
  402348:	4801      	ldr	r0, [pc, #4]	; (402350 <z_log_msg2_pending+0x8>)
  40234a:	f003 bfb3 	b.w	4062b4 <mpsc_pbuf_is_pending>
  40234e:	bf00      	nop
  402350:	204006bc 	.word	0x204006bc

00402354 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
  402354:	4b1d      	ldr	r3, [pc, #116]	; (4023cc <z_impl_log_process+0x78>)
  402356:	781b      	ldrb	r3, [r3, #0]
{
  402358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40235c:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
  40235e:	b903      	cbnz	r3, 402362 <z_impl_log_process+0xe>
  402360:	b388      	cbz	r0, 4023c6 <z_impl_log_process+0x72>
	msg = get_msg();
  402362:	f004 f857 	bl	406414 <get_msg>
	if (msg.msg) {
  402366:	4606      	mov	r6, r0
  402368:	b118      	cbz	r0, 402372 <z_impl_log_process+0x1e>
		if (!bypass) {
  40236a:	b16d      	cbz	r5, 402388 <z_impl_log_process+0x34>
		z_log_msg2_free(msg.msg2);
  40236c:	4630      	mov	r0, r6
  40236e:	f7ff ffe5 	bl	40233c <z_log_msg2_free>
	if (!bypass && z_log_dropped_pending()) {
  402372:	b92d      	cbnz	r5, 402380 <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
  402374:	4b16      	ldr	r3, [pc, #88]	; (4023d0 <z_impl_log_process+0x7c>)
	if (!bypass && z_log_dropped_pending()) {
  402376:	681b      	ldr	r3, [r3, #0]
  402378:	2b00      	cmp	r3, #0
  40237a:	dd01      	ble.n	402380 <z_impl_log_process+0x2c>
		dropped_notify();
  40237c:	f7ff ff92 	bl	4022a4 <dropped_notify>
}
  402380:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_log_msg2_pending();
  402384:	f7ff bfe0 	b.w	402348 <z_log_msg2_pending>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  402388:	4b12      	ldr	r3, [pc, #72]	; (4023d4 <z_impl_log_process+0x80>)
  40238a:	f3bf 8f5b 	dmb	ish
  40238e:	e853 2f00 	ldrex	r2, [r3]
  402392:	3a01      	subs	r2, #1
  402394:	e843 2100 	strex	r1, r2, [r3]
  402398:	2900      	cmp	r1, #0
  40239a:	d1f8      	bne.n	40238e <z_impl_log_process+0x3a>
	return __log_backends_end - __log_backends_start;
  40239c:	4c0e      	ldr	r4, [pc, #56]	; (4023d8 <z_impl_log_process+0x84>)
  40239e:	46a8      	mov	r8, r5
  4023a0:	4f0e      	ldr	r7, [pc, #56]	; (4023dc <z_impl_log_process+0x88>)
  4023a2:	f3bf 8f5b 	dmb	ish
  4023a6:	1b3f      	subs	r7, r7, r4
  4023a8:	113f      	asrs	r7, r7, #4
		for (int i = 0; i < log_backend_count_get(); i++) {
  4023aa:	45b8      	cmp	r8, r7
  4023ac:	dade      	bge.n	40236c <z_impl_log_process+0x18>
	return backend->cb->active;
  4023ae:	6863      	ldr	r3, [r4, #4]
			if (log_backend_is_active(backend) &&
  4023b0:	795b      	ldrb	r3, [r3, #5]
  4023b2:	b123      	cbz	r3, 4023be <z_impl_log_process+0x6a>
	backend->api->process(backend, msg);
  4023b4:	6823      	ldr	r3, [r4, #0]
  4023b6:	4631      	mov	r1, r6
  4023b8:	4620      	mov	r0, r4
  4023ba:	681b      	ldr	r3, [r3, #0]
  4023bc:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
  4023be:	f108 0801 	add.w	r8, r8, #1
  4023c2:	3410      	adds	r4, #16
  4023c4:	e7f1      	b.n	4023aa <z_impl_log_process+0x56>
}
  4023c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4023ca:	bf00      	nop
  4023cc:	20400c10 	.word	0x20400c10
  4023d0:	204006b4 	.word	0x204006b4
  4023d4:	204006b0 	.word	0x204006b0
  4023d8:	004072b8 	.word	0x004072b8
  4023dc:	004072c8 	.word	0x004072c8

004023e0 <log_process_thread_func>:
{
  4023e0:	b510      	push	{r4, lr}
	log_init();
  4023e2:	f7ff fef7 	bl	4021d4 <log_init>
	return z_impl_z_current_get();
  4023e6:	f003 f977 	bl	4056d8 <z_impl_z_current_get>
	proc_tid = process_tid;
  4023ea:	4b0c      	ldr	r3, [pc, #48]	; (40241c <log_process_thread_func+0x3c>)
  4023ec:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
  4023ee:	b130      	cbz	r0, 4023fe <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
  4023f0:	4b0b      	ldr	r3, [pc, #44]	; (402420 <log_process_thread_func+0x40>)
	    process_tid &&
  4023f2:	681b      	ldr	r3, [r3, #0]
  4023f4:	2b09      	cmp	r3, #9
  4023f6:	dd02      	ble.n	4023fe <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
  4023f8:	480a      	ldr	r0, [pc, #40]	; (402424 <log_process_thread_func+0x44>)
  4023fa:	f002 fd71 	bl	404ee0 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
  4023fe:	4c09      	ldr	r4, [pc, #36]	; (402424 <log_process_thread_func+0x44>)
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
  402400:	2000      	movs	r0, #0
  402402:	f7ff ffa7 	bl	402354 <z_impl_log_process>
		if (log_process(false) == false) {
  402406:	2800      	cmp	r0, #0
  402408:	d1fa      	bne.n	402400 <log_process_thread_func+0x20>
  40240a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  40240e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  402412:	4620      	mov	r0, r4
  402414:	f002 fd84 	bl	404f20 <z_impl_k_sem_take>
  402418:	e7f2      	b.n	402400 <log_process_thread_func+0x20>
  40241a:	bf00      	nop
  40241c:	204006f0 	.word	0x204006f0
  402420:	204006b0 	.word	0x204006b0
  402424:	20400040 	.word	0x20400040

00402428 <z_log_msg_post_finalize>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  402428:	4b1d      	ldr	r3, [pc, #116]	; (4024a0 <z_log_msg_post_finalize+0x78>)
{
  40242a:	b513      	push	{r0, r1, r4, lr}
  40242c:	f3bf 8f5b 	dmb	ish
  402430:	e853 2f00 	ldrex	r2, [r3]
  402434:	1c51      	adds	r1, r2, #1
  402436:	e843 1000 	strex	r0, r1, [r3]
  40243a:	2800      	cmp	r0, #0
  40243c:	d1f8      	bne.n	402430 <z_log_msg_post_finalize+0x8>
	if (panic_mode) {
  40243e:	4b19      	ldr	r3, [pc, #100]	; (4024a4 <z_log_msg_post_finalize+0x7c>)
  402440:	f3bf 8f5b 	dmb	ish
  402444:	781b      	ldrb	r3, [r3, #0]
  402446:	b183      	cbz	r3, 40246a <z_log_msg_post_finalize+0x42>
	__asm__ volatile(
  402448:	f04f 0320 	mov.w	r3, #32
  40244c:	f3ef 8411 	mrs	r4, BASEPRI
  402450:	f383 8812 	msr	BASEPRI_MAX, r3
  402454:	f3bf 8f6f 	isb	sy
  402458:	2000      	movs	r0, #0
  40245a:	f7ff ff7b 	bl	402354 <z_impl_log_process>
	__asm__ volatile(
  40245e:	f384 8811 	msr	BASEPRI, r4
  402462:	f3bf 8f6f 	isb	sy
}
  402466:	b002      	add	sp, #8
  402468:	bd10      	pop	{r4, pc}
	} else if (proc_tid != NULL && cnt == 0) {
  40246a:	4b0f      	ldr	r3, [pc, #60]	; (4024a8 <z_log_msg_post_finalize+0x80>)
  40246c:	681b      	ldr	r3, [r3, #0]
  40246e:	2b00      	cmp	r3, #0
  402470:	d0f9      	beq.n	402466 <z_log_msg_post_finalize+0x3e>
  402472:	b952      	cbnz	r2, 40248a <z_log_msg_post_finalize+0x62>
	z_impl_k_timer_start(timer, duration, period);
  402474:	2200      	movs	r2, #0
  402476:	2300      	movs	r3, #0
  402478:	480c      	ldr	r0, [pc, #48]	; (4024ac <z_log_msg_post_finalize+0x84>)
  40247a:	e9cd 2300 	strd	r2, r3, [sp]
  40247e:	f242 7210 	movw	r2, #10000	; 0x2710
  402482:	2300      	movs	r3, #0
  402484:	f003 fb2c 	bl	405ae0 <z_impl_k_timer_start>
  402488:	e7ed      	b.n	402466 <z_log_msg_post_finalize+0x3e>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
  40248a:	2a0a      	cmp	r2, #10
  40248c:	d1eb      	bne.n	402466 <z_log_msg_post_finalize+0x3e>
	z_impl_k_timer_stop(timer);
  40248e:	4807      	ldr	r0, [pc, #28]	; (4024ac <z_log_msg_post_finalize+0x84>)
  402490:	f004 fcf4 	bl	406e7c <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
  402494:	4806      	ldr	r0, [pc, #24]	; (4024b0 <z_log_msg_post_finalize+0x88>)
}
  402496:	b002      	add	sp, #8
  402498:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  40249c:	f002 bd20 	b.w	404ee0 <z_impl_k_sem_give>
  4024a0:	204006b0 	.word	0x204006b0
  4024a4:	20400c11 	.word	0x20400c11
  4024a8:	204006f0 	.word	0x204006f0
  4024ac:	20400450 	.word	0x20400450
  4024b0:	20400040 	.word	0x20400040

004024b4 <z_log_msg2_commit>:
	msg->hdr.timestamp = timestamp_func();
  4024b4:	4b06      	ldr	r3, [pc, #24]	; (4024d0 <z_log_msg2_commit+0x1c>)
{
  4024b6:	b510      	push	{r4, lr}
  4024b8:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
  4024ba:	681b      	ldr	r3, [r3, #0]
  4024bc:	4798      	blx	r3
	mpsc_pbuf_commit(&log_buffer, (union mpsc_pbuf_generic *)msg);
  4024be:	4621      	mov	r1, r4
	msg->hdr.timestamp = timestamp_func();
  4024c0:	60a0      	str	r0, [r4, #8]
	mpsc_pbuf_commit(&log_buffer, (union mpsc_pbuf_generic *)msg);
  4024c2:	4804      	ldr	r0, [pc, #16]	; (4024d4 <z_log_msg2_commit+0x20>)
  4024c4:	f003 fe59 	bl	40617a <mpsc_pbuf_commit>
}
  4024c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_log_msg_post_finalize();
  4024cc:	f7ff bfac 	b.w	402428 <z_log_msg_post_finalize>
  4024d0:	20400008 	.word	0x20400008
  4024d4:	204006bc 	.word	0x204006bc

004024d8 <z_impl_log_panic>:
{
  4024d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
  4024da:	4f0e      	ldr	r7, [pc, #56]	; (402514 <z_impl_log_panic+0x3c>)
  4024dc:	783d      	ldrb	r5, [r7, #0]
  4024de:	b975      	cbnz	r5, 4024fe <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
  4024e0:	4c0d      	ldr	r4, [pc, #52]	; (402518 <z_impl_log_panic+0x40>)
	log_init();
  4024e2:	f7ff fe77 	bl	4021d4 <log_init>
  4024e6:	4e0d      	ldr	r6, [pc, #52]	; (40251c <z_impl_log_panic+0x44>)
  4024e8:	1b36      	subs	r6, r6, r4
  4024ea:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
  4024ec:	42b5      	cmp	r5, r6
  4024ee:	db07      	blt.n	402500 <z_impl_log_panic+0x28>
  4024f0:	2000      	movs	r0, #0
  4024f2:	f7ff ff2f 	bl	402354 <z_impl_log_process>
		while (log_process(false) == true) {
  4024f6:	2800      	cmp	r0, #0
  4024f8:	d1fa      	bne.n	4024f0 <z_impl_log_panic+0x18>
	panic_mode = true;
  4024fa:	2301      	movs	r3, #1
  4024fc:	703b      	strb	r3, [r7, #0]
}
  4024fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
  402500:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
  402502:	795b      	ldrb	r3, [r3, #5]
  402504:	b11b      	cbz	r3, 40250e <z_impl_log_panic+0x36>
	backend->api->panic(backend);
  402506:	6823      	ldr	r3, [r4, #0]
  402508:	4620      	mov	r0, r4
  40250a:	695b      	ldr	r3, [r3, #20]
  40250c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
  40250e:	3501      	adds	r5, #1
  402510:	3410      	adds	r4, #16
  402512:	e7eb      	b.n	4024ec <z_impl_log_panic+0x14>
  402514:	20400c11 	.word	0x20400c11
  402518:	004072b8 	.word	0x004072b8
  40251c:	004072c8 	.word	0x004072c8

00402520 <log_source_name_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
  402520:	4a04      	ldr	r2, [pc, #16]	; (402534 <log_source_name_get+0x14>)
  402522:	4b05      	ldr	r3, [pc, #20]	; (402538 <log_source_name_get+0x18>)
  402524:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
  402526:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
  40252a:	bf34      	ite	cc
  40252c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
  402530:	2000      	movcs	r0, #0
}
  402532:	4770      	bx	lr
  402534:	00407270 	.word	0x00407270
  402538:	004072b8 	.word	0x004072b8

0040253c <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
  40253c:	4a05      	ldr	r2, [pc, #20]	; (402554 <log_backend_enable+0x18>)
	backend->cb->id = id;
  40253e:	6843      	ldr	r3, [r0, #4]
  402540:	1a80      	subs	r0, r0, r2
	backend->cb->active = true;
  402542:	2201      	movs	r2, #1
	backend->cb->ctx = ctx;
  402544:	6019      	str	r1, [r3, #0]
  402546:	1100      	asrs	r0, r0, #4
	backend->cb->active = true;
  402548:	715a      	strb	r2, [r3, #5]
  40254a:	3001      	adds	r0, #1

	if (!IS_ENABLED(CONFIG_LOG1)) {
		__ASSERT(backend->api->process, "Backend does not support v2 API");
	}

	log_backend_id_set(backend, id);
  40254c:	7118      	strb	r0, [r3, #4]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
  40254e:	f7ff be6d 	b.w	40222c <z_log_notify_backend_enabled>
  402552:	bf00      	nop
  402554:	004072b8 	.word	0x004072b8

00402558 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
  402558:	b40e      	push	{r1, r2, r3}
  40255a:	b503      	push	{r0, r1, lr}
  40255c:	ab03      	add	r3, sp, #12
  40255e:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
  402560:	4805      	ldr	r0, [pc, #20]	; (402578 <print_formatted+0x20>)
{
  402562:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
  402566:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
  402568:	f7ff f958 	bl	40181c <cbvprintf>
	va_end(args);

	return length;
}
  40256c:	b002      	add	sp, #8
  40256e:	f85d eb04 	ldr.w	lr, [sp], #4
  402572:	b003      	add	sp, #12
  402574:	4770      	bx	lr
  402576:	bf00      	nop
  402578:	00406455 	.word	0x00406455

0040257c <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
  40257c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402580:	461d      	mov	r5, r3
  402582:	9b08      	ldr	r3, [sp, #32]
  402584:	4617      	mov	r7, r2
  402586:	4604      	mov	r4, r0
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  402588:	06da      	lsls	r2, r3, #27
{
  40258a:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  40258c:	d405      	bmi.n	40259a <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  40258e:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
  402590:	bf4c      	ite	mi
  402592:	492a      	ldrmi	r1, [pc, #168]	; (40263c <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
  402594:	492a      	ldrpl	r1, [pc, #168]	; (402640 <hexdump_line_print+0xc4>)
  402596:	f7ff ffdf 	bl	402558 <print_formatted>
{
  40259a:	f04f 0800 	mov.w	r8, #0
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
  40259e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 402644 <hexdump_line_print+0xc8>
	for (int i = 0; i < prefix_offset; i++) {
  4025a2:	45a8      	cmp	r8, r5
  4025a4:	db2a      	blt.n	4025fc <hexdump_line_print+0x80>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  4025a6:	2500      	movs	r5, #0
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
  4025a8:	f8df 809c 	ldr.w	r8, [pc, #156]	; 402648 <hexdump_line_print+0xcc>
			print_formatted(output, "%02x ", data[i]);
  4025ac:	f8df 909c 	ldr.w	r9, [pc, #156]	; 40264c <hexdump_line_print+0xd0>
			print_formatted(output, " ");
  4025b0:	f8df a090 	ldr.w	sl, [pc, #144]	; 402644 <hexdump_line_print+0xc8>
		if (i < length) {
  4025b4:	42bd      	cmp	r5, r7
  4025b6:	d22f      	bcs.n	402618 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
  4025b8:	5d72      	ldrb	r2, [r6, r5]
  4025ba:	4649      	mov	r1, r9
  4025bc:	4620      	mov	r0, r4
  4025be:	f7ff ffcb 	bl	402558 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  4025c2:	3501      	adds	r5, #1
  4025c4:	2d10      	cmp	r5, #16
  4025c6:	d120      	bne.n	40260a <hexdump_line_print+0x8e>
		}
	}

	print_formatted(output, "|");

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  4025c8:	2500      	movs	r5, #0
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
  4025ca:	f8df 8078 	ldr.w	r8, [pc, #120]	; 402644 <hexdump_line_print+0xc8>
			print_formatted(output, "%c",
  4025ce:	f8df 9080 	ldr.w	r9, [pc, #128]	; 402650 <hexdump_line_print+0xd4>
	print_formatted(output, "|");
  4025d2:	4620      	mov	r0, r4
  4025d4:	491f      	ldr	r1, [pc, #124]	; (402654 <hexdump_line_print+0xd8>)
  4025d6:	f7ff ffbf 	bl	402558 <print_formatted>
		if (i < length) {
  4025da:	42af      	cmp	r7, r5
  4025dc:	d928      	bls.n	402630 <hexdump_line_print+0xb4>
			char c = (char)data[i];
  4025de:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
  4025e0:	4649      	mov	r1, r9
  4025e2:	4620      	mov	r0, r4
	return (int)((((unsigned)c) >= ' ') &&
  4025e4:	f1a2 0320 	sub.w	r3, r2, #32
  4025e8:	2b5f      	cmp	r3, #95	; 0x5f
  4025ea:	bf28      	it	cs
  4025ec:	222e      	movcs	r2, #46	; 0x2e
  4025ee:	f7ff ffb3 	bl	402558 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  4025f2:	3501      	adds	r5, #1
  4025f4:	2d10      	cmp	r5, #16
  4025f6:	d114      	bne.n	402622 <hexdump_line_print+0xa6>
		}
	}
}
  4025f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
  4025fc:	4649      	mov	r1, r9
  4025fe:	4620      	mov	r0, r4
	for (int i = 0; i < prefix_offset; i++) {
  402600:	f108 0801 	add.w	r8, r8, #1
		print_formatted(output, " ");
  402604:	f7ff ffa8 	bl	402558 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  402608:	e7cb      	b.n	4025a2 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
  40260a:	076a      	lsls	r2, r5, #29
  40260c:	d1d2      	bne.n	4025b4 <hexdump_line_print+0x38>
			print_formatted(output, " ");
  40260e:	4651      	mov	r1, sl
  402610:	4620      	mov	r0, r4
  402612:	f7ff ffa1 	bl	402558 <print_formatted>
  402616:	e7cd      	b.n	4025b4 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
  402618:	4641      	mov	r1, r8
  40261a:	4620      	mov	r0, r4
  40261c:	f7ff ff9c 	bl	402558 <print_formatted>
  402620:	e7cf      	b.n	4025c2 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
  402622:	076b      	lsls	r3, r5, #29
  402624:	d1d9      	bne.n	4025da <hexdump_line_print+0x5e>
			print_formatted(output, " ");
  402626:	4641      	mov	r1, r8
  402628:	4620      	mov	r0, r4
  40262a:	f7ff ff95 	bl	402558 <print_formatted>
  40262e:	e7d4      	b.n	4025da <hexdump_line_print+0x5e>
			print_formatted(output, " ");
  402630:	4641      	mov	r1, r8
  402632:	4620      	mov	r0, r4
  402634:	f7ff ff90 	bl	402558 <print_formatted>
  402638:	e7db      	b.n	4025f2 <hexdump_line_print+0x76>
  40263a:	bf00      	nop
  40263c:	004075f9 	.word	0x004075f9
  402640:	004075f8 	.word	0x004075f8
  402644:	00407603 	.word	0x00407603
  402648:	00407601 	.word	0x00407601
  40264c:	004075fb 	.word	0x004075fb
  402650:	00407607 	.word	0x00407607
  402654:	00407605 	.word	0x00407605

00402658 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
  402658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40265c:	461c      	mov	r4, r3
  40265e:	b087      	sub	sp, #28
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
  402660:	f001 0301 	and.w	r3, r1, #1
{
  402664:	4607      	mov	r7, r0
  402666:	9205      	str	r2, [sp, #20]
  402668:	4688      	mov	r8, r1
  40266a:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
  40266e:	f001 0b02 	and.w	fp, r1, #2
{
  402672:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  402676:	f001 0608 	and.w	r6, r1, #8
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
  40267a:	9304      	str	r3, [sp, #16]
	const char *tag = z_log_get_tag();
  40267c:	f003 fece 	bl	40641c <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
  402680:	4602      	mov	r2, r0
  402682:	2800      	cmp	r0, #0
  402684:	d044      	beq.n	402710 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
  402686:	493a      	ldr	r1, [pc, #232]	; (402770 <prefix_print+0x118>)
  402688:	4638      	mov	r0, r7
  40268a:	f7ff ff65 	bl	402558 <print_formatted>
  40268e:	4605      	mov	r5, r0
	}

	if (stamp) {
  402690:	f1bb 0f00 	cmp.w	fp, #0
  402694:	d008      	beq.n	4026a8 <prefix_print+0x50>
	if (!format) {
  402696:	f018 0f44 	tst.w	r8, #68	; 0x44
  40269a:	d13b      	bne.n	402714 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
  40269c:	4622      	mov	r2, r4
  40269e:	4935      	ldr	r1, [pc, #212]	; (402774 <prefix_print+0x11c>)
  4026a0:	4638      	mov	r0, r7
  4026a2:	f7ff ff59 	bl	402558 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
  4026a6:	4405      	add	r5, r0
	if (color) {
  4026a8:	9b04      	ldr	r3, [sp, #16]
  4026aa:	b153      	cbz	r3, 4026c2 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
  4026ac:	4b32      	ldr	r3, [pc, #200]	; (402778 <prefix_print+0x120>)
		print_formatted(output, "%s", log_color);
  4026ae:	4638      	mov	r0, r7
  4026b0:	4932      	ldr	r1, [pc, #200]	; (40277c <prefix_print+0x124>)
		const char *log_color = start && (colors[level] != NULL) ?
  4026b2:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
  4026b6:	4b32      	ldr	r3, [pc, #200]	; (402780 <prefix_print+0x128>)
  4026b8:	2a00      	cmp	r2, #0
  4026ba:	bf08      	it	eq
  4026bc:	461a      	moveq	r2, r3
  4026be:	f7ff ff4b 	bl	402558 <print_formatted>
	if (level_on) {
  4026c2:	b13e      	cbz	r6, 4026d4 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
  4026c4:	4b2f      	ldr	r3, [pc, #188]	; (402784 <prefix_print+0x12c>)
  4026c6:	4638      	mov	r0, r7
  4026c8:	492f      	ldr	r1, [pc, #188]	; (402788 <prefix_print+0x130>)
  4026ca:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
  4026ce:	f7ff ff43 	bl	402558 <print_formatted>
  4026d2:	4606      	mov	r6, r0
	if (source_id >= 0) {
  4026d4:	f1ba 0f00 	cmp.w	sl, #0
  4026d8:	db16      	blt.n	402708 <prefix_print+0xb0>
		total += print_formatted(output,
  4026da:	9b05      	ldr	r3, [sp, #20]
  4026dc:	2b00      	cmp	r3, #0
  4026de:	d045      	beq.n	40276c <prefix_print+0x114>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
  4026e0:	2301      	movs	r3, #1
		total += print_formatted(output,
  4026e2:	4c2a      	ldr	r4, [pc, #168]	; (40278c <prefix_print+0x134>)
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
  4026e4:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
  4026e8:	4b29      	ldr	r3, [pc, #164]	; (402790 <prefix_print+0x138>)
  4026ea:	f019 0f10 	tst.w	r9, #16
  4026ee:	bf18      	it	ne
  4026f0:	461c      	movne	r4, r3
  4026f2:	4651      	mov	r1, sl
  4026f4:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
  4026f8:	f7ff ff12 	bl	402520 <log_source_name_get>
  4026fc:	4621      	mov	r1, r4
  4026fe:	4602      	mov	r2, r0
  402700:	4638      	mov	r0, r7
  402702:	f7ff ff29 	bl	402558 <print_formatted>
  402706:	4406      	add	r6, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
  402708:	1970      	adds	r0, r6, r5
  40270a:	b007      	add	sp, #28
  40270c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
  402710:	4605      	mov	r5, r0
  402712:	e7bd      	b.n	402690 <prefix_print+0x38>
	} else if (freq != 0U) {
  402714:	4b1f      	ldr	r3, [pc, #124]	; (402794 <prefix_print+0x13c>)
  402716:	6818      	ldr	r0, [r3, #0]
  402718:	2800      	cmp	r0, #0
  40271a:	d0c4      	beq.n	4026a6 <prefix_print+0x4e>
		timestamp /= timestamp_div;
  40271c:	4b1e      	ldr	r3, [pc, #120]	; (402798 <prefix_print+0x140>)
		ms = (remainder * 1000U) / freq;
  40271e:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
  402722:	f44f 6161 	mov.w	r1, #3600	; 0xe10
		mins = seconds / 60U;
  402726:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
		timestamp /= timestamp_div;
  40272a:	681b      	ldr	r3, [r3, #0]
  40272c:	fbb4 f4f3 	udiv	r4, r4, r3
		total_seconds = timestamp / freq;
  402730:	fbb4 f3f0 	udiv	r3, r4, r0
		remainder = timestamp % freq;
  402734:	fb00 4413 	mls	r4, r0, r3, r4
		ms = (remainder * 1000U) / freq;
  402738:	fb08 f404 	mul.w	r4, r8, r4
  40273c:	fbb3 f2f1 	udiv	r2, r3, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  402740:	fbb4 fef0 	udiv	lr, r4, r0
  402744:	fb01 3112 	mls	r1, r1, r2, r3
  402748:	fb00 441e 	mls	r4, r0, lr, r4
		mins = seconds / 60U;
  40274c:	fbb1 f3fc 	udiv	r3, r1, ip
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  402750:	fb08 f404 	mul.w	r4, r8, r4
			length = print_formatted(output,
  402754:	fb0c 1113 	mls	r1, ip, r3, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  402758:	fbb4 f0f0 	udiv	r0, r4, r0
			length = print_formatted(output,
  40275c:	9100      	str	r1, [sp, #0]
  40275e:	490f      	ldr	r1, [pc, #60]	; (40279c <prefix_print+0x144>)
  402760:	e9cd e001 	strd	lr, r0, [sp, #4]
  402764:	4638      	mov	r0, r7
  402766:	f7ff fef7 	bl	402558 <print_formatted>
  40276a:	e79c      	b.n	4026a6 <prefix_print+0x4e>
		total += print_formatted(output,
  40276c:	4c07      	ldr	r4, [pc, #28]	; (40278c <prefix_print+0x134>)
  40276e:	e7c0      	b.n	4026f2 <prefix_print+0x9a>
  402770:	00407618 	.word	0x00407618
  402774:	0040761c 	.word	0x0040761c
  402778:	00407320 	.word	0x00407320
  40277c:	00407641 	.word	0x00407641
  402780:	0040760a 	.word	0x0040760a
  402784:	00407334 	.word	0x00407334
  402788:	00407644 	.word	0x00407644
  40278c:	0040760f 	.word	0x0040760f
  402790:	00407614 	.word	0x00407614
  402794:	204006f4 	.word	0x204006f4
  402798:	204006f8 	.word	0x204006f8
  40279c:	00407625 	.word	0x00407625

004027a0 <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
  4027a0:	b538      	push	{r3, r4, r5, lr}
  4027a2:	460c      	mov	r4, r1
  4027a4:	4605      	mov	r5, r0
	if (color) {
  4027a6:	07e1      	lsls	r1, r4, #31
  4027a8:	d503      	bpl.n	4027b2 <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
  4027aa:	4a08      	ldr	r2, [pc, #32]	; (4027cc <postfix_print+0x2c>)
  4027ac:	4908      	ldr	r1, [pc, #32]	; (4027d0 <postfix_print+0x30>)
  4027ae:	f7ff fed3 	bl	402558 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  4027b2:	06e2      	lsls	r2, r4, #27
  4027b4:	d408      	bmi.n	4027c8 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  4027b6:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
  4027b8:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
  4027ba:	bf4c      	ite	mi
  4027bc:	4905      	ldrmi	r1, [pc, #20]	; (4027d4 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
  4027be:	4906      	ldrpl	r1, [pc, #24]	; (4027d8 <postfix_print+0x38>)
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
  4027c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
  4027c4:	f7ff bec8 	b.w	402558 <print_formatted>
}
  4027c8:	bd38      	pop	{r3, r4, r5, pc}
  4027ca:	bf00      	nop
  4027cc:	0040760a 	.word	0x0040760a
  4027d0:	00407641 	.word	0x00407641
  4027d4:	004075f9 	.word	0x004075f9
  4027d8:	004075f8 	.word	0x004075f8

004027dc <log_output_msg2_process>:
	log_output_flush(output);
}

void log_output_msg2_process(const struct log_output *output,
			     struct log_msg2 *msg, uint32_t flags)
{
  4027dc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @return Log level.
 */
static inline uint8_t log_msg2_get_level(struct log_msg2 *msg)
{
	return msg->hdr.desc.level;
  4027e0:	880b      	ldrh	r3, [r1, #0]
  4027e2:	4606      	mov	r6, r0
  4027e4:	460c      	mov	r4, r1
  4027e6:	4690      	mov	r8, r2
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYST) {
		log_output_msg2_syst_process(output, msg, flags);
		return;
	}

	if (!raw_string) {
  4027e8:	f413 7fe0 	tst.w	r3, #448	; 0x1c0
  4027ec:	f3c3 1982 	ubfx	r9, r3, #6, #3
  4027f0:	d04c      	beq.n	40288c <log_output_msg2_process+0xb0>
	return msg->hdr.desc.domain;
  4027f2:	780a      	ldrb	r2, [r1, #0]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg2_get_source(struct log_msg2 *msg)
{
	return msg->hdr.source;
  4027f4:	684b      	ldr	r3, [r1, #4]
	return msg->hdr.desc.domain;
  4027f6:	f3c2 02c2 	ubfx	r2, r2, #3, #3
		void *source = (void *)log_msg2_get_source(msg);
		uint8_t domain_id = log_msg2_get_domain(msg);
		int16_t source_id = source ?
  4027fa:	2b00      	cmp	r3, #0
  4027fc:	d043      	beq.n	402886 <log_output_msg2_process+0xaa>
  4027fe:	4924      	ldr	r1, [pc, #144]	; (402890 <log_output_msg2_process+0xb4>)
  402800:	1a5b      	subs	r3, r3, r1
  402802:	f343 03cf 	sbfx	r3, r3, #3, #16
			(IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
				log_dynamic_source_id(source) :
				log_const_source_id(source)) :
			-1;

		prefix_offset = prefix_print(output, flags, 0, timestamp,
  402806:	f8cd 9000 	str.w	r9, [sp]
  40280a:	4641      	mov	r1, r8
  40280c:	4630      	mov	r0, r6
  40280e:	e9cd 2301 	strd	r2, r3, [sp, #4]
  402812:	2200      	movs	r2, #0
  402814:	68a3      	ldr	r3, [r4, #8]
  402816:	f7ff ff1f 	bl	402658 <prefix_print>
  40281a:	4682      	mov	sl, r0
 */
static inline uint8_t *log_msg2_get_package(struct log_msg2 *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;

	return msg->data;
  40281c:	4625      	mov	r5, r4
	*len = msg->hdr.desc.package_len;
  40281e:	f855 3b0c 	ldr.w	r3, [r5], #12
	}

	size_t len;
	uint8_t *data = log_msg2_get_package(msg, &len);

	if (len) {
  402822:	f3c3 2349 	ubfx	r3, r3, #9, #10
  402826:	b14b      	cbz	r3, 40283c <log_output_msg2_process+0x60>
		int err = cbpprintf(raw_string ? cr_out_func :  out_func,
  402828:	481a      	ldr	r0, [pc, #104]	; (402894 <log_output_msg2_process+0xb8>)
  40282a:	462a      	mov	r2, r5
  40282c:	4b1a      	ldr	r3, [pc, #104]	; (402898 <log_output_msg2_process+0xbc>)
  40282e:	4631      	mov	r1, r6
  402830:	f1b9 0f00 	cmp.w	r9, #0
  402834:	bf18      	it	ne
  402836:	4618      	movne	r0, r3
  402838:	f003 f9dd 	bl	405bf6 <cbpprintf>
	*len = msg->hdr.desc.data_len;
  40283c:	8867      	ldrh	r7, [r4, #2]
  40283e:	f3c7 07cb 	ubfx	r7, r7, #3, #12
		(void)err;
		__ASSERT_NO_MSG(err >= 0);
	}

	data = log_msg2_get_data(msg, &len);
	if (len) {
  402842:	b197      	cbz	r7, 40286a <log_output_msg2_process+0x8e>
	return msg->data + msg->hdr.desc.package_len;
  402844:	6822      	ldr	r2, [r4, #0]
  402846:	f3c2 2249 	ubfx	r2, r2, #9, #10
  40284a:	4415      	add	r5, r2
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  40284c:	2f10      	cmp	r7, #16
  40284e:	463c      	mov	r4, r7
		hexdump_line_print(output, data, length,
  402850:	4629      	mov	r1, r5
  402852:	4653      	mov	r3, sl
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  402854:	bf28      	it	cs
  402856:	2410      	movcs	r4, #16
		hexdump_line_print(output, data, length,
  402858:	4630      	mov	r0, r6
  40285a:	f8cd 8000 	str.w	r8, [sp]
  40285e:	4622      	mov	r2, r4
		data += length;
  402860:	4425      	add	r5, r4
		hexdump_line_print(output, data, length,
  402862:	f7ff fe8b 	bl	40257c <hexdump_line_print>
	} while (len);
  402866:	1b3f      	subs	r7, r7, r4
  402868:	d1f0      	bne.n	40284c <log_output_msg2_process+0x70>
		log_msg2_hexdump(output, data, len, prefix_offset, flags);
	}

	if (!raw_string) {
  40286a:	f1b9 0f00 	cmp.w	r9, #0
  40286e:	d004      	beq.n	40287a <log_output_msg2_process+0x9e>
		postfix_print(output, flags, level);
  402870:	464a      	mov	r2, r9
  402872:	4641      	mov	r1, r8
  402874:	4630      	mov	r0, r6
  402876:	f7ff ff93 	bl	4027a0 <postfix_print>
	}

	log_output_flush(output);
  40287a:	4630      	mov	r0, r6
}
  40287c:	b004      	add	sp, #16
  40287e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(output);
  402882:	f003 bdda 	b.w	40643a <log_output_flush>
		int16_t source_id = source ?
  402886:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  40288a:	e7bc      	b.n	402806 <log_output_msg2_process+0x2a>
		prefix_offset = 0;
  40288c:	46ca      	mov	sl, r9
  40288e:	e7c5      	b.n	40281c <log_output_msg2_process+0x40>
  402890:	00407270 	.word	0x00407270
  402894:	0040648b 	.word	0x0040648b
  402898:	00406455 	.word	0x00406455

0040289c <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
  40289c:	f242 730f 	movw	r3, #9999	; 0x270f
  4028a0:	4a11      	ldr	r2, [pc, #68]	; (4028e8 <log_output_dropped_process+0x4c>)
  4028a2:	428b      	cmp	r3, r1
{
  4028a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  4028a6:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
  4028a8:	bf28      	it	cs
  4028aa:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
  4028ac:	6805      	ldr	r5, [r0, #0]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
  4028ae:	2105      	movs	r1, #5
  4028b0:	4668      	mov	r0, sp
  4028b2:	f003 f9eb 	bl	405c8c <snprintk>

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
  4028b6:	6863      	ldr	r3, [r4, #4]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
  4028b8:	4606      	mov	r6, r0
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
  4028ba:	220b      	movs	r2, #11
  4028bc:	4628      	mov	r0, r5
  4028be:	685b      	ldr	r3, [r3, #4]
  4028c0:	490a      	ldr	r1, [pc, #40]	; (4028ec <log_output_dropped_process+0x50>)
  4028c2:	f003 fdad 	bl	406420 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
  4028c6:	6863      	ldr	r3, [r4, #4]
  4028c8:	4632      	mov	r2, r6
  4028ca:	4669      	mov	r1, sp
  4028cc:	4628      	mov	r0, r5
  4028ce:	685b      	ldr	r3, [r3, #4]
  4028d0:	f003 fda6 	bl	406420 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
  4028d4:	6863      	ldr	r3, [r4, #4]
  4028d6:	221b      	movs	r2, #27
  4028d8:	4905      	ldr	r1, [pc, #20]	; (4028f0 <log_output_dropped_process+0x54>)
  4028da:	685b      	ldr	r3, [r3, #4]
  4028dc:	4628      	mov	r0, r5
  4028de:	f003 fd9f 	bl	406420 <buffer_write>
		     output->control_block->ctx);
}
  4028e2:	b002      	add	sp, #8
  4028e4:	bd70      	pop	{r4, r5, r6, pc}
  4028e6:	bf00      	nop
  4028e8:	00407d67 	.word	0x00407d67
  4028ec:	00407686 	.word	0x00407686
  4028f0:	0040766a 	.word	0x0040766a

004028f4 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
  4028f4:	b510      	push	{r4, lr}
	timestamp_div = 1U;
  4028f6:	4a08      	ldr	r2, [pc, #32]	; (402918 <log_output_timestamp_freq_set+0x24>)
  4028f8:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  4028fa:	2100      	movs	r1, #0
  4028fc:	4c07      	ldr	r4, [pc, #28]	; (40291c <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
  4028fe:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
  402900:	42a0      	cmp	r0, r4
  402902:	d804      	bhi.n	40290e <log_output_timestamp_freq_set+0x1a>
  402904:	b101      	cbz	r1, 402908 <log_output_timestamp_freq_set+0x14>
  402906:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
  402908:	4b05      	ldr	r3, [pc, #20]	; (402920 <log_output_timestamp_freq_set+0x2c>)
  40290a:	6018      	str	r0, [r3, #0]
}
  40290c:	bd10      	pop	{r4, pc}
		frequency /= 2U;
  40290e:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
  402910:	2101      	movs	r1, #1
  402912:	005b      	lsls	r3, r3, #1
  402914:	e7f4      	b.n	402900 <log_output_timestamp_freq_set+0xc>
  402916:	bf00      	nop
  402918:	204006f8 	.word	0x204006f8
  40291c:	000f4240 	.word	0x000f4240
  402920:	204006f4 	.word	0x204006f4

00402924 <z_impl_z_log_msg2_runtime_vcreate>:
#endif

void z_impl_z_log_msg2_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				const char *fmt, va_list ap)
{
  402924:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402928:	b085      	sub	sp, #20
  40292a:	4605      	mov	r5, r0
  40292c:	4688      	mov	r8, r1
  40292e:	4614      	mov	r4, r2
  402930:	4699      	mov	r9, r3
  402932:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
  402936:	e9dd 6b0e 	ldrd	r6, fp, [sp, #56]	; 0x38
	int plen;

	if (fmt) {
  40293a:	f1bb 0f00 	cmp.w	fp, #0
  40293e:	d037      	beq.n	4029b0 <z_impl_z_log_msg2_runtime_vcreate+0x8c>
		va_list ap2;

		va_copy(ap2, ap);
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET, 0,
  402940:	2200      	movs	r2, #0
  402942:	465b      	mov	r3, fp
  402944:	210c      	movs	r1, #12
  402946:	f8cd a000 	str.w	sl, [sp]
  40294a:	4610      	mov	r0, r2
		va_copy(ap2, ap);
  40294c:	f8cd a00c 	str.w	sl, [sp, #12]
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET, 0,
  402950:	f7fe fd2a 	bl	4013a8 <cbvprintf_package>
  402954:	4607      	mov	r7, r0
		plen = 0;
	}

	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
	struct log_msg2 *msg;
	struct log_msg2_desc desc =
  402956:	f004 0207 	and.w	r2, r4, #7
  40295a:	f005 0407 	and.w	r4, r5, #7
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
  40295e:	f106 0013 	add.w	r0, r6, #19
	struct log_msg2_desc desc =
  402962:	4d14      	ldr	r5, [pc, #80]	; (4029b4 <z_impl_z_log_msg2_runtime_vcreate+0x90>)
  402964:	00e4      	lsls	r4, r4, #3
  402966:	4b14      	ldr	r3, [pc, #80]	; (4029b8 <z_impl_z_log_msg2_runtime_vcreate+0x94>)
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
  402968:	4438      	add	r0, r7
	struct log_msg2_desc desc =
  40296a:	ea05 2547 	and.w	r5, r5, r7, lsl #9
  40296e:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
  402972:	f020 0007 	bic.w	r0, r0, #7
	struct log_msg2_desc desc =
  402976:	ea03 43c6 	and.w	r3, r3, r6, lsl #19
  40297a:	432c      	orrs	r4, r5
		Z_LOG_MSG_DESC_INITIALIZER(domain_id, level, plen, dlen);

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		msg = alloca(msg_wlen * sizeof(int));
	} else {
		msg = z_log_msg2_alloc(msg_wlen);
  40297c:	0880      	lsrs	r0, r0, #2
	struct log_msg2_desc desc =
  40297e:	431c      	orrs	r4, r3
		msg = z_log_msg2_alloc(msg_wlen);
  402980:	f7ff fcce 	bl	402320 <z_log_msg2_alloc>
	}

	if (msg && fmt) {
  402984:	4605      	mov	r5, r0
  402986:	b150      	cbz	r0, 40299e <z_impl_z_log_msg2_runtime_vcreate+0x7a>
  402988:	f1bb 0f00 	cmp.w	fp, #0
  40298c:	d007      	beq.n	40299e <z_impl_z_log_msg2_runtime_vcreate+0x7a>
		plen = cbvprintf_package(msg->data, (size_t)plen, 0, fmt, ap);
  40298e:	465b      	mov	r3, fp
  402990:	2200      	movs	r2, #0
  402992:	4639      	mov	r1, r7
  402994:	300c      	adds	r0, #12
  402996:	f8cd a000 	str.w	sl, [sp]
  40299a:	f7fe fd05 	bl	4013a8 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
	}

	z_log_msg2_finalize(msg, source, desc, data);
  40299e:	464b      	mov	r3, r9
  4029a0:	4622      	mov	r2, r4
  4029a2:	4641      	mov	r1, r8
  4029a4:	4628      	mov	r0, r5
}
  4029a6:	b005      	add	sp, #20
  4029a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_log_msg2_finalize(msg, source, desc, data);
  4029ac:	f003 bd7a 	b.w	4064a4 <z_log_msg2_finalize>
		plen = 0;
  4029b0:	465f      	mov	r7, fp
  4029b2:	e7d0      	b.n	402956 <z_impl_z_log_msg2_runtime_vcreate+0x32>
  4029b4:	0007fe00 	.word	0x0007fe00
  4029b8:	7ff80000 	.word	0x7ff80000

004029bc <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
  4029bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4029be:	460d      	mov	r5, r1
  4029c0:	4604      	mov	r4, r0
  4029c2:	1846      	adds	r6, r0, r1
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
  4029c4:	4f05      	ldr	r7, [pc, #20]	; (4029dc <char_out+0x20>)
		for (size_t i = 0; i < length; i++) {
  4029c6:	42b4      	cmp	r4, r6
  4029c8:	d101      	bne.n	4029ce <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
  4029ca:	4628      	mov	r0, r5
  4029cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
  4029ce:	6838      	ldr	r0, [r7, #0]
  4029d0:	f814 1b01 	ldrb.w	r1, [r4], #1
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
  4029d4:	6883      	ldr	r3, [r0, #8]
  4029d6:	685b      	ldr	r3, [r3, #4]
  4029d8:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
  4029da:	e7f4      	b.n	4029c6 <char_out+0xa>
  4029dc:	20400710 	.word	0x20400710

004029e0 <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
  4029e0:	4b01      	ldr	r3, [pc, #4]	; (4029e8 <log_backend_uart_init+0x8>)
  4029e2:	4a02      	ldr	r2, [pc, #8]	; (4029ec <log_backend_uart_init+0xc>)
  4029e4:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
  4029e6:	4770      	bx	lr
  4029e8:	20400710 	.word	0x20400710
  4029ec:	00406ff0 	.word	0x00406ff0

004029f0 <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
  4029f0:	4b02      	ldr	r3, [pc, #8]	; (4029fc <panic+0xc>)
  4029f2:	2201      	movs	r2, #1
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
  4029f4:	4802      	ldr	r0, [pc, #8]	; (402a00 <panic+0x10>)
  4029f6:	701a      	strb	r2, [r3, #0]
  4029f8:	f003 bd1f 	b.w	40643a <log_output_flush>
  4029fc:	20400c12 	.word	0x20400c12
  402a00:	00407364 	.word	0x00407364

00402a04 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
  402a04:	4801      	ldr	r0, [pc, #4]	; (402a0c <dropped+0x8>)
  402a06:	f7ff bf49 	b.w	40289c <log_output_dropped_process>
  402a0a:	bf00      	nop
  402a0c:	00407364 	.word	0x00407364

00402a10 <process>:
		log_output_msg2_process(&log_output_uart, &msg->log, flags);
  402a10:	220f      	movs	r2, #15
  402a12:	4801      	ldr	r0, [pc, #4]	; (402a18 <process+0x8>)
  402a14:	f7ff bee2 	b.w	4027dc <log_output_msg2_process>
  402a18:	00407364 	.word	0x00407364

00402a1c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
  402a1c:	4901      	ldr	r1, [pc, #4]	; (402a24 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
  402a1e:	2210      	movs	r2, #16
	str	r2, [r1]
  402a20:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
  402a22:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
  402a24:	e000ed10 	.word	0xe000ed10

00402a28 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
  402a28:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
  402a2a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
  402a2c:	f380 8811 	msr	BASEPRI, r0
	isb
  402a30:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
  402a34:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
  402a38:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
  402a3a:	b662      	cpsie	i
	isb
  402a3c:	f3bf 8f6f 	isb	sy

	bx	lr
  402a40:	4770      	bx	lr
  402a42:	bf00      	nop

00402a44 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  402a44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402a48:	b088      	sub	sp, #32
  402a4a:	4681      	mov	r9, r0

	if (esf != NULL) {
  402a4c:	460c      	mov	r4, r1
{
  402a4e:	af00      	add	r7, sp, #0
	if (esf != NULL) {
  402a50:	2900      	cmp	r1, #0
  402a52:	d04b      	beq.n	402aec <z_arm_fatal_error+0xa8>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
  402a54:	46ea      	mov	sl, sp
  402a56:	b088      	sub	sp, #32
  402a58:	f04f 0805 	mov.w	r8, #5
  402a5c:	68a3      	ldr	r3, [r4, #8]
  402a5e:	466d      	mov	r5, sp
  402a60:	4826      	ldr	r0, [pc, #152]	; (402afc <z_arm_fatal_error+0xb8>)
  402a62:	f8c7 8008 	str.w	r8, [r7, #8]
  402a66:	462e      	mov	r6, r5
  402a68:	e9d1 1200 	ldrd	r1, r2, [r1]
  402a6c:	e9c5 0104 	strd	r0, r1, [r5, #16]
  402a70:	e9c5 2306 	strd	r2, r3, [r5, #24]
  402a74:	f846 8f0c 	str.w	r8, [r6, #12]!
  402a78:	2300      	movs	r3, #0
  402a7a:	4632      	mov	r2, r6
  402a7c:	f44f 5121 	mov.w	r1, #10304	; 0x2840
  402a80:	481f      	ldr	r0, [pc, #124]	; (402b00 <z_arm_fatal_error+0xbc>)
  402a82:	f003 fd2a 	bl	4064da <z_impl_z_log_msg2_static_create>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
  402a86:	481f      	ldr	r0, [pc, #124]	; (402b04 <z_arm_fatal_error+0xc0>)
  402a88:	6963      	ldr	r3, [r4, #20]
  402a8a:	46d5      	mov	sp, sl
  402a8c:	f8c7 8008 	str.w	r8, [r7, #8]
  402a90:	46ad      	mov	sp, r5
  402a92:	f8c5 800c 	str.w	r8, [r5, #12]
  402a96:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
  402a9a:	e9c5 0104 	strd	r0, r1, [r5, #16]
  402a9e:	e9c5 2306 	strd	r2, r3, [r5, #24]
  402aa2:	2300      	movs	r3, #0
  402aa4:	4632      	mov	r2, r6
  402aa6:	f44f 5121 	mov.w	r1, #10304	; 0x2840
  402aaa:	4815      	ldr	r0, [pc, #84]	; (402b00 <z_arm_fatal_error+0xbc>)
  402aac:	f003 fd15 	bl	4064da <z_impl_z_log_msg2_static_create>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
  402ab0:	2503      	movs	r5, #3
  402ab2:	4a15      	ldr	r2, [pc, #84]	; (402b08 <z_arm_fatal_error+0xc4>)
  402ab4:	46d5      	mov	sp, sl
  402ab6:	69e3      	ldr	r3, [r4, #28]
  402ab8:	607d      	str	r5, [r7, #4]
  402aba:	617d      	str	r5, [r7, #20]
  402abc:	e9c7 2306 	strd	r2, r3, [r7, #24]
  402ac0:	2300      	movs	r3, #0
  402ac2:	f107 0214 	add.w	r2, r7, #20
  402ac6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  402aca:	480d      	ldr	r0, [pc, #52]	; (402b00 <z_arm_fatal_error+0xbc>)
  402acc:	f003 fd05 	bl	4064da <z_impl_z_log_msg2_static_create>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
  402ad0:	4a0e      	ldr	r2, [pc, #56]	; (402b0c <z_arm_fatal_error+0xc8>)
  402ad2:	69a3      	ldr	r3, [r4, #24]
  402ad4:	607d      	str	r5, [r7, #4]
  402ad6:	617d      	str	r5, [r7, #20]
  402ad8:	e9c7 2306 	strd	r2, r3, [r7, #24]
  402adc:	2300      	movs	r3, #0
  402ade:	f107 0214 	add.w	r2, r7, #20
  402ae2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  402ae6:	4806      	ldr	r0, [pc, #24]	; (402b00 <z_arm_fatal_error+0xbc>)
  402ae8:	f003 fcf7 	bl	4064da <z_impl_z_log_msg2_static_create>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
  402aec:	4621      	mov	r1, r4
  402aee:	4648      	mov	r0, r9
  402af0:	f001 ff4a 	bl	404988 <z_fatal_error>
}
  402af4:	3720      	adds	r7, #32
  402af6:	46bd      	mov	sp, r7
  402af8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402afc:	004076ac 	.word	0x004076ac
  402b00:	004072a0 	.word	0x004072a0
  402b04:	004076db 	.word	0x004076db
  402b08:	0040770a 	.word	0x0040770a
  402b0c:	00407719 	.word	0x00407719

00402b10 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
  402b10:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  402b12:	2b00      	cmp	r3, #0
  402b14:	db08      	blt.n	402b28 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  402b16:	2201      	movs	r2, #1
  402b18:	f000 001f 	and.w	r0, r0, #31
  402b1c:	095b      	lsrs	r3, r3, #5
  402b1e:	fa02 f000 	lsl.w	r0, r2, r0
  402b22:	4a02      	ldr	r2, [pc, #8]	; (402b2c <arch_irq_enable+0x1c>)
  402b24:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
  402b28:	4770      	bx	lr
  402b2a:	bf00      	nop
  402b2c:	e000e100 	.word	0xe000e100

00402b30 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
  402b30:	b243      	sxtb	r3, r0
		prio += _IRQ_PRIO_OFFSET;
  402b32:	3101      	adds	r1, #1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  402b34:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  402b36:	ea4f 1141 	mov.w	r1, r1, lsl #5
  402b3a:	b2c9      	uxtb	r1, r1
  if ((int32_t)(IRQn) >= 0)
  402b3c:	db06      	blt.n	402b4c <z_arm_irq_priority_set+0x1c>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  402b3e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  402b42:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  402b46:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
  402b4a:	4770      	bx	lr
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  402b4c:	f000 000f 	and.w	r0, r0, #15
  402b50:	4b01      	ldr	r3, [pc, #4]	; (402b58 <z_arm_irq_priority_set+0x28>)
  402b52:	5419      	strb	r1, [r3, r0]
}
  402b54:	4770      	bx	lr
  402b56:	bf00      	nop
  402b58:	e000ed14 	.word	0xe000ed14

00402b5c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
  402b5c:	bf30      	wfi
    b z_SysNmiOnReset
  402b5e:	f7ff bffd 	b.w	402b5c <z_SysNmiOnReset>
  402b62:	bf00      	nop

00402b64 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
  402b64:	4a0f      	ldr	r2, [pc, #60]	; (402ba4 <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
  402b66:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
  402b68:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
  402b6c:	4b0e      	ldr	r3, [pc, #56]	; (402ba8 <z_arm_prep_c+0x44>)
  402b6e:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
  402b70:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  402b74:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
  402b78:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  402b7c:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  402b80:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
  402b84:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
  402b88:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  402b8c:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
  402b90:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
  402b94:	f001 ffa6 	bl	404ae4 <z_bss_zero>
	z_data_copy();
  402b98:	f002 fe08 	bl	4057ac <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
  402b9c:	f000 fb96 	bl	4032cc <z_arm_interrupt_init>
	z_cstart();
  402ba0:	f001 ffaa 	bl	404af8 <z_cstart>
  402ba4:	00400000 	.word	0x00400000
  402ba8:	e000ed00 	.word	0xe000ed00

00402bac <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
  402bac:	4a09      	ldr	r2, [pc, #36]	; (402bd4 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
  402bae:	490a      	ldr	r1, [pc, #40]	; (402bd8 <arch_swap+0x2c>)
	_current->arch.basepri = key;
  402bb0:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
  402bb2:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
  402bb4:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
  402bb6:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
  402bb8:	4908      	ldr	r1, [pc, #32]	; (402bdc <arch_swap+0x30>)
  402bba:	684b      	ldr	r3, [r1, #4]
  402bbc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  402bc0:	604b      	str	r3, [r1, #4]
  402bc2:	2300      	movs	r3, #0
  402bc4:	f383 8811 	msr	BASEPRI, r3
  402bc8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
  402bcc:	6893      	ldr	r3, [r2, #8]
}
  402bce:	6f98      	ldr	r0, [r3, #120]	; 0x78
  402bd0:	4770      	bx	lr
  402bd2:	bf00      	nop
  402bd4:	20400bd4 	.word	0x20400bd4
  402bd8:	00407554 	.word	0x00407554
  402bdc:	e000ed00 	.word	0xe000ed00

00402be0 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
  402be0:	4912      	ldr	r1, [pc, #72]	; (402c2c <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
  402be2:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
  402be4:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
  402be8:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
  402bea:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
  402bee:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
  402bf2:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
  402bf4:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
  402bf8:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
  402bfc:	4f0c      	ldr	r7, [pc, #48]	; (402c30 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
  402bfe:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
  402c02:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
  402c04:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
  402c06:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
  402c08:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
  402c0a:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
  402c0c:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
  402c0e:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
  402c12:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
  402c14:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
  402c16:	f000 fb99 	bl	40334c <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
  402c1a:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
  402c1e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
  402c22:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
  402c26:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
  402c2a:	4770      	bx	lr
    ldr r1, =_kernel
  402c2c:	20400bd4 	.word	0x20400bd4
    ldr v4, =_SCS_ICSR
  402c30:	e000ed04 	.word	0xe000ed04

00402c34 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
  402c34:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
  402c38:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
  402c3a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
  402c3e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
  402c42:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
  402c44:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
  402c48:	2902      	cmp	r1, #2
    beq _oops
  402c4a:	d0ff      	beq.n	402c4c <_oops>

00402c4c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
  402c4c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
  402c4e:	f003 fc64 	bl	40651a <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
  402c52:	bd01      	pop	{r0, pc}

00402c54 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
  402c54:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
  402c58:	3a20      	subs	r2, #32
	iframe->a2 = (uint32_t)p1;
  402c5a:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
  402c5c:	4907      	ldr	r1, [pc, #28]	; (402c7c <arch_new_thread+0x28>)
	iframe->a2 = (uint32_t)p1;
  402c5e:	6053      	str	r3, [r2, #4]
	iframe->a3 = (uint32_t)p2;
  402c60:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
  402c62:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
  402c66:	6093      	str	r3, [r2, #8]
	iframe->a4 = (uint32_t)p3;
  402c68:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
  402c6a:	6191      	str	r1, [r2, #24]
	iframe->a4 = (uint32_t)p3;
  402c6c:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
  402c6e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  402c72:	61d3      	str	r3, [r2, #28]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
  402c74:	2300      	movs	r3, #0
	thread->callee_saved.psp = (uint32_t)iframe;
  402c76:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
  402c78:	6743      	str	r3, [r0, #116]	; 0x74
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
  402c7a:	4770      	bx	lr
  402c7c:	00405ca7 	.word	0x00405ca7

00402c80 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
  402c80:	4a09      	ldr	r2, [pc, #36]	; (402ca8 <z_check_thread_stack_fail+0x28>)
{
  402c82:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
  402c84:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
  402c86:	b170      	cbz	r0, 402ca6 <z_check_thread_stack_fail+0x26>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
  402c88:	f113 0f16 	cmn.w	r3, #22
  402c8c:	6e40      	ldr	r0, [r0, #100]	; 0x64
  402c8e:	d005      	beq.n	402c9c <z_check_thread_stack_fail+0x1c>
  402c90:	f1a0 0220 	sub.w	r2, r0, #32
  402c94:	429a      	cmp	r2, r3
  402c96:	d805      	bhi.n	402ca4 <z_check_thread_stack_fail+0x24>
  402c98:	4283      	cmp	r3, r0
  402c9a:	d203      	bcs.n	402ca4 <z_check_thread_stack_fail+0x24>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
  402c9c:	4281      	cmp	r1, r0
  402c9e:	bf28      	it	cs
  402ca0:	2000      	movcs	r0, #0
  402ca2:	4770      	bx	lr
  402ca4:	2000      	movs	r0, #0
}
  402ca6:	4770      	bx	lr
  402ca8:	20400bd4 	.word	0x20400bd4

00402cac <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
  402cac:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
  402cae:	4b09      	ldr	r3, [pc, #36]	; (402cd4 <arch_switch_to_main_thread+0x28>)
{
  402cb0:	460d      	mov	r5, r1
  402cb2:	4614      	mov	r4, r2
	_current = main_thread;
  402cb4:	6098      	str	r0, [r3, #8]
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
  402cb6:	f000 fb49 	bl	40334c <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
  402cba:	4620      	mov	r0, r4
  402cbc:	f385 8809 	msr	PSP, r5
  402cc0:	2100      	movs	r1, #0
  402cc2:	b663      	cpsie	if
  402cc4:	f381 8811 	msr	BASEPRI, r1
  402cc8:	f3bf 8f6f 	isb	sy
  402ccc:	2200      	movs	r2, #0
  402cce:	2300      	movs	r3, #0
  402cd0:	f002 ffe9 	bl	405ca6 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
  402cd4:	20400bd4 	.word	0x20400bd4

00402cd8 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
  402cd8:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
  402cda:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
  402cde:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
  402ce2:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
  402ce6:	4904      	ldr	r1, [pc, #16]	; (402cf8 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
  402ce8:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
  402cea:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
  402cec:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
  402cee:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
  402cf2:	4902      	ldr	r1, [pc, #8]	; (402cfc <_isr_wrapper+0x24>)
	bx r1
  402cf4:	4708      	bx	r1
  402cf6:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
  402cf8:	00407038 	.word	0x00407038
	ldr r1, =z_arm_int_exit
  402cfc:	00402d01 	.word	0x00402d01

00402d00 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
  402d00:	4b04      	ldr	r3, [pc, #16]	; (402d14 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
  402d02:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
  402d04:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
  402d06:	4288      	cmp	r0, r1
	beq _EXIT_EXC
  402d08:	d003      	beq.n	402d12 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
  402d0a:	4903      	ldr	r1, [pc, #12]	; (402d18 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
  402d0c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
  402d10:	600a      	str	r2, [r1, #0]

00402d12 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
  402d12:	4770      	bx	lr
	ldr r3, =_kernel
  402d14:	20400bd4 	.word	0x20400bd4
	ldr r1, =_SCS_ICSR
  402d18:	e000ed04 	.word	0xe000ed04

00402d1c <bus_fault.constprop.0>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason.
 *
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
  402d1c:	b570      	push	{r4, r5, r6, lr}
  402d1e:	b088      	sub	sp, #32
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
  402d20:	4b3c      	ldr	r3, [pc, #240]	; (402e14 <bus_fault.constprop.0+0xf8>)
  402d22:	2402      	movs	r4, #2
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
  402d24:	4606      	mov	r6, r0
  402d26:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
  402d28:	aa05      	add	r2, sp, #20
  402d2a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402d2e:	483a      	ldr	r0, [pc, #232]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402d30:	9306      	str	r3, [sp, #24]
  402d32:	9401      	str	r4, [sp, #4]
  402d34:	9405      	str	r4, [sp, #20]
  402d36:	f003 fbff 	bl	406538 <z_log_msg2_static_create.constprop.0>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
  402d3a:	4b38      	ldr	r3, [pc, #224]	; (402e1c <bus_fault.constprop.0+0x100>)
  402d3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402d3e:	04d9      	lsls	r1, r3, #19
  402d40:	d509      	bpl.n	402d56 <bus_fault.constprop.0+0x3a>
		PR_FAULT_INFO("  Stacking error");
  402d42:	4b37      	ldr	r3, [pc, #220]	; (402e20 <bus_fault.constprop.0+0x104>)
  402d44:	aa05      	add	r2, sp, #20
  402d46:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402d4a:	4833      	ldr	r0, [pc, #204]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402d4c:	9306      	str	r3, [sp, #24]
  402d4e:	9401      	str	r4, [sp, #4]
  402d50:	9405      	str	r4, [sp, #20]
  402d52:	f003 fbf1 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
  402d56:	4b31      	ldr	r3, [pc, #196]	; (402e1c <bus_fault.constprop.0+0x100>)
  402d58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402d5a:	051a      	lsls	r2, r3, #20
  402d5c:	d50a      	bpl.n	402d74 <bus_fault.constprop.0+0x58>
		PR_FAULT_INFO("  Unstacking error");
  402d5e:	4b31      	ldr	r3, [pc, #196]	; (402e24 <bus_fault.constprop.0+0x108>)
  402d60:	aa05      	add	r2, sp, #20
  402d62:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402d66:	482c      	ldr	r0, [pc, #176]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402d68:	9306      	str	r3, [sp, #24]
  402d6a:	2302      	movs	r3, #2
  402d6c:	9301      	str	r3, [sp, #4]
  402d6e:	9305      	str	r3, [sp, #20]
  402d70:	f003 fbe2 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
  402d74:	4c29      	ldr	r4, [pc, #164]	; (402e1c <bus_fault.constprop.0+0x100>)
  402d76:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402d78:	059b      	lsls	r3, r3, #22
  402d7a:	d51f      	bpl.n	402dbc <bus_fault.constprop.0+0xa0>
		PR_FAULT_INFO("  Precise data bus error");
  402d7c:	4b2a      	ldr	r3, [pc, #168]	; (402e28 <bus_fault.constprop.0+0x10c>)
  402d7e:	aa05      	add	r2, sp, #20
  402d80:	4825      	ldr	r0, [pc, #148]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402d82:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402d86:	9306      	str	r3, [sp, #24]
  402d88:	2302      	movs	r3, #2
  402d8a:	9301      	str	r3, [sp, #4]
  402d8c:	9305      	str	r3, [sp, #20]
  402d8e:	f003 fbd3 	bl	406538 <z_log_msg2_static_create.constprop.0>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
  402d92:	6ba3      	ldr	r3, [r4, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
  402d94:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  402d96:	0410      	lsls	r0, r2, #16
  402d98:	d510      	bpl.n	402dbc <bus_fault.constprop.0+0xa0>
			PR_EXC("  BFAR Address: 0x%x", bfar);
  402d9a:	4a24      	ldr	r2, [pc, #144]	; (402e2c <bus_fault.constprop.0+0x110>)
  402d9c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  402da0:	481d      	ldr	r0, [pc, #116]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402da2:	e9cd 2306 	strd	r2, r3, [sp, #24]
  402da6:	2303      	movs	r3, #3
  402da8:	aa05      	add	r2, sp, #20
  402daa:	9301      	str	r3, [sp, #4]
  402dac:	9305      	str	r3, [sp, #20]
  402dae:	f003 fbc3 	bl	406538 <z_log_msg2_static_create.constprop.0>
			if (from_hard_fault != 0) {
  402db2:	b11e      	cbz	r6, 402dbc <bus_fault.constprop.0+0xa0>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
  402db4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402db6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  402dba:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
  402dbc:	4b17      	ldr	r3, [pc, #92]	; (402e1c <bus_fault.constprop.0+0x100>)
  402dbe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402dc0:	0559      	lsls	r1, r3, #21
  402dc2:	d50a      	bpl.n	402dda <bus_fault.constprop.0+0xbe>
		PR_FAULT_INFO("  Imprecise data bus error");
  402dc4:	4b1a      	ldr	r3, [pc, #104]	; (402e30 <bus_fault.constprop.0+0x114>)
  402dc6:	aa05      	add	r2, sp, #20
  402dc8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402dcc:	4812      	ldr	r0, [pc, #72]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402dce:	9306      	str	r3, [sp, #24]
  402dd0:	2302      	movs	r3, #2
  402dd2:	9301      	str	r3, [sp, #4]
  402dd4:	9305      	str	r3, [sp, #20]
  402dd6:	f003 fbaf 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
  402dda:	4b10      	ldr	r3, [pc, #64]	; (402e1c <bus_fault.constprop.0+0x100>)
  402ddc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  402dde:	05d2      	lsls	r2, r2, #23
  402de0:	d513      	bpl.n	402e0a <bus_fault.constprop.0+0xee>
		PR_FAULT_INFO("  Instruction bus error");
  402de2:	4b14      	ldr	r3, [pc, #80]	; (402e34 <bus_fault.constprop.0+0x118>)
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
  402de4:	9306      	str	r3, [sp, #24]
  402de6:	2302      	movs	r3, #2
  402de8:	aa05      	add	r2, sp, #20
  402dea:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402dee:	480a      	ldr	r0, [pc, #40]	; (402e18 <bus_fault.constprop.0+0xfc>)
  402df0:	9301      	str	r3, [sp, #4]
  402df2:	9305      	str	r3, [sp, #20]
  402df4:	f003 fba0 	bl	406538 <z_log_msg2_static_create.constprop.0>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
  402df8:	4a08      	ldr	r2, [pc, #32]	; (402e1c <bus_fault.constprop.0+0x100>)

	*recoverable = memory_fault_recoverable(esf, true);
  402dfa:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
  402dfc:	6a93      	ldr	r3, [r2, #40]	; 0x28
  402dfe:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
  402e02:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
  402e04:	7028      	strb	r0, [r5, #0]

	return reason;
}
  402e06:	b008      	add	sp, #32
  402e08:	bd70      	pop	{r4, r5, r6, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
  402e0a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402e0c:	049b      	lsls	r3, r3, #18
  402e0e:	d5f3      	bpl.n	402df8 <bus_fault.constprop.0+0xdc>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
  402e10:	4b09      	ldr	r3, [pc, #36]	; (402e38 <bus_fault.constprop.0+0x11c>)
  402e12:	e7e7      	b.n	402de4 <bus_fault.constprop.0+0xc8>
  402e14:	00407747 	.word	0x00407747
  402e18:	004072a0 	.word	0x004072a0
  402e1c:	e000ed00 	.word	0xe000ed00
  402e20:	0040775d 	.word	0x0040775d
  402e24:	0040776e 	.word	0x0040776e
  402e28:	00407781 	.word	0x00407781
  402e2c:	0040779a 	.word	0x0040779a
  402e30:	004077af 	.word	0x004077af
  402e34:	004077ca 	.word	0x004077ca
  402e38:	004077e2 	.word	0x004077e2

00402e3c <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
  402e3c:	b510      	push	{r4, lr}
  402e3e:	b088      	sub	sp, #32
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
  402e40:	4b36      	ldr	r3, [pc, #216]	; (402f1c <usage_fault.constprop.0+0xe0>)
  402e42:	2402      	movs	r4, #2
  402e44:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402e48:	aa05      	add	r2, sp, #20
  402e4a:	4835      	ldr	r0, [pc, #212]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402e4c:	9306      	str	r3, [sp, #24]
  402e4e:	9401      	str	r4, [sp, #4]
  402e50:	9405      	str	r4, [sp, #20]
  402e52:	f003 fb71 	bl	406538 <z_log_msg2_static_create.constprop.0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
  402e56:	4b33      	ldr	r3, [pc, #204]	; (402f24 <usage_fault.constprop.0+0xe8>)
  402e58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402e5a:	019b      	lsls	r3, r3, #6
  402e5c:	d509      	bpl.n	402e72 <usage_fault.constprop.0+0x36>
		PR_FAULT_INFO("  Division by zero");
  402e5e:	4b32      	ldr	r3, [pc, #200]	; (402f28 <usage_fault.constprop.0+0xec>)
  402e60:	aa05      	add	r2, sp, #20
  402e62:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402e66:	482e      	ldr	r0, [pc, #184]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402e68:	9306      	str	r3, [sp, #24]
  402e6a:	9401      	str	r4, [sp, #4]
  402e6c:	9405      	str	r4, [sp, #20]
  402e6e:	f003 fb63 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
  402e72:	4b2c      	ldr	r3, [pc, #176]	; (402f24 <usage_fault.constprop.0+0xe8>)
  402e74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402e76:	01dc      	lsls	r4, r3, #7
  402e78:	d50a      	bpl.n	402e90 <usage_fault.constprop.0+0x54>
		PR_FAULT_INFO("  Unaligned memory access");
  402e7a:	4b2c      	ldr	r3, [pc, #176]	; (402f2c <usage_fault.constprop.0+0xf0>)
  402e7c:	aa05      	add	r2, sp, #20
  402e7e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402e82:	4827      	ldr	r0, [pc, #156]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402e84:	9306      	str	r3, [sp, #24]
  402e86:	2302      	movs	r3, #2
  402e88:	9301      	str	r3, [sp, #4]
  402e8a:	9305      	str	r3, [sp, #20]
  402e8c:	f003 fb54 	bl	406538 <z_log_msg2_static_create.constprop.0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
  402e90:	4b24      	ldr	r3, [pc, #144]	; (402f24 <usage_fault.constprop.0+0xe8>)
  402e92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402e94:	0318      	lsls	r0, r3, #12
  402e96:	d50a      	bpl.n	402eae <usage_fault.constprop.0+0x72>
		PR_FAULT_INFO("  No coprocessor instructions");
  402e98:	4b25      	ldr	r3, [pc, #148]	; (402f30 <usage_fault.constprop.0+0xf4>)
  402e9a:	aa05      	add	r2, sp, #20
  402e9c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402ea0:	481f      	ldr	r0, [pc, #124]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402ea2:	9306      	str	r3, [sp, #24]
  402ea4:	2302      	movs	r3, #2
  402ea6:	9301      	str	r3, [sp, #4]
  402ea8:	9305      	str	r3, [sp, #20]
  402eaa:	f003 fb45 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
  402eae:	4b1d      	ldr	r3, [pc, #116]	; (402f24 <usage_fault.constprop.0+0xe8>)
  402eb0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402eb2:	0359      	lsls	r1, r3, #13
  402eb4:	d50a      	bpl.n	402ecc <usage_fault.constprop.0+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
  402eb6:	4b1f      	ldr	r3, [pc, #124]	; (402f34 <usage_fault.constprop.0+0xf8>)
  402eb8:	aa05      	add	r2, sp, #20
  402eba:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402ebe:	4818      	ldr	r0, [pc, #96]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402ec0:	9306      	str	r3, [sp, #24]
  402ec2:	2302      	movs	r3, #2
  402ec4:	9301      	str	r3, [sp, #4]
  402ec6:	9305      	str	r3, [sp, #20]
  402ec8:	f003 fb36 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
  402ecc:	4b15      	ldr	r3, [pc, #84]	; (402f24 <usage_fault.constprop.0+0xe8>)
  402ece:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402ed0:	039a      	lsls	r2, r3, #14
  402ed2:	d50a      	bpl.n	402eea <usage_fault.constprop.0+0xae>
		PR_FAULT_INFO("  Illegal use of the EPSR");
  402ed4:	4b18      	ldr	r3, [pc, #96]	; (402f38 <usage_fault.constprop.0+0xfc>)
  402ed6:	aa05      	add	r2, sp, #20
  402ed8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402edc:	4810      	ldr	r0, [pc, #64]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402ede:	9306      	str	r3, [sp, #24]
  402ee0:	2302      	movs	r3, #2
  402ee2:	9301      	str	r3, [sp, #4]
  402ee4:	9305      	str	r3, [sp, #20]
  402ee6:	f003 fb27 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
  402eea:	4b0e      	ldr	r3, [pc, #56]	; (402f24 <usage_fault.constprop.0+0xe8>)
  402eec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402eee:	03db      	lsls	r3, r3, #15
  402ef0:	d50a      	bpl.n	402f08 <usage_fault.constprop.0+0xcc>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
  402ef2:	4b12      	ldr	r3, [pc, #72]	; (402f3c <usage_fault.constprop.0+0x100>)
  402ef4:	aa05      	add	r2, sp, #20
  402ef6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402efa:	4809      	ldr	r0, [pc, #36]	; (402f20 <usage_fault.constprop.0+0xe4>)
  402efc:	9306      	str	r3, [sp, #24]
  402efe:	2302      	movs	r3, #2
  402f00:	9301      	str	r3, [sp, #4]
  402f02:	9305      	str	r3, [sp, #20]
  402f04:	f003 fb18 	bl	406538 <z_log_msg2_static_create.constprop.0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
  402f08:	4a06      	ldr	r2, [pc, #24]	; (402f24 <usage_fault.constprop.0+0xe8>)

	return reason;
}
  402f0a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
  402f0c:	6a93      	ldr	r3, [r2, #40]	; 0x28
  402f0e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
  402f12:	ea6f 4313 	mvn.w	r3, r3, lsr #16
  402f16:	6293      	str	r3, [r2, #40]	; 0x28
}
  402f18:	b008      	add	sp, #32
  402f1a:	bd10      	pop	{r4, pc}
  402f1c:	00407811 	.word	0x00407811
  402f20:	004072a0 	.word	0x004072a0
  402f24:	e000ed00 	.word	0xe000ed00
  402f28:	00407829 	.word	0x00407829
  402f2c:	0040783c 	.word	0x0040783c
  402f30:	00407856 	.word	0x00407856
  402f34:	00407874 	.word	0x00407874
  402f38:	00407899 	.word	0x00407899
  402f3c:	004078b3 	.word	0x004078b3

00402f40 <mem_manage_fault>:
{
  402f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402f44:	b088      	sub	sp, #32
	PR_FAULT_INFO("***** MPU FAULT *****");
  402f46:	4b48      	ldr	r3, [pc, #288]	; (403068 <mem_manage_fault+0x128>)
  402f48:	2402      	movs	r4, #2
{
  402f4a:	4607      	mov	r7, r0
  402f4c:	4688      	mov	r8, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
  402f4e:	4847      	ldr	r0, [pc, #284]	; (40306c <mem_manage_fault+0x12c>)
{
  402f50:	4615      	mov	r5, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
  402f52:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402f56:	aa05      	add	r2, sp, #20
  402f58:	9306      	str	r3, [sp, #24]
  402f5a:	9401      	str	r4, [sp, #4]
  402f5c:	9405      	str	r4, [sp, #20]
  402f5e:	f003 faeb 	bl	406538 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
  402f62:	4b43      	ldr	r3, [pc, #268]	; (403070 <mem_manage_fault+0x130>)
  402f64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402f66:	06d8      	lsls	r0, r3, #27
  402f68:	d509      	bpl.n	402f7e <mem_manage_fault+0x3e>
		PR_FAULT_INFO("  Stacking error (context area might be"
  402f6a:	4b42      	ldr	r3, [pc, #264]	; (403074 <mem_manage_fault+0x134>)
  402f6c:	aa05      	add	r2, sp, #20
  402f6e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402f72:	483e      	ldr	r0, [pc, #248]	; (40306c <mem_manage_fault+0x12c>)
  402f74:	9306      	str	r3, [sp, #24]
  402f76:	9401      	str	r4, [sp, #4]
  402f78:	9405      	str	r4, [sp, #20]
  402f7a:	f003 fadd 	bl	406538 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
  402f7e:	4b3c      	ldr	r3, [pc, #240]	; (403070 <mem_manage_fault+0x130>)
  402f80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402f82:	0719      	lsls	r1, r3, #28
  402f84:	d50a      	bpl.n	402f9c <mem_manage_fault+0x5c>
		PR_FAULT_INFO("  Unstacking error");
  402f86:	4b3c      	ldr	r3, [pc, #240]	; (403078 <mem_manage_fault+0x138>)
  402f88:	aa05      	add	r2, sp, #20
  402f8a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402f8e:	4837      	ldr	r0, [pc, #220]	; (40306c <mem_manage_fault+0x12c>)
  402f90:	9306      	str	r3, [sp, #24]
  402f92:	2302      	movs	r3, #2
  402f94:	9301      	str	r3, [sp, #4]
  402f96:	9305      	str	r3, [sp, #20]
  402f98:	f003 face 	bl	406538 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
  402f9c:	4c34      	ldr	r4, [pc, #208]	; (403070 <mem_manage_fault+0x130>)
  402f9e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402fa0:	079a      	lsls	r2, r3, #30
  402fa2:	d431      	bmi.n	403008 <mem_manage_fault+0xc8>
	uint32_t mmfar = -EINVAL;
  402fa4:	f06f 0615 	mvn.w	r6, #21
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
  402fa8:	4b31      	ldr	r3, [pc, #196]	; (403070 <mem_manage_fault+0x130>)
  402faa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402fac:	07dc      	lsls	r4, r3, #31
  402fae:	d50a      	bpl.n	402fc6 <mem_manage_fault+0x86>
		PR_FAULT_INFO("  Instruction Access Violation");
  402fb0:	4b32      	ldr	r3, [pc, #200]	; (40307c <mem_manage_fault+0x13c>)
  402fb2:	aa05      	add	r2, sp, #20
  402fb4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402fb8:	482c      	ldr	r0, [pc, #176]	; (40306c <mem_manage_fault+0x12c>)
  402fba:	9306      	str	r3, [sp, #24]
  402fbc:	2302      	movs	r3, #2
  402fbe:	9301      	str	r3, [sp, #4]
  402fc0:	9305      	str	r3, [sp, #20]
  402fc2:	f003 fab9 	bl	406538 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
  402fc6:	4b2a      	ldr	r3, [pc, #168]	; (403070 <mem_manage_fault+0x130>)
  402fc8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402fca:	0698      	lsls	r0, r3, #26
  402fcc:	d50a      	bpl.n	402fe4 <mem_manage_fault+0xa4>
		PR_FAULT_INFO(
  402fce:	4b2c      	ldr	r3, [pc, #176]	; (403080 <mem_manage_fault+0x140>)
  402fd0:	aa05      	add	r2, sp, #20
  402fd2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  402fd6:	4825      	ldr	r0, [pc, #148]	; (40306c <mem_manage_fault+0x12c>)
  402fd8:	9306      	str	r3, [sp, #24]
  402fda:	2302      	movs	r3, #2
  402fdc:	9301      	str	r3, [sp, #4]
  402fde:	9305      	str	r3, [sp, #20]
  402fe0:	f003 faaa 	bl	406538 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
  402fe4:	4b22      	ldr	r3, [pc, #136]	; (403070 <mem_manage_fault+0x130>)
  402fe6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  402fe8:	06d1      	lsls	r1, r2, #27
  402fea:	d430      	bmi.n	40304e <mem_manage_fault+0x10e>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
  402fec:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
  402fee:	0792      	lsls	r2, r2, #30
  402ff0:	d42d      	bmi.n	40304e <mem_manage_fault+0x10e>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
  402ff2:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
  402ff4:	4a1e      	ldr	r2, [pc, #120]	; (403070 <mem_manage_fault+0x130>)
  402ff6:	6a93      	ldr	r3, [r2, #40]	; 0x28
  402ff8:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
  402ffc:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
  402ffe:	2300      	movs	r3, #0
  403000:	702b      	strb	r3, [r5, #0]
}
  403002:	b008      	add	sp, #32
  403004:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PR_FAULT_INFO("  Data Access Violation");
  403008:	4b1e      	ldr	r3, [pc, #120]	; (403084 <mem_manage_fault+0x144>)
  40300a:	aa05      	add	r2, sp, #20
  40300c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403010:	4816      	ldr	r0, [pc, #88]	; (40306c <mem_manage_fault+0x12c>)
  403012:	9306      	str	r3, [sp, #24]
  403014:	2302      	movs	r3, #2
  403016:	9301      	str	r3, [sp, #4]
  403018:	9305      	str	r3, [sp, #20]
  40301a:	f003 fa8d 	bl	406538 <z_log_msg2_static_create.constprop.0>
		uint32_t temp = SCB->MMFAR;
  40301e:	6b66      	ldr	r6, [r4, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
  403020:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  403022:	061b      	lsls	r3, r3, #24
  403024:	d5be      	bpl.n	402fa4 <mem_manage_fault+0x64>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
  403026:	4b18      	ldr	r3, [pc, #96]	; (403088 <mem_manage_fault+0x148>)
  403028:	aa05      	add	r2, sp, #20
  40302a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  40302e:	480f      	ldr	r0, [pc, #60]	; (40306c <mem_manage_fault+0x12c>)
  403030:	e9cd 3606 	strd	r3, r6, [sp, #24]
  403034:	2303      	movs	r3, #3
  403036:	9301      	str	r3, [sp, #4]
  403038:	9305      	str	r3, [sp, #20]
  40303a:	f003 fa7d 	bl	406538 <z_log_msg2_static_create.constprop.0>
			if (from_hard_fault != 0) {
  40303e:	f1b8 0f00 	cmp.w	r8, #0
  403042:	d0b1      	beq.n	402fa8 <mem_manage_fault+0x68>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
  403044:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  403046:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  40304a:	62a3      	str	r3, [r4, #40]	; 0x28
  40304c:	e7ac      	b.n	402fa8 <mem_manage_fault+0x68>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
  40304e:	685b      	ldr	r3, [r3, #4]
  403050:	051b      	lsls	r3, r3, #20
  403052:	d5ce      	bpl.n	402ff2 <mem_manage_fault+0xb2>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
  403054:	4639      	mov	r1, r7
  403056:	4630      	mov	r0, r6
  403058:	f7ff fe12 	bl	402c80 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
  40305c:	2800      	cmp	r0, #0
  40305e:	d0c8      	beq.n	402ff2 <mem_manage_fault+0xb2>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  403060:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
  403064:	2002      	movs	r0, #2
  403066:	e7c5      	b.n	402ff4 <mem_manage_fault+0xb4>
  403068:	004078de 	.word	0x004078de
  40306c:	004072a0 	.word	0x004072a0
  403070:	e000ed00 	.word	0xe000ed00
  403074:	004078f4 	.word	0x004078f4
  403078:	0040776e 	.word	0x0040776e
  40307c:	00407955 	.word	0x00407955
  403080:	004077e2 	.word	0x004077e2
  403084:	00407927 	.word	0x00407927
  403088:	0040793f 	.word	0x0040793f

0040308c <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
  40308c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
  40308e:	ab0a      	add	r3, sp, #40	; 0x28
  403090:	9305      	str	r3, [sp, #20]
		arch_syscall_invoke6(*(uintptr_t *)&domain_id, *(uintptr_t *)&source, *(uintptr_t *)&level, *(uintptr_t *)&data, *(uintptr_t *)&dlen, (uintptr_t) &more, K_SYSCALL_Z_LOG_MSG2_RUNTIME_VCREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
  403092:	9302      	str	r3, [sp, #8]
  403094:	2201      	movs	r2, #1
  403096:	4b05      	ldr	r3, [pc, #20]	; (4030ac <z_log_msg2_runtime_create.constprop.0+0x20>)
  403098:	9301      	str	r3, [sp, #4]
  40309a:	2300      	movs	r3, #0
  40309c:	4618      	mov	r0, r3
  40309e:	9300      	str	r3, [sp, #0]
  4030a0:	f7ff fc40 	bl	402924 <z_impl_z_log_msg2_runtime_vcreate>
}
  4030a4:	b007      	add	sp, #28
  4030a6:	f85d fb04 	ldr.w	pc, [sp], #4
  4030aa:	bf00      	nop
  4030ac:	00407974 	.word	0x00407974

004030b0 <z_arm_fault>:
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
  4030b0:	4b71      	ldr	r3, [pc, #452]	; (403278 <z_arm_fault+0x1c8>)
{
  4030b2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
  4030b6:	685d      	ldr	r5, [r3, #4]
{
  4030b8:	b08f      	sub	sp, #60	; 0x3c
  4030ba:	460f      	mov	r7, r1
  4030bc:	f04f 0800 	mov.w	r8, #0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
  4030c0:	f3c5 0408 	ubfx	r4, r5, #0, #9
  4030c4:	f388 8811 	msr	BASEPRI, r8
  4030c8:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
  4030cc:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
  4030d0:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
  4030d4:	d10e      	bne.n	4030f4 <z_arm_fault+0x44>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
  4030d6:	f002 030c 	and.w	r3, r2, #12
  4030da:	2b08      	cmp	r3, #8
  4030dc:	d10c      	bne.n	4030f8 <z_arm_fault+0x48>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
  4030de:	4b67      	ldr	r3, [pc, #412]	; (40327c <z_arm_fault+0x1cc>)
  4030e0:	aa09      	add	r2, sp, #36	; 0x24
  4030e2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  4030e6:	4866      	ldr	r0, [pc, #408]	; (403280 <z_arm_fault+0x1d0>)
  4030e8:	930a      	str	r3, [sp, #40]	; 0x28
  4030ea:	2302      	movs	r3, #2
  4030ec:	9305      	str	r3, [sp, #20]
  4030ee:	9309      	str	r3, [sp, #36]	; 0x24
  4030f0:	f003 fa22 	bl	406538 <z_log_msg2_static_create.constprop.0>
		return NULL;
  4030f4:	4647      	mov	r7, r8
  4030f6:	e004      	b.n	403102 <z_arm_fault+0x52>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
  4030f8:	0712      	lsls	r2, r2, #28
  4030fa:	d402      	bmi.n	403102 <z_arm_fault+0x52>
			ptr_esf = (z_arch_esf_t *)msp;
  4030fc:	4607      	mov	r7, r0
			*nested_exc = true;
  4030fe:	f04f 0801 	mov.w	r8, #1
	*recoverable = false;
  403102:	2300      	movs	r3, #0
  403104:	f88d 3013 	strb.w	r3, [sp, #19]
	switch (fault) {
  403108:	1ee3      	subs	r3, r4, #3
  40310a:	2b09      	cmp	r3, #9
  40310c:	f200 809a 	bhi.w	403244 <z_arm_fault+0x194>
  403110:	e8df f003 	tbb	[pc, r3]
  403114:	878e8a05 	.word	0x878e8a05
  403118:	98989898 	.word	0x98989898
  40311c:	9298      	.short	0x9298
	PR_FAULT_INFO("***** HARD FAULT *****");
  40311e:	2502      	movs	r5, #2
  403120:	4b58      	ldr	r3, [pc, #352]	; (403284 <z_arm_fault+0x1d4>)
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
  403122:	4e55      	ldr	r6, [pc, #340]	; (403278 <z_arm_fault+0x1c8>)
	PR_FAULT_INFO("***** HARD FAULT *****");
  403124:	aa09      	add	r2, sp, #36	; 0x24
  403126:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  40312a:	4855      	ldr	r0, [pc, #340]	; (403280 <z_arm_fault+0x1d0>)
  40312c:	930a      	str	r3, [sp, #40]	; 0x28
	*recoverable = false;
  40312e:	f04f 0900 	mov.w	r9, #0
	PR_FAULT_INFO("***** HARD FAULT *****");
  403132:	9505      	str	r5, [sp, #20]
  403134:	9509      	str	r5, [sp, #36]	; 0x24
  403136:	f003 f9ff 	bl	406538 <z_log_msg2_static_create.constprop.0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
  40313a:	6af4      	ldr	r4, [r6, #44]	; 0x2c
	*recoverable = false;
  40313c:	f88d 9013 	strb.w	r9, [sp, #19]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
  403140:	402c      	ands	r4, r5
  403142:	d00b      	beq.n	40315c <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
  403144:	4b50      	ldr	r3, [pc, #320]	; (403288 <z_arm_fault+0x1d8>)
  403146:	9505      	str	r5, [sp, #20]
  403148:	930a      	str	r3, [sp, #40]	; 0x28
  40314a:	9509      	str	r5, [sp, #36]	; 0x24
	PR_FAULT_INFO(
  40314c:	aa09      	add	r2, sp, #36	; 0x24
  40314e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403152:	484b      	ldr	r0, [pc, #300]	; (403280 <z_arm_fault+0x1d0>)
	uint32_t reason = K_ERR_CPU_EXCEPTION;
  403154:	2400      	movs	r4, #0
	PR_FAULT_INFO(
  403156:	f003 f9ef 	bl	406538 <z_log_msg2_static_create.constprop.0>
}
  40315a:	e00c      	b.n	403176 <z_arm_fault+0xc6>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
  40315c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  40315e:	2b00      	cmp	r3, #0
  403160:	da24      	bge.n	4031ac <z_arm_fault+0xfc>
		PR_EXC("  Debug event");
  403162:	4b4a      	ldr	r3, [pc, #296]	; (40328c <z_arm_fault+0x1dc>)
  403164:	aa09      	add	r2, sp, #36	; 0x24
  403166:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  40316a:	4845      	ldr	r0, [pc, #276]	; (403280 <z_arm_fault+0x1d0>)
  40316c:	930a      	str	r3, [sp, #40]	; 0x28
  40316e:	9505      	str	r5, [sp, #20]
  403170:	9509      	str	r5, [sp, #36]	; 0x24
  403172:	f003 f9e1 	bl	406538 <z_log_msg2_static_create.constprop.0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
  403176:	f89d 3013 	ldrb.w	r3, [sp, #19]
  40317a:	b9a3      	cbnz	r3, 4031a6 <z_arm_fault+0xf6>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
  40317c:	2220      	movs	r2, #32
  40317e:	4639      	mov	r1, r7
  403180:	a806      	add	r0, sp, #24
  403182:	f003 f9ec 	bl	40655e <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
  403186:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  403188:	f1b8 0f00 	cmp.w	r8, #0
  40318c:	d06f      	beq.n	40326e <z_arm_fault+0x1be>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
  40318e:	f3c3 0208 	ubfx	r2, r3, #0, #9
  403192:	b922      	cbnz	r2, 40319e <z_arm_fault+0xee>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
  403194:	ea6f 2353 	mvn.w	r3, r3, lsr #9
  403198:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
  40319c:	930d      	str	r3, [sp, #52]	; 0x34
	}

	z_arm_fatal_error(reason, &esf_copy);
  40319e:	a906      	add	r1, sp, #24
  4031a0:	4620      	mov	r0, r4
  4031a2:	f7ff fc4f 	bl	402a44 <z_arm_fatal_error>
}
  4031a6:	b00f      	add	sp, #60	; 0x3c
  4031a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
  4031ac:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  4031ae:	005b      	lsls	r3, r3, #1
  4031b0:	d5e1      	bpl.n	403176 <z_arm_fault+0xc6>
		PR_EXC("  Fault escalation (see below)");
  4031b2:	4b37      	ldr	r3, [pc, #220]	; (403290 <z_arm_fault+0x1e0>)
  4031b4:	aa09      	add	r2, sp, #36	; 0x24
  4031b6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  4031ba:	4831      	ldr	r0, [pc, #196]	; (403280 <z_arm_fault+0x1d0>)
  4031bc:	930a      	str	r3, [sp, #40]	; 0x28
  4031be:	9505      	str	r5, [sp, #20]
  4031c0:	9509      	str	r5, [sp, #36]	; 0x24
  4031c2:	f003 f9b9 	bl	406538 <z_log_msg2_static_create.constprop.0>
	uint16_t fault_insn = *(ret_addr - 1);
  4031c6:	69bb      	ldr	r3, [r7, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
  4031c8:	f833 2c02 	ldrh.w	r2, [r3, #-2]
  4031cc:	f64d 7302 	movw	r3, #57090	; 0xdf02
  4031d0:	429a      	cmp	r2, r3
  4031d2:	d00a      	beq.n	4031ea <z_arm_fault+0x13a>
		} else if (SCB_MMFSR != 0) {
  4031d4:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
  4031d8:	b1b3      	cbz	r3, 403208 <z_arm_fault+0x158>
			reason = mem_manage_fault(esf, 1, recoverable);
  4031da:	f10d 0213 	add.w	r2, sp, #19
  4031de:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
  4031e0:	4638      	mov	r0, r7
  4031e2:	f7ff fead 	bl	402f40 <mem_manage_fault>
  4031e6:	4604      	mov	r4, r0
		break;
  4031e8:	e7c5      	b.n	403176 <z_arm_fault+0xc6>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
  4031ea:	683b      	ldr	r3, [r7, #0]
  4031ec:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  4031f0:	4a28      	ldr	r2, [pc, #160]	; (403294 <z_arm_fault+0x1e4>)
  4031f2:	4823      	ldr	r0, [pc, #140]	; (403280 <z_arm_fault+0x1d0>)
  4031f4:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  4031f8:	2303      	movs	r3, #3
  4031fa:	aa09      	add	r2, sp, #36	; 0x24
  4031fc:	9305      	str	r3, [sp, #20]
  4031fe:	9309      	str	r3, [sp, #36]	; 0x24
  403200:	f003 f99a 	bl	406538 <z_log_msg2_static_create.constprop.0>
			reason = esf->basic.r0;
  403204:	683c      	ldr	r4, [r7, #0]
  403206:	e7b6      	b.n	403176 <z_arm_fault+0xc6>
		} else if (SCB_BFSR != 0) {
  403208:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
  40320c:	b12b      	cbz	r3, 40321a <z_arm_fault+0x16a>
			reason = bus_fault(esf, 1, recoverable);
  40320e:	f10d 0113 	add.w	r1, sp, #19
  403212:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
  403214:	f7ff fd82 	bl	402d1c <bus_fault.constprop.0>
  403218:	e7e5      	b.n	4031e6 <z_arm_fault+0x136>
		} else if (SCB_UFSR != 0) {
  40321a:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
  40321c:	b29b      	uxth	r3, r3
  40321e:	2b00      	cmp	r3, #0
  403220:	d0a9      	beq.n	403176 <z_arm_fault+0xc6>
		reason = usage_fault(esf);
  403222:	f7ff fe0b 	bl	402e3c <usage_fault.constprop.0>
  403226:	e7de      	b.n	4031e6 <z_arm_fault+0x136>
		reason = mem_manage_fault(esf, 0, recoverable);
  403228:	f10d 0213 	add.w	r2, sp, #19
  40322c:	2100      	movs	r1, #0
  40322e:	e7d7      	b.n	4031e0 <z_arm_fault+0x130>
		reason = bus_fault(esf, 0, recoverable);
  403230:	f10d 0113 	add.w	r1, sp, #19
  403234:	2000      	movs	r0, #0
  403236:	e7ed      	b.n	403214 <z_arm_fault+0x164>
	PR_FAULT_INFO(
  403238:	4b17      	ldr	r3, [pc, #92]	; (403298 <z_arm_fault+0x1e8>)
  40323a:	930a      	str	r3, [sp, #40]	; 0x28
  40323c:	2302      	movs	r3, #2
  40323e:	9305      	str	r3, [sp, #20]
  403240:	9309      	str	r3, [sp, #36]	; 0x24
  403242:	e783      	b.n	40314c <z_arm_fault+0x9c>
	PR_FAULT_INFO("***** %s %d) *****",
  403244:	f415 7ff8 	tst.w	r5, #496	; 0x1f0
  403248:	4a14      	ldr	r2, [pc, #80]	; (40329c <z_arm_fault+0x1ec>)
  40324a:	4b15      	ldr	r3, [pc, #84]	; (4032a0 <z_arm_fault+0x1f0>)
  40324c:	f1a4 0410 	sub.w	r4, r4, #16
  403250:	bf18      	it	ne
  403252:	4613      	movne	r3, r2
  403254:	490a      	ldr	r1, [pc, #40]	; (403280 <z_arm_fault+0x1d0>)
  403256:	2201      	movs	r2, #1
  403258:	e9cd 3402 	strd	r3, r4, [sp, #8]
  40325c:	2400      	movs	r4, #0
  40325e:	4b11      	ldr	r3, [pc, #68]	; (4032a4 <z_arm_fault+0x1f4>)
  403260:	4620      	mov	r0, r4
  403262:	9301      	str	r3, [sp, #4]
  403264:	9400      	str	r4, [sp, #0]
  403266:	4623      	mov	r3, r4
  403268:	f7ff ff10 	bl	40308c <z_log_msg2_runtime_create.constprop.0>
}
  40326c:	e783      	b.n	403176 <z_arm_fault+0xc6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
  40326e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
  403272:	f023 0301 	bic.w	r3, r3, #1
  403276:	e791      	b.n	40319c <z_arm_fault+0xec>
  403278:	e000ed00 	.word	0xe000ed00
  40327c:	004079b5 	.word	0x004079b5
  403280:	004072a0 	.word	0x004072a0
  403284:	004079e0 	.word	0x004079e0
  403288:	004079f7 	.word	0x004079f7
  40328c:	00407a18 	.word	0x00407a18
  403290:	00407a26 	.word	0x00407a26
  403294:	00407a45 	.word	0x00407a45
  403298:	00407a61 	.word	0x00407a61
  40329c:	0040799c 	.word	0x0040799c
  4032a0:	00407987 	.word	0x00407987
  4032a4:	00407974 	.word	0x00407974

004032a8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
  4032a8:	4a02      	ldr	r2, [pc, #8]	; (4032b4 <z_arm_fault_init+0xc>)
  4032aa:	6953      	ldr	r3, [r2, #20]
  4032ac:	f043 0310 	orr.w	r3, r3, #16
  4032b0:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
  4032b2:	4770      	bx	lr
  4032b4:	e000ed00 	.word	0xe000ed00

004032b8 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
  4032b8:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
  4032bc:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
  4032c0:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
  4032c2:	4672      	mov	r2, lr
	bl z_arm_fault
  4032c4:	f7ff fef4 	bl	4030b0 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
  4032c8:	bd01      	pop	{r0, pc}
  4032ca:	bf00      	nop

004032cc <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
  4032cc:	2300      	movs	r3, #0
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  4032ce:	4804      	ldr	r0, [pc, #16]	; (4032e0 <z_arm_interrupt_init+0x14>)
  4032d0:	2120      	movs	r1, #32
  4032d2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
  4032d4:	3301      	adds	r3, #1
  4032d6:	2b47      	cmp	r3, #71	; 0x47
  4032d8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
  4032dc:	d1f9      	bne.n	4032d2 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
  4032de:	4770      	bx	lr
  4032e0:	e000e100 	.word	0xe000e100

004032e4 <__start>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
  4032e4:	2020      	movs	r0, #32
    msr BASEPRI, r0
  4032e6:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
  4032ea:	4808      	ldr	r0, [pc, #32]	; (40330c <__start+0x28>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
  4032ec:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
  4032f0:	1840      	adds	r0, r0, r1
    msr PSP, r0
  4032f2:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
  4032f6:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
  4032fa:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
  4032fc:	4308      	orrs	r0, r1
    msr CONTROL, r0
  4032fe:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
  403302:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
  403306:	f7ff fc2d 	bl	402b64 <z_arm_prep_c>
  40330a:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
  40330c:	204014c0 	.word	0x204014c0

00403310 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
  403310:	4b06      	ldr	r3, [pc, #24]	; (40332c <z_impl_k_thread_abort+0x1c>)
  403312:	689b      	ldr	r3, [r3, #8]
  403314:	4283      	cmp	r3, r0
  403316:	d107      	bne.n	403328 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  403318:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
  40331c:	b123      	cbz	r3, 403328 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
  40331e:	4a04      	ldr	r2, [pc, #16]	; (403330 <z_impl_k_thread_abort+0x20>)
  403320:	6853      	ldr	r3, [r2, #4]
  403322:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  403326:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
  403328:	f002 b9dc 	b.w	4056e4 <z_thread_abort>
  40332c:	20400bd4 	.word	0x20400bd4
  403330:	e000ed00 	.word	0xe000ed00

00403334 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
  403334:	4b02      	ldr	r3, [pc, #8]	; (403340 <z_arm_configure_static_mpu_regions+0xc>)
  403336:	2101      	movs	r1, #1
  403338:	4a02      	ldr	r2, [pc, #8]	; (403344 <z_arm_configure_static_mpu_regions+0x10>)
  40333a:	4803      	ldr	r0, [pc, #12]	; (403348 <z_arm_configure_static_mpu_regions+0x14>)
  40333c:	f000 b888 	b.w	403450 <arm_core_mpu_configure_static_mpu_regions>
  403340:	20460000 	.word	0x20460000
  403344:	20400000 	.word	0x20400000
  403348:	00407374 	.word	0x00407374

0040334c <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
  40334c:	6e42      	ldr	r2, [r0, #100]	; 0x64
	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
  40334e:	2120      	movs	r1, #32
	dynamic_regions[region_num].start = guard_start;
  403350:	4b04      	ldr	r3, [pc, #16]	; (403364 <z_arm_configure_dynamic_mpu_regions+0x18>)
		guard_start = thread->stack_info.start - guard_size;
  403352:	3a20      	subs	r2, #32

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
  403354:	4618      	mov	r0, r3
	dynamic_regions[region_num].start = guard_start;
  403356:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
  403358:	4a03      	ldr	r2, [pc, #12]	; (403368 <z_arm_configure_dynamic_mpu_regions+0x1c>)
  40335a:	e9c3 1201 	strd	r1, r2, [r3, #4]
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
  40335e:	2101      	movs	r1, #1
  403360:	f000 b880 	b.w	403464 <arm_core_mpu_configure_dynamic_mpu_regions>
  403364:	20400714 	.word	0x20400714
  403368:	150b0000 	.word	0x150b0000

0040336c <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
  40336c:	b5f0      	push	{r4, r5, r6, r7, lr}
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
  40336e:	2600      	movs	r6, #0
{
  403370:	b089      	sub	sp, #36	; 0x24
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
  403372:	4f28      	ldr	r7, [pc, #160]	; (403414 <mpu_configure_regions+0xa8>)
	for (i = 0; i < regions_num; i++) {
  403374:	428e      	cmp	r6, r1
  403376:	da17      	bge.n	4033a8 <mpu_configure_regions+0x3c>
		if (regions[i].size == 0U) {
  403378:	6844      	ldr	r4, [r0, #4]
  40337a:	2c00      	cmp	r4, #0
  40337c:	d046      	beq.n	40340c <mpu_configure_regions+0xa0>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
  40337e:	b1e3      	cbz	r3, 4033ba <mpu_configure_regions+0x4e>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
  403380:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
  403384:	ea14 0f0c 	tst.w	r4, ip
  403388:	d011      	beq.n	4033ae <mpu_configure_regions+0x42>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
  40338a:	4b23      	ldr	r3, [pc, #140]	; (403418 <mpu_configure_regions+0xac>)
  40338c:	e9cd 3606 	strd	r3, r6, [sp, #24]
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
  403390:	2303      	movs	r3, #3
  403392:	9301      	str	r3, [sp, #4]
  403394:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_static_create(source, desc, package, data);
  403396:	2300      	movs	r3, #0
  403398:	aa05      	add	r2, sp, #20
  40339a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  40339e:	481f      	ldr	r0, [pc, #124]	; (40341c <mpu_configure_regions+0xb0>)
  4033a0:	f003 f89b 	bl	4064da <z_impl_z_log_msg2_static_create>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
  4033a4:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
  4033a8:	4610      	mov	r0, r2
  4033aa:	b009      	add	sp, #36	; 0x24
  4033ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		&&
  4033ae:	2c1f      	cmp	r4, #31
  4033b0:	d9eb      	bls.n	40338a <mpu_configure_regions+0x1e>
		((part->start & (part->size - 1U)) == 0U);
  4033b2:	6805      	ldr	r5, [r0, #0]
		&&
  4033b4:	ea1c 0f05 	tst.w	ip, r5
  4033b8:	d1e7      	bne.n	40338a <mpu_configure_regions+0x1e>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
  4033ba:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, &regions[i]);
  4033bc:	b2d2      	uxtb	r2, r2
	region_conf.base = new_region->start;
  4033be:	6805      	ldr	r5, [r0, #0]
#if defined(CONFIG_CPU_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
  4033c0:	f8d0 c008 	ldr.w	ip, [r0, #8]
	if (size <= 32U) {
  4033c4:	d910      	bls.n	4033e8 <mpu_configure_regions+0x7c>
	if (size > (1UL << 31)) {
  4033c6:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
  4033ca:	d80f      	bhi.n	4033ec <mpu_configure_regions+0x80>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
  4033cc:	3c01      	subs	r4, #1
  4033ce:	fab4 f484 	clz	r4, r4
  4033d2:	f1c4 041f 	rsb	r4, r4, #31
  4033d6:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
  4033d8:	2a0f      	cmp	r2, #15
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
  4033da:	ea4c 0404 	orr.w	r4, ip, r4
  4033de:	d907      	bls.n	4033f0 <mpu_configure_regions+0x84>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
  4033e0:	4b0f      	ldr	r3, [pc, #60]	; (403420 <mpu_configure_regions+0xb4>)
  4033e2:	e9cd 3206 	strd	r3, r2, [sp, #24]
  4033e6:	e7d3      	b.n	403390 <mpu_configure_regions+0x24>
		return REGION_32B;
  4033e8:	2408      	movs	r4, #8
  4033ea:	e7f5      	b.n	4033d8 <mpu_configure_regions+0x6c>
		return REGION_4G;
  4033ec:	243e      	movs	r4, #62	; 0x3e
  4033ee:	e7f3      	b.n	4033d8 <mpu_configure_regions+0x6c>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
  4033f0:	f025 051f 	bic.w	r5, r5, #31
  4033f4:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
  4033f8:	f044 0401 	orr.w	r4, r4, #1
				| MPU_RBAR_VALID_Msk | index;
  4033fc:	4315      	orrs	r5, r2
		reg_index++;
  4033fe:	3201      	adds	r2, #1
  403400:	f045 0510 	orr.w	r5, r5, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
  403404:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
  403408:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
  40340c:	3601      	adds	r6, #1
  40340e:	300c      	adds	r0, #12
  403410:	e7b0      	b.n	403374 <mpu_configure_regions+0x8>
  403412:	bf00      	nop
  403414:	e000ed00 	.word	0xe000ed00
  403418:	00407a89 	.word	0x00407a89
  40341c:	00407298 	.word	0x00407298
  403420:	00407aac 	.word	0x00407aac

00403424 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
  403424:	4b04      	ldr	r3, [pc, #16]	; (403438 <arm_core_mpu_enable+0x14>)
  403426:	2205      	movs	r2, #5
  403428:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
  40342c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  403430:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
  403434:	4770      	bx	lr
  403436:	bf00      	nop
  403438:	e000ed00 	.word	0xe000ed00

0040343c <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
  40343c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
  403440:	4b02      	ldr	r3, [pc, #8]	; (40344c <arm_core_mpu_disable+0x10>)
  403442:	2200      	movs	r2, #0
  403444:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
  403448:	4770      	bx	lr
  40344a:	bf00      	nop
  40344c:	e000ed00 	.word	0xe000ed00

00403450 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
  403450:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
  403452:	4c03      	ldr	r4, [pc, #12]	; (403460 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
  403454:	2301      	movs	r3, #1
  403456:	7822      	ldrb	r2, [r4, #0]
  403458:	f7ff ff88 	bl	40336c <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
  40345c:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
  40345e:	bd10      	pop	{r4, pc}
  403460:	20400c14 	.word	0x20400c14

00403464 <arm_core_mpu_configure_dynamic_mpu_regions>:

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
  403464:	4a09      	ldr	r2, [pc, #36]	; (40348c <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
  403466:	b508      	push	{r3, lr}
  403468:	2300      	movs	r3, #0
  40346a:	7812      	ldrb	r2, [r2, #0]
  40346c:	f7ff ff7e 	bl	40336c <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
  403470:	f110 0f16 	cmn.w	r0, #22
  403474:	d003      	beq.n	40347e <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
  403476:	4b06      	ldr	r3, [pc, #24]	; (403490 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)
  MPU->RASR = 0U;
  403478:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
  40347a:	280f      	cmp	r0, #15
  40347c:	dd00      	ble.n	403480 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
  40347e:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
  403480:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
  403484:	3001      	adds	r0, #1
  MPU->RASR = 0U;
  403486:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  40348a:	e7f6      	b.n	40347a <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
  40348c:	20400c14 	.word	0x20400c14
  403490:	e000ed00 	.word	0xe000ed00

00403494 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
  403494:	4914      	ldr	r1, [pc, #80]	; (4034e8 <z_arm_mpu_init+0x54>)
  403496:	6808      	ldr	r0, [r1, #0]
  403498:	2810      	cmp	r0, #16
{
  40349a:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
  40349c:	d821      	bhi.n	4034e2 <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
  40349e:	f7ff ffcd 	bl	40343c <arm_core_mpu_disable>
  4034a2:	4c12      	ldr	r4, [pc, #72]	; (4034ec <z_arm_mpu_init+0x58>)
  4034a4:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
  4034a6:	2200      	movs	r2, #0
  4034a8:	4290      	cmp	r0, r2
  4034aa:	f101 010c 	add.w	r1, r1, #12
  4034ae:	d105      	bne.n	4034bc <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
  4034b0:	4b0f      	ldr	r3, [pc, #60]	; (4034f0 <z_arm_mpu_init+0x5c>)
  4034b2:	7018      	strb	r0, [r3, #0]
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
  4034b4:	2000      	movs	r0, #0
	arm_core_mpu_enable();
  4034b6:	f7ff ffb5 	bl	403424 <arm_core_mpu_enable>
}
  4034ba:	bd10      	pop	{r4, pc}
  4034bc:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
  4034c0:	f851 3c0c 	ldr.w	r3, [r1, #-12]
  4034c4:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
  4034c8:	4313      	orrs	r3, r2
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
  4034ca:	3201      	adds	r2, #1
  4034cc:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
  4034d0:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
  4034d4:	f851 3c04 	ldr.w	r3, [r1, #-4]
  4034d8:	f043 0301 	orr.w	r3, r3, #1
  4034dc:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
  4034e0:	e7e2      	b.n	4034a8 <z_arm_mpu_init+0x14>
		return -1;
  4034e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  4034e6:	e7e8      	b.n	4034ba <z_arm_mpu_init+0x26>
  4034e8:	00407380 	.word	0x00407380
  4034ec:	e000ed00 	.word	0xe000ed00
  4034f0:	20400c14 	.word	0x20400c14

004034f4 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
  4034f4:	4b01      	ldr	r3, [pc, #4]	; (4034fc <__stdout_hook_install+0x8>)
  4034f6:	6018      	str	r0, [r3, #0]
}
  4034f8:	4770      	bx	lr
  4034fa:	bf00      	nop
  4034fc:	2040000c 	.word	0x2040000c

00403500 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
  403500:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
  403502:	4808      	ldr	r0, [pc, #32]	; (403524 <uart_console_init+0x24>)
  403504:	4b08      	ldr	r3, [pc, #32]	; (403528 <uart_console_init+0x28>)
  403506:	6018      	str	r0, [r3, #0]
  403508:	f003 fb31 	bl	406b6e <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
  40350c:	b138      	cbz	r0, 40351e <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
  40350e:	4807      	ldr	r0, [pc, #28]	; (40352c <uart_console_init+0x2c>)
  403510:	f7ff fff0 	bl	4034f4 <__stdout_hook_install>
	__printk_hook_install(console_out);
  403514:	4805      	ldr	r0, [pc, #20]	; (40352c <uart_console_init+0x2c>)
  403516:	f7fe f959 	bl	4017cc <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
  40351a:	2000      	movs	r0, #0
}
  40351c:	bd08      	pop	{r3, pc}
		return -ENODEV;
  40351e:	f06f 0012 	mvn.w	r0, #18
  403522:	e7fb      	b.n	40351c <uart_console_init+0x1c>
  403524:	00406ff0 	.word	0x00406ff0
  403528:	20400720 	.word	0x20400720
  40352c:	00403531 	.word	0x00403531

00403530 <console_out>:
	if ('\n' == c) {
  403530:	280a      	cmp	r0, #10
{
  403532:	b538      	push	{r3, r4, r5, lr}
  403534:	4604      	mov	r4, r0
  403536:	4d07      	ldr	r5, [pc, #28]	; (403554 <console_out+0x24>)
	if ('\n' == c) {
  403538:	d104      	bne.n	403544 <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
  40353a:	6828      	ldr	r0, [r5, #0]
  40353c:	6883      	ldr	r3, [r0, #8]
  40353e:	210d      	movs	r1, #13
  403540:	685b      	ldr	r3, [r3, #4]
  403542:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
  403544:	6828      	ldr	r0, [r5, #0]
  403546:	6883      	ldr	r3, [r0, #8]
  403548:	b2e1      	uxtb	r1, r4
  40354a:	685b      	ldr	r3, [r3, #4]
  40354c:	4798      	blx	r3
}
  40354e:	4620      	mov	r0, r4
  403550:	bd38      	pop	{r3, r4, r5, pc}
  403552:	bf00      	nop
  403554:	20400720 	.word	0x20400720

00403558 <i2c_sam_twihs_configure>:
	const struct i2c_sam_twihs_dev_cfg *const dev_cfg = dev->config;
	Twihs *const twihs = dev_cfg->regs;
	uint32_t bitrate;
	int ret;

	if (!(config & I2C_MODE_MASTER)) {
  403558:	f011 0310 	ands.w	r3, r1, #16
{
  40355c:	b510      	push	{r4, lr}
  40355e:	b088      	sub	sp, #32
	if (!(config & I2C_MODE_MASTER)) {
  403560:	d10e      	bne.n	403580 <i2c_sam_twihs_configure+0x28>
		LOG_ERR("Master Mode is not enabled");
  403562:	4a27      	ldr	r2, [pc, #156]	; (403600 <i2c_sam_twihs_configure+0xa8>)
		break;
	case I2C_SPEED_FAST:
		bitrate = BUS_SPEED_FAST_HZ;
		break;
	default:
		LOG_ERR("Unsupported I2C speed value");
  403564:	9206      	str	r2, [sp, #24]
  403566:	2202      	movs	r2, #2
  403568:	9201      	str	r2, [sp, #4]
  40356a:	9205      	str	r2, [sp, #20]
  40356c:	4825      	ldr	r0, [pc, #148]	; (403604 <i2c_sam_twihs_configure+0xac>)
  40356e:	aa05      	add	r2, sp, #20
  403570:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403574:	f002 ffb1 	bl	4064da <z_impl_z_log_msg2_static_create>
		return -EIO;
  403578:	f06f 0004 	mvn.w	r0, #4

	/* Enable Master Mode */
	twihs->TWIHS_CR = TWIHS_CR_MSEN;

	return 0;
}
  40357c:	b008      	add	sp, #32
  40357e:	bd10      	pop	{r4, pc}
	if (config & I2C_ADDR_10_BITS) {
  403580:	f011 0301 	ands.w	r3, r1, #1
  403584:	d011      	beq.n	4035aa <i2c_sam_twihs_configure+0x52>
		LOG_ERR("I2C 10-bit addressing is currently not supported");
  403586:	2402      	movs	r4, #2
  403588:	4b1f      	ldr	r3, [pc, #124]	; (403608 <i2c_sam_twihs_configure+0xb0>)
  40358a:	9401      	str	r4, [sp, #4]
  40358c:	9306      	str	r3, [sp, #24]
  40358e:	9405      	str	r4, [sp, #20]
  403590:	2300      	movs	r3, #0
  403592:	aa05      	add	r2, sp, #20
  403594:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403598:	481a      	ldr	r0, [pc, #104]	; (403604 <i2c_sam_twihs_configure+0xac>)
  40359a:	f002 ff9e 	bl	4064da <z_impl_z_log_msg2_static_create>
		LOG_ERR("Please submit a patch");
  40359e:	4b1b      	ldr	r3, [pc, #108]	; (40360c <i2c_sam_twihs_configure+0xb4>)
  4035a0:	9401      	str	r4, [sp, #4]
  4035a2:	9306      	str	r3, [sp, #24]
  4035a4:	9405      	str	r4, [sp, #20]
  4035a6:	2300      	movs	r3, #0
  4035a8:	e7e0      	b.n	40356c <i2c_sam_twihs_configure+0x14>
	switch (I2C_SPEED_GET(config)) {
  4035aa:	f3c1 0142 	ubfx	r1, r1, #1, #3
  4035ae:	2901      	cmp	r1, #1
  4035b0:	d003      	beq.n	4035ba <i2c_sam_twihs_configure+0x62>
  4035b2:	2902      	cmp	r1, #2
  4035b4:	d00d      	beq.n	4035d2 <i2c_sam_twihs_configure+0x7a>
		LOG_ERR("Unsupported I2C speed value");
  4035b6:	4a16      	ldr	r2, [pc, #88]	; (403610 <i2c_sam_twihs_configure+0xb8>)
  4035b8:	e7d4      	b.n	403564 <i2c_sam_twihs_configure+0xc>
		bitrate = BUS_SPEED_STANDARD_HZ;
  4035ba:	4a16      	ldr	r2, [pc, #88]	; (403614 <i2c_sam_twihs_configure+0xbc>)
		cl_div =   ((SOC_ATMEL_SAM_MCK_FREQ_HZ / (speed * 2U)) - 3)
  4035bc:	0052      	lsls	r2, r2, #1
  4035be:	4916      	ldr	r1, [pc, #88]	; (403618 <i2c_sam_twihs_configure+0xc0>)
  4035c0:	fbb1 f1f2 	udiv	r1, r1, r2
  4035c4:	3903      	subs	r1, #3
  4035c6:	fa21 f203 	lsr.w	r2, r1, r3
		if (cl_div <= 255U) {
  4035ca:	2aff      	cmp	r2, #255	; 0xff
  4035cc:	d903      	bls.n	4035d6 <i2c_sam_twihs_configure+0x7e>
			ck_div++;
  4035ce:	3301      	adds	r3, #1
	while (!div_completed) {
  4035d0:	e7f9      	b.n	4035c6 <i2c_sam_twihs_configure+0x6e>
	switch (I2C_SPEED_GET(config)) {
  4035d2:	4a12      	ldr	r2, [pc, #72]	; (40361c <i2c_sam_twihs_configure+0xc4>)
  4035d4:	e7f2      	b.n	4035bc <i2c_sam_twihs_configure+0x64>
	if (ck_div > CKDIV_MAX) {
  4035d6:	2b07      	cmp	r3, #7
  4035d8:	d905      	bls.n	4035e6 <i2c_sam_twihs_configure+0x8e>
		LOG_ERR("Failed to configure I2C clock");
  4035da:	4b11      	ldr	r3, [pc, #68]	; (403620 <i2c_sam_twihs_configure+0xc8>)
  4035dc:	9306      	str	r3, [sp, #24]
  4035de:	2302      	movs	r3, #2
  4035e0:	9301      	str	r3, [sp, #4]
  4035e2:	9305      	str	r3, [sp, #20]
  4035e4:	e7df      	b.n	4035a6 <i2c_sam_twihs_configure+0x4e>
	Twihs *const twihs = dev_cfg->regs;
  4035e6:	6841      	ldr	r1, [r0, #4]
			    | TWIHS_CWGR_CKDIV(ck_div);
  4035e8:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
	return 0;
  4035ec:	2000      	movs	r0, #0
	Twihs *const twihs = dev_cfg->regs;
  4035ee:	6809      	ldr	r1, [r1, #0]
			    | TWIHS_CWGR_CKDIV(ck_div);
  4035f0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
	twihs->TWIHS_CR = TWIHS_CR_SVDIS;
  4035f4:	2320      	movs	r3, #32
	twihs->TWIHS_CWGR = TWIHS_CWGR_CLDIV(cl_div) | TWIHS_CWGR_CHDIV(cl_div)
  4035f6:	610a      	str	r2, [r1, #16]
	twihs->TWIHS_CR = TWIHS_CR_SVDIS;
  4035f8:	600b      	str	r3, [r1, #0]
	twihs->TWIHS_CR = TWIHS_CR_MSEN;
  4035fa:	2304      	movs	r3, #4
  4035fc:	600b      	str	r3, [r1, #0]
	return 0;
  4035fe:	e7bd      	b.n	40357c <i2c_sam_twihs_configure+0x24>
  403600:	00407b03 	.word	0x00407b03
  403604:	00407280 	.word	0x00407280
  403608:	00407b1e 	.word	0x00407b1e
  40360c:	00407b4f 	.word	0x00407b4f
  403610:	00407b65 	.word	0x00407b65
  403614:	000186a0 	.word	0x000186a0
  403618:	08f0d180 	.word	0x08f0d180
  40361c:	00061a80 	.word	0x00061a80
  403620:	00407b81 	.word	0x00407b81

00403624 <i2c_sam_twihs_initialize>:
	/* We are done */
	k_sem_give(&dev_data->sem);
}

static int i2c_sam_twihs_initialize(const struct device *dev)
{
  403624:	b5f0      	push	{r4, r5, r6, r7, lr}
	const struct i2c_sam_twihs_dev_cfg *const dev_cfg = dev->config;
  403626:	6846      	ldr	r6, [r0, #4]
{
  403628:	b08d      	sub	sp, #52	; 0x34
  40362a:	4605      	mov	r5, r0
	struct i2c_sam_twihs_dev_data *const dev_data = dev->data;
  40362c:	6907      	ldr	r7, [r0, #16]
	Twihs *const twihs = dev_cfg->regs;
	uint32_t bitrate_cfg;
	int ret;

	/* Configure interrupts */
	dev_cfg->irq_config();
  40362e:	e9d6 4300 	ldrd	r4, r3, [r6]
  403632:	4798      	blx	r3
	return z_impl_k_sem_init(sem, initial_count, limit);
  403634:	2201      	movs	r2, #1
  403636:	2100      	movs	r1, #0
  403638:	4638      	mov	r0, r7
  40363a:	f003 fae2 	bl	406c02 <z_impl_k_sem_init>

	/* Initialize semaphore */
	k_sem_init(&dev_data->sem, 0, 1);

	/* Connect pins to the peripheral */
	soc_gpio_list_configure(dev_cfg->pin_list, dev_cfg->pin_list_size);
  40363e:	7c31      	ldrb	r1, [r6, #16]
  403640:	68f0      	ldr	r0, [r6, #12]
  403642:	f002 febc 	bl	4063be <soc_gpio_list_configure>

	/* Enable module's clock */
	soc_pmc_peripheral_enable(dev_cfg->periph_id);
  403646:	7c70      	ldrb	r0, [r6, #17]
  403648:	f7fe fd7a 	bl	402140 <soc_pmc_peripheral_enable>

	/* Reset the module */
	twihs->TWIHS_CR = TWIHS_CR_SWRST;
  40364c:	2380      	movs	r3, #128	; 0x80
extern "C" {
#endif

static inline uint32_t i2c_map_dt_bitrate(uint32_t bitrate)
{
	switch (bitrate) {
  40364e:	4a27      	ldr	r2, [pc, #156]	; (4036ec <i2c_sam_twihs_initialize+0xc8>)
  403650:	6023      	str	r3, [r4, #0]

	bitrate_cfg = i2c_map_dt_bitrate(dev_cfg->bitrate);
  403652:	68b3      	ldr	r3, [r6, #8]
  403654:	4293      	cmp	r3, r2
  403656:	d033      	beq.n	4036c0 <i2c_sam_twihs_initialize+0x9c>
  403658:	d827      	bhi.n	4036aa <i2c_sam_twihs_initialize+0x86>
  40365a:	4a25      	ldr	r2, [pc, #148]	; (4036f0 <i2c_sam_twihs_initialize+0xcc>)
  40365c:	4293      	cmp	r3, r2
  40365e:	d031      	beq.n	4036c4 <i2c_sam_twihs_initialize+0xa0>
  403660:	4a24      	ldr	r2, [pc, #144]	; (4036f4 <i2c_sam_twihs_initialize+0xd0>)
  403662:	4293      	cmp	r3, r2
  403664:	d030      	beq.n	4036c8 <i2c_sam_twihs_initialize+0xa4>
		return I2C_SPEED_HIGH << I2C_SPEED_SHIFT;
	case I2C_BITRATE_ULTRA:
		return I2C_SPEED_ULTRA << I2C_SPEED_SHIFT;
	}

	LOG_ERR("Invalid I2C bit rate value");
  403666:	4b24      	ldr	r3, [pc, #144]	; (4036f8 <i2c_sam_twihs_initialize+0xd4>)
  403668:	930a      	str	r3, [sp, #40]	; 0x28
  40366a:	2302      	movs	r3, #2
  40366c:	9305      	str	r3, [sp, #20]
  40366e:	9309      	str	r3, [sp, #36]	; 0x24
  403670:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403674:	2300      	movs	r3, #0
  403676:	aa09      	add	r2, sp, #36	; 0x24
  403678:	4820      	ldr	r0, [pc, #128]	; (4036fc <i2c_sam_twihs_initialize+0xd8>)
  40367a:	f002 ff2e 	bl	4064da <z_impl_z_log_msg2_static_create>

	return 0;
  40367e:	2100      	movs	r1, #0

	ret = i2c_sam_twihs_configure(dev, I2C_MODE_MASTER | bitrate_cfg);
  403680:	f041 0110 	orr.w	r1, r1, #16
  403684:	4628      	mov	r0, r5
  403686:	f7ff ff67 	bl	403558 <i2c_sam_twihs_configure>
	if (ret < 0) {
  40368a:	1e04      	subs	r4, r0, #0
  40368c:	da20      	bge.n	4036d0 <i2c_sam_twihs_initialize+0xac>
		LOG_ERR("Failed to initialize %s device", DEV_NAME(dev));
  40368e:	682b      	ldr	r3, [r5, #0]
  403690:	2201      	movs	r2, #1
  403692:	491a      	ldr	r1, [pc, #104]	; (4036fc <i2c_sam_twihs_initialize+0xd8>)
  403694:	9302      	str	r3, [sp, #8]
  403696:	4b1a      	ldr	r3, [pc, #104]	; (403700 <i2c_sam_twihs_initialize+0xdc>)
  403698:	9301      	str	r3, [sp, #4]
  40369a:	2300      	movs	r3, #0
  40369c:	4618      	mov	r0, r3
  40369e:	9300      	str	r3, [sp, #0]
	}

	/* Enable module's IRQ */
	irq_enable(dev_cfg->irq_id);

	LOG_INF("Device %s initialized", DEV_NAME(dev));
  4036a0:	f003 f8b2 	bl	406808 <z_log_msg2_runtime_create.constprop.0>

	return 0;
}
  4036a4:	4620      	mov	r0, r4
  4036a6:	b00d      	add	sp, #52	; 0x34
  4036a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (bitrate) {
  4036aa:	4a16      	ldr	r2, [pc, #88]	; (403704 <i2c_sam_twihs_initialize+0xe0>)
  4036ac:	4293      	cmp	r3, r2
  4036ae:	d00d      	beq.n	4036cc <i2c_sam_twihs_initialize+0xa8>
  4036b0:	f502 12c3 	add.w	r2, r2, #1597440	; 0x186000
  4036b4:	f502 6220 	add.w	r2, r2, #2560	; 0xa00
  4036b8:	4293      	cmp	r3, r2
  4036ba:	d1d4      	bne.n	403666 <i2c_sam_twihs_initialize+0x42>
		return I2C_SPEED_ULTRA << I2C_SPEED_SHIFT;
  4036bc:	210a      	movs	r1, #10
  4036be:	e7df      	b.n	403680 <i2c_sam_twihs_initialize+0x5c>
		return I2C_SPEED_FAST_PLUS << I2C_SPEED_SHIFT;
  4036c0:	2106      	movs	r1, #6
  4036c2:	e7dd      	b.n	403680 <i2c_sam_twihs_initialize+0x5c>
		return I2C_SPEED_STANDARD << I2C_SPEED_SHIFT;
  4036c4:	2102      	movs	r1, #2
  4036c6:	e7db      	b.n	403680 <i2c_sam_twihs_initialize+0x5c>
	switch (bitrate) {
  4036c8:	2104      	movs	r1, #4
  4036ca:	e7d9      	b.n	403680 <i2c_sam_twihs_initialize+0x5c>
		return I2C_SPEED_HIGH << I2C_SPEED_SHIFT;
  4036cc:	2108      	movs	r1, #8
  4036ce:	e7d7      	b.n	403680 <i2c_sam_twihs_initialize+0x5c>
	irq_enable(dev_cfg->irq_id);
  4036d0:	7cb0      	ldrb	r0, [r6, #18]
	LOG_INF("Device %s initialized", DEV_NAME(dev));
  4036d2:	2400      	movs	r4, #0
	irq_enable(dev_cfg->irq_id);
  4036d4:	f7ff fa1c 	bl	402b10 <arch_irq_enable>
	LOG_INF("Device %s initialized", DEV_NAME(dev));
  4036d8:	682b      	ldr	r3, [r5, #0]
  4036da:	2203      	movs	r2, #3
  4036dc:	4907      	ldr	r1, [pc, #28]	; (4036fc <i2c_sam_twihs_initialize+0xd8>)
  4036de:	9302      	str	r3, [sp, #8]
  4036e0:	4620      	mov	r0, r4
  4036e2:	4b09      	ldr	r3, [pc, #36]	; (403708 <i2c_sam_twihs_initialize+0xe4>)
  4036e4:	9400      	str	r4, [sp, #0]
  4036e6:	9301      	str	r3, [sp, #4]
  4036e8:	4623      	mov	r3, r4
  4036ea:	e7d9      	b.n	4036a0 <i2c_sam_twihs_initialize+0x7c>
  4036ec:	000f4240 	.word	0x000f4240
  4036f0:	000186a0 	.word	0x000186a0
  4036f4:	00061a80 	.word	0x00061a80
  4036f8:	00407b9f 	.word	0x00407b9f
  4036fc:	00407280 	.word	0x00407280
  403700:	00407bba 	.word	0x00407bba
  403704:	0033e140 	.word	0x0033e140
  403708:	00407bd9 	.word	0x00407bd9

0040370c <wdt_sam_setup>:

static int wdt_sam_setup(const struct device *dev, uint8_t options)
{
	const struct wdt_sam_dev_cfg *config = dev->config;

	Wdt * const wdt = config->regs;
  40370c:	6843      	ldr	r3, [r0, #4]
	struct wdt_sam_dev_data *data = dev->data;
  40370e:	6902      	ldr	r2, [r0, #16]
{
  403710:	b510      	push	{r4, lr}
	Wdt * const wdt = config->regs;
  403712:	681c      	ldr	r4, [r3, #0]
{
  403714:	b088      	sub	sp, #32

	if (!data->timeout_valid) {
  403716:	7a13      	ldrb	r3, [r2, #8]
  403718:	b973      	cbnz	r3, 403738 <wdt_sam_setup+0x2c>
		LOG_ERR("No valid timeouts installed");
  40371a:	4a13      	ldr	r2, [pc, #76]	; (403768 <wdt_sam_setup+0x5c>)
  40371c:	9206      	str	r2, [sp, #24]
  40371e:	2202      	movs	r2, #2
  403720:	9201      	str	r2, [sp, #4]
  403722:	9205      	str	r2, [sp, #20]
  403724:	4811      	ldr	r0, [pc, #68]	; (40376c <wdt_sam_setup+0x60>)
  403726:	aa05      	add	r2, sp, #20
  403728:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  40372c:	f002 fed5 	bl	4064da <z_impl_z_log_msg2_static_create>
		return -EINVAL;
  403730:	f06f 0015 	mvn.w	r0, #21

	wdt->WDT_MR = data->mode;
	data->mode_set = true;

	return 0;
}
  403734:	b008      	add	sp, #32
  403736:	bd10      	pop	{r4, pc}
	if (data->mode_set) {
  403738:	7a53      	ldrb	r3, [r2, #9]
  40373a:	b993      	cbnz	r3, 403762 <wdt_sam_setup+0x56>
	if ((options & WDT_OPT_PAUSE_IN_SLEEP) == WDT_OPT_PAUSE_IN_SLEEP) {
  40373c:	07c8      	lsls	r0, r1, #31
	return 0;
  40373e:	f04f 0000 	mov.w	r0, #0
		data->mode |= WDT_MR_WDIDLEHLT;
  403742:	bf42      	ittt	mi
  403744:	6853      	ldrmi	r3, [r2, #4]
  403746:	f043 5300 	orrmi.w	r3, r3, #536870912	; 0x20000000
  40374a:	6053      	strmi	r3, [r2, #4]
	if ((options & WDT_OPT_PAUSE_HALTED_BY_DBG) ==
  40374c:	078b      	lsls	r3, r1, #30
		data->mode |= WDT_MR_WDDBGHLT;
  40374e:	bf42      	ittt	mi
  403750:	6853      	ldrmi	r3, [r2, #4]
  403752:	f043 5380 	orrmi.w	r3, r3, #268435456	; 0x10000000
  403756:	6053      	strmi	r3, [r2, #4]
	wdt->WDT_MR = data->mode;
  403758:	6853      	ldr	r3, [r2, #4]
  40375a:	6063      	str	r3, [r4, #4]
	data->mode_set = true;
  40375c:	2301      	movs	r3, #1
  40375e:	7253      	strb	r3, [r2, #9]
	return 0;
  403760:	e7e8      	b.n	403734 <wdt_sam_setup+0x28>
		return -EPERM;
  403762:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  403766:	e7e5      	b.n	403734 <wdt_sam_setup+0x28>
  403768:	00407c03 	.word	0x00407c03
  40376c:	004072b0 	.word	0x004072b0

00403770 <wdt_sam_convert_timeout>:
	timeout = timeout * 1000U;
  403770:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  403774:	4358      	muls	r0, r3
	min =  (SAM_PRESCALAR * 1000000) / sclk;
  403776:	4b17      	ldr	r3, [pc, #92]	; (4037d4 <wdt_sam_convert_timeout+0x64>)
  403778:	fbb3 f1f1 	udiv	r1, r3, r1
{
  40377c:	b5b0      	push	{r4, r5, r7, lr}
	if ((timeout < min) || (timeout > max)) {
  40377e:	4281      	cmp	r1, r0
{
  403780:	b082      	sub	sp, #8
	max = min * WDT_MAX_VALUE;
  403782:	ebc1 3301 	rsb	r3, r1, r1, lsl #12
{
  403786:	af00      	add	r7, sp, #0
	if ((timeout < min) || (timeout > max)) {
  403788:	d801      	bhi.n	40378e <wdt_sam_convert_timeout+0x1e>
  40378a:	4283      	cmp	r3, r0
  40378c:	d21c      	bcs.n	4037c8 <wdt_sam_convert_timeout+0x58>
		LOG_ERR("Invalid timeout value allowed range:"
  40378e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  403792:	466c      	mov	r4, sp
  403794:	b088      	sub	sp, #32
  403796:	4810      	ldr	r0, [pc, #64]	; (4037d8 <wdt_sam_convert_timeout+0x68>)
  403798:	fbb3 f3f5 	udiv	r3, r3, r5
  40379c:	466a      	mov	r2, sp
  40379e:	fbb1 f1f5 	udiv	r1, r1, r5
  4037a2:	6193      	str	r3, [r2, #24]
  4037a4:	2304      	movs	r3, #4
  4037a6:	6110      	str	r0, [r2, #16]
  4037a8:	6151      	str	r1, [r2, #20]
  4037aa:	607b      	str	r3, [r7, #4]
  4037ac:	f842 3f0c 	str.w	r3, [r2, #12]!
  4037b0:	480a      	ldr	r0, [pc, #40]	; (4037dc <wdt_sam_convert_timeout+0x6c>)
  4037b2:	2300      	movs	r3, #0
  4037b4:	f44f 5101 	mov.w	r1, #8256	; 0x2040
  4037b8:	f002 fe8f 	bl	4064da <z_impl_z_log_msg2_static_create>
		return -EINVAL;
  4037bc:	f06f 0015 	mvn.w	r0, #21
  4037c0:	46a5      	mov	sp, r4
}
  4037c2:	3708      	adds	r7, #8
  4037c4:	46bd      	mov	sp, r7
  4037c6:	bdb0      	pop	{r4, r5, r7, pc}
	return WDT_MR_WDV(timeout / min);
  4037c8:	fbb0 f0f1 	udiv	r0, r0, r1
  4037cc:	f3c0 000b 	ubfx	r0, r0, #0, #12
  4037d0:	e7f7      	b.n	4037c2 <wdt_sam_convert_timeout+0x52>
  4037d2:	bf00      	nop
  4037d4:	07a12000 	.word	0x07a12000
  4037d8:	00407c1f 	.word	0x00407c1f
  4037dc:	004072b0 	.word	0x004072b0

004037e0 <wdt_sam_install_timeout>:

static int wdt_sam_install_timeout(const struct device *dev,
				   const struct wdt_timeout_cfg *cfg)
{
  4037e0:	b570      	push	{r4, r5, r6, lr}
	uint32_t wdt_mode = 0U;
	int timeout_value;

	struct wdt_sam_dev_data *data = dev->data;
  4037e2:	6905      	ldr	r5, [r0, #16]
{
  4037e4:	b088      	sub	sp, #32
  4037e6:	460c      	mov	r4, r1

	if (data->timeout_valid) {
  4037e8:	7a2b      	ldrb	r3, [r5, #8]
  4037ea:	b17b      	cbz	r3, 40380c <wdt_sam_install_timeout+0x2c>
		LOG_ERR("No more timeouts can be installed");
  4037ec:	4b27      	ldr	r3, [pc, #156]	; (40388c <wdt_sam_install_timeout+0xac>)
  4037ee:	9306      	str	r3, [sp, #24]
  4037f0:	2302      	movs	r3, #2
  4037f2:	9301      	str	r3, [sp, #4]
  4037f4:	9305      	str	r3, [sp, #20]
  4037f6:	4826      	ldr	r0, [pc, #152]	; (403890 <wdt_sam_install_timeout+0xb0>)
  4037f8:	2300      	movs	r3, #0
  4037fa:	aa05      	add	r2, sp, #20
  4037fc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403800:	f002 fe6b 	bl	4064da <z_impl_z_log_msg2_static_create>
		return -ENOMEM;
  403804:	f06f 000b 	mvn.w	r0, #11
		     WDT_MR_WDD(timeout_value);

	data->timeout_valid = true;

	return 0;
}
  403808:	b008      	add	sp, #32
  40380a:	bd70      	pop	{r4, r5, r6, pc}
	if (cfg->window.min != 0U) {
  40380c:	680e      	ldr	r6, [r1, #0]
  40380e:	b116      	cbz	r6, 403816 <wdt_sam_install_timeout+0x36>
			return -EINVAL;
  403810:	f06f 0015 	mvn.w	r0, #21
  403814:	e7f8      	b.n	403808 <wdt_sam_install_timeout+0x28>
	timeout_value = wdt_sam_convert_timeout(cfg->window.max,
  403816:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  40381a:	6860      	ldr	r0, [r4, #4]
  40381c:	f7ff ffa8 	bl	403770 <wdt_sam_convert_timeout>
	if (timeout_value < 0) {
  403820:	2800      	cmp	r0, #0
  403822:	dbf5      	blt.n	403810 <wdt_sam_install_timeout+0x30>
	switch (cfg->flags) {
  403824:	7b23      	ldrb	r3, [r4, #12]
  403826:	b183      	cbz	r3, 40384a <wdt_sam_install_timeout+0x6a>
  403828:	2b02      	cmp	r3, #2
  40382a:	d02b      	beq.n	403884 <wdt_sam_install_timeout+0xa4>
		LOG_ERR("Unsupported watchdog config Flag\n");
  40382c:	4b19      	ldr	r3, [pc, #100]	; (403894 <wdt_sam_install_timeout+0xb4>)
  40382e:	9306      	str	r3, [sp, #24]
  403830:	2302      	movs	r3, #2
  403832:	9301      	str	r3, [sp, #4]
  403834:	9305      	str	r3, [sp, #20]
  403836:	4816      	ldr	r0, [pc, #88]	; (403890 <wdt_sam_install_timeout+0xb0>)
  403838:	4633      	mov	r3, r6
  40383a:	aa05      	add	r2, sp, #20
  40383c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403840:	f002 fe4b 	bl	4064da <z_impl_z_log_msg2_static_create>
		return -ENOTSUP;
  403844:	f06f 0085 	mvn.w	r0, #133	; 0x85
  403848:	e7de      	b.n	403808 <wdt_sam_install_timeout+0x28>
		if (cfg->callback) {
  40384a:	68a3      	ldr	r3, [r4, #8]
  40384c:	b173      	cbz	r3, 40386c <wdt_sam_install_timeout+0x8c>
			wdt_mode = WDT_MR_WDFIEN;   /* WDT fault interrupt. */
  40384e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
			data->cb = cfg->callback;
  403852:	602b      	str	r3, [r5, #0]
		     WDT_MR_WDD(timeout_value);
  403854:	4b10      	ldr	r3, [pc, #64]	; (403898 <wdt_sam_install_timeout+0xb8>)
  403856:	ea03 4300 	and.w	r3, r3, r0, lsl #16
		     WDT_MR_WDV(timeout_value) |
  40385a:	f3c0 000b 	ubfx	r0, r0, #0, #12
  40385e:	4303      	orrs	r3, r0
	return 0;
  403860:	2000      	movs	r0, #0
		     WDT_MR_WDV(timeout_value) |
  403862:	4313      	orrs	r3, r2
	data->mode = wdt_mode |
  403864:	606b      	str	r3, [r5, #4]
	data->timeout_valid = true;
  403866:	2301      	movs	r3, #1
  403868:	722b      	strb	r3, [r5, #8]
	return 0;
  40386a:	e7cd      	b.n	403808 <wdt_sam_install_timeout+0x28>
			LOG_ERR("Invalid(NULL) ISR callback passed\n");
  40386c:	4a0b      	ldr	r2, [pc, #44]	; (40389c <wdt_sam_install_timeout+0xbc>)
  40386e:	9206      	str	r2, [sp, #24]
  403870:	2202      	movs	r2, #2
  403872:	9201      	str	r2, [sp, #4]
  403874:	9205      	str	r2, [sp, #20]
  403876:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  40387a:	aa05      	add	r2, sp, #20
  40387c:	4804      	ldr	r0, [pc, #16]	; (403890 <wdt_sam_install_timeout+0xb0>)
  40387e:	f002 fe2c 	bl	4064da <z_impl_z_log_msg2_static_create>
  403882:	e7c5      	b.n	403810 <wdt_sam_install_timeout+0x30>
	switch (cfg->flags) {
  403884:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  403888:	e7e4      	b.n	403854 <wdt_sam_install_timeout+0x74>
  40388a:	bf00      	nop
  40388c:	00407c52 	.word	0x00407c52
  403890:	004072b0 	.word	0x004072b0
  403894:	00407c97 	.word	0x00407c97
  403898:	0fff0000 	.word	0x0fff0000
  40389c:	00407c74 	.word	0x00407c74

004038a0 <can_calc_timing_int>:
/* Internal function to do the actual calculation */
static int can_calc_timing_int(uint32_t core_clock, struct can_timing *res,
			       const struct can_timing *min,
			       const struct can_timing *max,
			       uint32_t bitrate, uint16_t sp)
{
  4038a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4038a4:	b085      	sub	sp, #20
	uint32_t ts = max->prop_seg + max->phase_seg1 + max->phase_seg2 +
  4038a6:	885c      	ldrh	r4, [r3, #2]
{
  4038a8:	e9cd 0201 	strd	r0, r2, [sp, #4]
	uint32_t ts = max->prop_seg + max->phase_seg1 + max->phase_seg2 +
  4038ac:	889a      	ldrh	r2, [r3, #4]
{
  4038ae:	f8bd c03c 	ldrh.w	ip, [sp, #60]	; 0x3c
	uint32_t ts = max->prop_seg + max->phase_seg1 + max->phase_seg2 +
  4038b2:	4414      	add	r4, r2
  4038b4:	88da      	ldrh	r2, [r3, #6]
		   CAN_SYNC_SEG;
	uint16_t sp_err_min = UINT16_MAX;
	int sp_err;
	struct can_timing tmp_res;

	if (sp >= 1000 ||
  4038b6:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
	uint32_t ts = max->prop_seg + max->phase_seg1 + max->phase_seg2 +
  4038ba:	4414      	add	r4, r2
  4038bc:	f104 0401 	add.w	r4, r4, #1
	if (sp >= 1000 ||
  4038c0:	d304      	bcc.n	4038cc <can_calc_timing_int+0x2c>
	    (!IS_ENABLED(CONFIG_CAN_FD_MODE) && bitrate > 1000000) ||
	     (IS_ENABLED(CONFIG_CAN_FD_MODE) && bitrate > 8000000)) {
		return -EINVAL;
  4038c2:	f06f 0015 	mvn.w	r0, #21
	if (sp_err_min) {
		LOG_DBG("SP error: %d 1/1000", sp_err_min);
	}

	return sp_err_min == UINT16_MAX ? -EINVAL : (int)sp_err_min;
}
  4038c6:	b005      	add	sp, #20
  4038c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    (!IS_ENABLED(CONFIG_CAN_FD_MODE) && bitrate > 1000000) ||
  4038cc:	4a3b      	ldr	r2, [pc, #236]	; (4039bc <can_calc_timing_int+0x11c>)
  4038ce:	980e      	ldr	r0, [sp, #56]	; 0x38
  4038d0:	4290      	cmp	r0, r2
  4038d2:	d8f6      	bhi.n	4038c2 <can_calc_timing_int+0x22>
	for (int prescaler = MAX(core_clock / (ts * bitrate), 1);
  4038d4:	4344      	muls	r4, r0
  4038d6:	9a01      	ldr	r2, [sp, #4]
	ts2 = ts - (ts * sp) / 1000;
  4038d8:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
	for (int prescaler = MAX(core_clock / (ts * bitrate), 1);
  4038dc:	fbb2 f4f4 	udiv	r4, r2, r4
  4038e0:	2c01      	cmp	r4, #1
  4038e2:	bf38      	it	cc
  4038e4:	2401      	movcc	r4, #1
  4038e6:	fb00 f804 	mul.w	r8, r0, r4
	uint16_t sp_err_min = UINT16_MAX;
  4038ea:	f64f 70ff 	movw	r0, #65535	; 0xffff
	     prescaler <= max->prescaler; ++prescaler) {
  4038ee:	891a      	ldrh	r2, [r3, #8]
	for (int prescaler = MAX(core_clock / (ts * bitrate), 1);
  4038f0:	42a2      	cmp	r2, r4
  4038f2:	da04      	bge.n	4038fe <can_calc_timing_int+0x5e>
	return sp_err_min == UINT16_MAX ? -EINVAL : (int)sp_err_min;
  4038f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4038f8:	4298      	cmp	r0, r3
  4038fa:	d1e4      	bne.n	4038c6 <can_calc_timing_int+0x26>
  4038fc:	e7e1      	b.n	4038c2 <can_calc_timing_int+0x22>
		if (core_clock % (prescaler * bitrate)) {
  4038fe:	9a01      	ldr	r2, [sp, #4]
  403900:	fbb2 f9f8 	udiv	r9, r2, r8
  403904:	fb08 2219 	mls	r2, r8, r9, r2
  403908:	bb22      	cbnz	r2, 403954 <can_calc_timing_int+0xb4>
	uint16_t ts1_max = max->phase_seg1 + max->prop_seg;
  40390a:	885a      	ldrh	r2, [r3, #2]
	ts2 = ts - (ts * sp) / 1000;
  40390c:	fa1f f789 	uxth.w	r7, r9
	uint16_t ts1_max = max->phase_seg1 + max->prop_seg;
  403910:	9203      	str	r2, [sp, #12]
  403912:	9d03      	ldr	r5, [sp, #12]
  403914:	889a      	ldrh	r2, [r3, #4]
  403916:	442a      	add	r2, r5
	uint16_t ts1_min = min->phase_seg1 + min->prop_seg;
  403918:	9d02      	ldr	r5, [sp, #8]
  40391a:	f8b5 e002 	ldrh.w	lr, [r5, #2]
	ts2 = ts - (ts * sp) / 1000;
  40391e:	fb09 f50c 	mul.w	r5, r9, ip
	uint16_t ts1_max = max->phase_seg1 + max->prop_seg;
  403922:	b292      	uxth	r2, r2
	ts2 = ts - (ts * sp) / 1000;
  403924:	fbb5 f5fa 	udiv	r5, r5, sl
  403928:	1b7d      	subs	r5, r7, r5
  40392a:	b2ae      	uxth	r6, r5
	ts2 = CLAMP(ts2, min->phase_seg2, max->phase_seg2);
  40392c:	9d02      	ldr	r5, [sp, #8]
  40392e:	f8b5 b006 	ldrh.w	fp, [r5, #6]
  403932:	455e      	cmp	r6, fp
  403934:	d912      	bls.n	40395c <can_calc_timing_int+0xbc>
  403936:	88dd      	ldrh	r5, [r3, #6]
  403938:	42b5      	cmp	r5, r6
  40393a:	bf28      	it	cs
  40393c:	4635      	movcs	r5, r6
	ts1 = ts - CAN_SYNC_SEG - ts2;
  40393e:	1e7e      	subs	r6, r7, #1
  403940:	1b76      	subs	r6, r6, r5
  403942:	b2b6      	uxth	r6, r6
	if (ts1 > ts1_max) {
  403944:	42b2      	cmp	r2, r6
  403946:	d20b      	bcs.n	403960 <can_calc_timing_int+0xc0>
		ts2 = ts - CAN_SYNC_SEG - ts1;
  403948:	43d5      	mvns	r5, r2
		if (ts2 > max->phase_seg2) {
  40394a:	88de      	ldrh	r6, [r3, #6]
		ts2 = ts - CAN_SYNC_SEG - ts1;
  40394c:	443d      	add	r5, r7
  40394e:	b2ad      	uxth	r5, r5
		if (ts2 > max->phase_seg2) {
  403950:	42ae      	cmp	r6, r5
  403952:	d20f      	bcs.n	403974 <can_calc_timing_int+0xd4>
	     prescaler <= max->prescaler; ++prescaler) {
  403954:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  403956:	3401      	adds	r4, #1
  403958:	4490      	add	r8, r2
  40395a:	e7c8      	b.n	4038ee <can_calc_timing_int+0x4e>
  40395c:	465d      	mov	r5, fp
  40395e:	e7ee      	b.n	40393e <can_calc_timing_int+0x9e>
	uint16_t ts1_min = min->phase_seg1 + min->prop_seg;
  403960:	9a02      	ldr	r2, [sp, #8]
  403962:	8892      	ldrh	r2, [r2, #4]
  403964:	4472      	add	r2, lr
  403966:	b292      	uxth	r2, r2
	} else if (ts1 < ts1_min) {
  403968:	42b2      	cmp	r2, r6
  40396a:	d925      	bls.n	4039b8 <can_calc_timing_int+0x118>
		ts2 = ts - ts1;
  40396c:	1abd      	subs	r5, r7, r2
  40396e:	b2ad      	uxth	r5, r5
		if (ts2 < min->phase_seg2) {
  403970:	45ab      	cmp	fp, r5
  403972:	d8ef      	bhi.n	403954 <can_calc_timing_int+0xb4>
	res->prop_seg = CLAMP(ts1 / 2, min->prop_seg, max->prop_seg);
  403974:	ebbe 0f52 	cmp.w	lr, r2, lsr #1
  403978:	ea4f 0652 	mov.w	r6, r2, lsr #1
  40397c:	d204      	bcs.n	403988 <can_calc_timing_int+0xe8>
  40397e:	f8dd e00c 	ldr.w	lr, [sp, #12]
  403982:	45b6      	cmp	lr, r6
  403984:	bf28      	it	cs
  403986:	46b6      	movcs	lr, r6
	sp_calc = (CAN_SYNC_SEG + ts1) * 1000 / ts;
  403988:	fb02 a60a 	mla	r6, r2, sl, sl
  40398c:	fbb6 f6f9 	udiv	r6, r6, r9
	return sp_calc > sp ? sp_calc - sp : sp - sp_calc;
  403990:	45b4      	cmp	ip, r6
  403992:	bf34      	ite	cc
  403994:	eba6 060c 	subcc.w	r6, r6, ip
  403998:	ebac 0606 	subcs.w	r6, ip, r6
		if (sp_err < sp_err_min) {
  40399c:	42b0      	cmp	r0, r6
  40399e:	d9d9      	bls.n	403954 <can_calc_timing_int+0xb4>
	res->phase_seg1 = ts1 - res->prop_seg;
  4039a0:	eba2 020e 	sub.w	r2, r2, lr
			sp_err_min = sp_err;
  4039a4:	b2b0      	uxth	r0, r6
			res->prop_seg = tmp_res.prop_seg;
  4039a6:	f8a1 e002 	strh.w	lr, [r1, #2]
			res->phase_seg1 = tmp_res.phase_seg1;
  4039aa:	808a      	strh	r2, [r1, #4]
			res->phase_seg2 = tmp_res.phase_seg2;
  4039ac:	80cd      	strh	r5, [r1, #6]
			res->prescaler = (uint16_t)prescaler;
  4039ae:	810c      	strh	r4, [r1, #8]
			if (sp_err == 0) {
  4039b0:	2e00      	cmp	r6, #0
  4039b2:	d1cf      	bne.n	403954 <can_calc_timing_int+0xb4>
  4039b4:	4630      	mov	r0, r6
  4039b6:	e786      	b.n	4038c6 <can_calc_timing_int+0x26>
  4039b8:	4632      	mov	r2, r6
  4039ba:	e7db      	b.n	403974 <can_calc_timing_int+0xd4>
  4039bc:	007a1200 	.word	0x007a1200

004039c0 <can_mcan_get_message>:

static void can_mcan_get_message(struct can_mcan_data *data,
				 volatile struct can_mcan_rx_fifo *fifo,
				 volatile uint32_t *fifo_status_reg,
				 volatile uint32_t *fifo_ack_reg)
{
  4039c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4039c4:	4604      	mov	r4, r0
  4039c6:	b09f      	sub	sp, #124	; 0x7c
  4039c8:	460f      	mov	r7, r1
  4039ca:	4615      	mov	r5, r2
  4039cc:	4698      	mov	r8, r3
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;

      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  4039ce:	f8df 9184 	ldr.w	r9, [pc, #388]	; 403b54 <can_mcan_get_message+0x194>
static inline uint8_t can_dlc_to_bytes(uint8_t dlc)
{
	static const uint8_t dlc_table[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 12,
					    16, 20, 24, 32, 48, 64};

	return dlc > 0x0F ? 64 : dlc_table[dlc];
  4039d2:	f8df a184 	ldr.w	sl, [pc, #388]	; 403b58 <can_mcan_get_message+0x198>
	can_rx_callback_t cb;
	int data_length;
	void *cb_arg;
	struct can_mcan_rx_fifo_hdr hdr;

	while ((*fifo_status_reg & CAN_MCAN_RXF0S_F0FL)) {
  4039d6:	682b      	ldr	r3, [r5, #0]
  4039d8:	065b      	lsls	r3, r3, #25
  4039da:	d102      	bne.n	4039e2 <can_mcan_get_message+0x22>
			LOG_ERR("Frame is too big");
		}

		*fifo_ack_reg = get_idx;
	}
}
  4039dc:	b01f      	add	sp, #124	; 0x7c
  4039de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		get_idx = (*fifo_status_reg & CAN_MCAN_RXF0S_F0GI) >>
  4039e2:	682e      	ldr	r6, [r5, #0]
		CACHE_INVALIDATE(&fifo[get_idx].hdr,
  4039e4:	2148      	movs	r1, #72	; 0x48
		get_idx = (*fifo_status_reg & CAN_MCAN_RXF0S_F0GI) >>
  4039e6:	f3c6 2605 	ubfx	r6, r6, #8, #6
		CACHE_INVALIDATE(&fifo[get_idx].hdr,
  4039ea:	fb01 7106 	mla	r1, r1, r6, r7
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  4039ee:	f001 031f 	and.w	r3, r1, #31
  4039f2:	460a      	mov	r2, r1
  4039f4:	3308      	adds	r3, #8
  __ASM volatile ("dsb 0xF":::"memory");
  4039f6:	f3bf 8f4f 	dsb	sy
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  4039fa:	3b20      	subs	r3, #32
  4039fc:	f8c9 225c 	str.w	r2, [r9, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
  403a00:	3220      	adds	r2, #32
        op_size -= __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
  403a02:	2b00      	cmp	r3, #0
  403a04:	dcf9      	bgt.n	4039fa <can_mcan_get_message+0x3a>
  403a06:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  403a0a:	f3bf 8f6f 	isb	sy
		memcpy32_volatile(&hdr, &fifo[get_idx].hdr,
  403a0e:	2208      	movs	r2, #8
  403a10:	a804      	add	r0, sp, #16
  403a12:	9101      	str	r1, [sp, #4]
  403a14:	f002 ffcf 	bl	4069b6 <memcpy32_volatile>
		if (hdr.xtd) {
  403a18:	9b04      	ldr	r3, [sp, #16]
  403a1a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  403a1c:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
			frame.id = hdr.ext_id;
  403a20:	9b04      	ldr	r3, [sp, #16]
		if (hdr.xtd) {
  403a22:	9901      	ldr	r1, [sp, #4]
			frame.id = hdr.ext_id;
  403a24:	bf14      	ite	ne
  403a26:	f3c3 031c 	ubfxne	r3, r3, #0, #29
			frame.id = hdr.std_id;
  403a2a:	f3c3 438a 	ubfxeq	r3, r3, #18, #11
  403a2e:	f363 021c 	bfi	r2, r3, #0, #29
		frame.fd = hdr.fdf;
  403a32:	9b05      	ldr	r3, [sp, #20]
  403a34:	920c      	str	r2, [sp, #48]	; 0x30
  403a36:	f3c3 5340 	ubfx	r3, r3, #21, #1
  403a3a:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
  403a3e:	f363 1245 	bfi	r2, r3, #5, #1
  403a42:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
		frame.rtr = hdr.rtr ? CAN_REMOTEREQUEST :
  403a46:	9a04      	ldr	r2, [sp, #16]
  403a48:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
  403a4c:	f3c2 7240 	ubfx	r2, r2, #29, #1
  403a50:	f362 1386 	bfi	r3, r2, #6, #1
  403a54:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		frame.id_type = hdr.xtd ? CAN_EXTENDED_IDENTIFIER :
  403a58:	9b04      	ldr	r3, [sp, #16]
  403a5a:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
  403a5e:	f3c3 7380 	ubfx	r3, r3, #30, #1
  403a62:	f363 10c7 	bfi	r0, r3, #7, #1
		frame.dlc = hdr.dlc;
  403a66:	9b05      	ldr	r3, [sp, #20]
		frame.id_type = hdr.xtd ? CAN_EXTENDED_IDENTIFIER :
  403a68:	f88d 0033 	strb.w	r0, [sp, #51]	; 0x33
		frame.dlc = hdr.dlc;
  403a6c:	f3c3 4003 	ubfx	r0, r3, #16, #4
		frame.brs = hdr.brs;
  403a70:	9b05      	ldr	r3, [sp, #20]
		frame.dlc = hdr.dlc;
  403a72:	4684      	mov	ip, r0
  403a74:	f88d 0034 	strb.w	r0, [sp, #52]	; 0x34
		frame.brs = hdr.brs;
  403a78:	f3c3 5300 	ubfx	r3, r3, #20, #1
  403a7c:	f89d 0035 	ldrb.w	r0, [sp, #53]	; 0x35
  403a80:	f363 0000 	bfi	r0, r3, #0, #1
		frame.timestamp = hdr.rxts;
  403a84:	9b05      	ldr	r3, [sp, #20]
		frame.brs = hdr.brs;
  403a86:	f88d 0035 	strb.w	r0, [sp, #53]	; 0x35
		frame.timestamp = hdr.rxts;
  403a8a:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
		filt_idx = hdr.fidx;
  403a8e:	9b05      	ldr	r3, [sp, #20]
		if ((hdr.xtd && data->ext_filt_rtr_mask & (1U << filt_idx) &&
  403a90:	9804      	ldr	r0, [sp, #16]
		filt_idx = hdr.fidx;
  403a92:	f3c3 6b06 	ubfx	fp, r3, #24, #7
		if ((hdr.xtd && data->ext_filt_rtr_mask & (1U << filt_idx) &&
  403a96:	0043      	lsls	r3, r0, #1
  403a98:	d50d      	bpl.n	403ab6 <can_mcan_get_message+0xf6>
  403a9a:	f894 0181 	ldrb.w	r0, [r4, #385]	; 0x181
  403a9e:	fa20 f00b 	lsr.w	r0, r0, fp
  403aa2:	07c0      	lsls	r0, r0, #31
  403aa4:	d507      	bpl.n	403ab6 <can_mcan_get_message+0xf6>
		     ((data->ext_filt_rtr >> filt_idx) & 1U) != frame.rtr) ||
  403aa6:	f894 0180 	ldrb.w	r0, [r4, #384]	; 0x180
  403aaa:	fa40 f00b 	asr.w	r0, r0, fp
  403aae:	f000 0001 	and.w	r0, r0, #1
		if ((hdr.xtd && data->ext_filt_rtr_mask & (1U << filt_idx) &&
  403ab2:	4290      	cmp	r0, r2
  403ab4:	d18f      	bne.n	4039d6 <can_mcan_get_message+0x16>
		    (data->std_filt_rtr_mask &  (1U << filt_idx) &&
  403ab6:	f04f 0e01 	mov.w	lr, #1
  403aba:	f8d4 017c 	ldr.w	r0, [r4, #380]	; 0x17c
  403abe:	fa0e fe0b 	lsl.w	lr, lr, fp
		     ((data->ext_filt_rtr >> filt_idx) & 1U) != frame.rtr) ||
  403ac2:	ea1e 0f00 	tst.w	lr, r0
  403ac6:	d008      	beq.n	403ada <can_mcan_get_message+0x11a>
		     ((data->std_filt_rtr >> filt_idx) & 1U) != frame.rtr)) {
  403ac8:	f8d4 0178 	ldr.w	r0, [r4, #376]	; 0x178
  403acc:	fa20 f00b 	lsr.w	r0, r0, fp
  403ad0:	f000 0001 	and.w	r0, r0, #1
		    (data->std_filt_rtr_mask &  (1U << filt_idx) &&
  403ad4:	4290      	cmp	r0, r2
  403ad6:	f47f af7e 	bne.w	4039d6 <can_mcan_get_message+0x16>
  403ada:	f81a 200c 	ldrb.w	r2, [sl, ip]
		if (data_length <= sizeof(frame.data)) {
  403ade:	2a40      	cmp	r2, #64	; 0x40
  403ae0:	d82c      	bhi.n	403b3c <can_mcan_get_message+0x17c>
			CACHE_INVALIDATE(fifo[get_idx].data_32,
  403ae2:	3203      	adds	r2, #3
  403ae4:	3108      	adds	r1, #8
    if ( dsize > 0 ) {
  403ae6:	f012 02fc 	ands.w	r2, r2, #252	; 0xfc
  403aea:	d00f      	beq.n	403b0c <can_mcan_get_message+0x14c>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  403aec:	f001 001f 	and.w	r0, r1, #31
  403af0:	460b      	mov	r3, r1
  403af2:	4410      	add	r0, r2
  __ASM volatile ("dsb 0xF":::"memory");
  403af4:	f3bf 8f4f 	dsb	sy
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  403af8:	3820      	subs	r0, #32
  403afa:	f8c9 325c 	str.w	r3, [r9, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
  403afe:	3320      	adds	r3, #32
      } while ( op_size > 0 );
  403b00:	2800      	cmp	r0, #0
  403b02:	dcf9      	bgt.n	403af8 <can_mcan_get_message+0x138>
  403b04:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  403b08:	f3bf 8f6f 	isb	sy
			memcpy32_volatile(frame.data_32, fifo[get_idx].data_32,
  403b0c:	a80e      	add	r0, sp, #56	; 0x38
  403b0e:	f002 ff52 	bl	4069b6 <memcpy32_volatile>
			if (frame.id_type == CAN_STANDARD_IDENTIFIER) {
  403b12:	f99d 2033 	ldrsb.w	r2, [sp, #51]	; 0x33
  403b16:	fa0f f38b 	sxth.w	r3, fp
  403b1a:	2a00      	cmp	r2, #0
  403b1c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
				cb = data->rx_cb_std[filt_idx];
  403b20:	bfab      	itete	ge
  403b22:	6d1a      	ldrge	r2, [r3, #80]	; 0x50
				cb = data->rx_cb_ext[filt_idx];
  403b24:	f8d3 20c0 	ldrlt.w	r2, [r3, #192]	; 0xc0
				cb_arg = data->cb_arg_std[filt_idx];
  403b28:	f8d3 10e0 	ldrge.w	r1, [r3, #224]	; 0xe0
				cb_arg = data->cb_arg_ext[filt_idx];
  403b2c:	f8d3 1150 	ldrlt.w	r1, [r3, #336]	; 0x150
			if (cb) {
  403b30:	b10a      	cbz	r2, 403b36 <can_mcan_get_message+0x176>
				cb(&frame, cb_arg);
  403b32:	a80c      	add	r0, sp, #48	; 0x30
  403b34:	4790      	blx	r2
		*fifo_ack_reg = get_idx;
  403b36:	f8c8 6000 	str.w	r6, [r8]
  403b3a:	e74c      	b.n	4039d6 <can_mcan_get_message+0x16>
			LOG_ERR("Frame is too big");
  403b3c:	4b07      	ldr	r3, [pc, #28]	; (403b5c <can_mcan_get_message+0x19c>)
  403b3e:	aa09      	add	r2, sp, #36	; 0x24
  403b40:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403b44:	4806      	ldr	r0, [pc, #24]	; (403b60 <can_mcan_get_message+0x1a0>)
  403b46:	930a      	str	r3, [sp, #40]	; 0x28
  403b48:	2302      	movs	r3, #2
  403b4a:	9303      	str	r3, [sp, #12]
  403b4c:	9309      	str	r3, [sp, #36]	; 0x24
  403b4e:	f002 ff3d 	bl	4069cc <z_log_msg2_static_create.constprop.0>
  403b52:	e7f0      	b.n	403b36 <can_mcan_get_message+0x176>
  403b54:	e000ed00 	.word	0xe000ed00
  403b58:	00407edc 	.word	0x00407edc
  403b5c:	00407cd7 	.word	0x00407cd7
  403b60:	00407270 	.word	0x00407270

00403b64 <can_mcan_configure_timing>:
{
  403b64:	b570      	push	{r4, r5, r6, lr}
	if (timing) {
  403b66:	b1b9      	cbz	r1, 403b98 <can_mcan_configure_timing+0x34>
		can->nbtp = (((uint32_t)timing->phase_seg1 - 1UL) & 0xFF) <<
  403b68:	888b      	ldrh	r3, [r1, #4]
			    (((uint32_t)timing->prescaler  - 1UL) & 0x1FF) <<
  403b6a:	890d      	ldrh	r5, [r1, #8]
		can->nbtp = (((uint32_t)timing->phase_seg1 - 1UL) & 0xFF) <<
  403b6c:	3b01      	subs	r3, #1
		uint32_t nbtp_sjw = can->nbtp & CAN_MCAN_NBTP_NSJW_MSK;
  403b6e:	69c4      	ldr	r4, [r0, #28]
			    (((uint32_t)timing->prescaler  - 1UL) & 0x1FF) <<
  403b70:	1e6e      	subs	r6, r5, #1
  403b72:	4d1c      	ldr	r5, [pc, #112]	; (403be4 <can_mcan_configure_timing+0x80>)
		can->nbtp = (((uint32_t)timing->phase_seg1 - 1UL) & 0xFF) <<
  403b74:	021b      	lsls	r3, r3, #8
			    (((uint32_t)timing->prescaler  - 1UL) & 0x1FF) <<
  403b76:	ea05 4506 	and.w	r5, r5, r6, lsl #16
		can->nbtp = (((uint32_t)timing->phase_seg1 - 1UL) & 0xFF) <<
  403b7a:	b29b      	uxth	r3, r3
				CAN_MCAN_NBTP_NTSEG2_POS |
  403b7c:	432b      	orrs	r3, r5
			    (((uint32_t)timing->phase_seg2 - 1UL) & 0x7F) <<
  403b7e:	88cd      	ldrh	r5, [r1, #6]
  403b80:	3d01      	subs	r5, #1
  403b82:	f005 057f 	and.w	r5, r5, #127	; 0x7f
				CAN_MCAN_NBTP_NTSEG2_POS |
  403b86:	432b      	orrs	r3, r5
		can->nbtp = (((uint32_t)timing->phase_seg1 - 1UL) & 0xFF) <<
  403b88:	61c3      	str	r3, [r0, #28]
		if (timing->sjw == CAN_SJW_NO_CHANGE) {
  403b8a:	880b      	ldrh	r3, [r1, #0]
			can->nbtp |= nbtp_sjw;
  403b8c:	69c1      	ldr	r1, [r0, #28]
		if (timing->sjw == CAN_SJW_NO_CHANGE) {
  403b8e:	b9f3      	cbnz	r3, 403bce <can_mcan_configure_timing+0x6a>
		uint32_t nbtp_sjw = can->nbtp & CAN_MCAN_NBTP_NSJW_MSK;
  403b90:	f004 437e 	and.w	r3, r4, #4261412864	; 0xfe000000
			can->nbtp |= nbtp_sjw;
  403b94:	430b      	orrs	r3, r1
			can->nbtp |= (((uint32_t)timing->sjw - 1UL) & 0x7F) <<
  403b96:	61c3      	str	r3, [r0, #28]
	if (timing_data) {
  403b98:	b1c2      	cbz	r2, 403bcc <can_mcan_configure_timing+0x68>
		can->dbtp = (((uint32_t)timing_data->phase_seg1 - 1UL) & 0x1F) <<
  403b9a:	8893      	ldrh	r3, [r2, #4]
			    (((uint32_t)timing_data->phase_seg2 - 1UL) & 0x0F) <<
  403b9c:	88d1      	ldrh	r1, [r2, #6]
		can->dbtp = (((uint32_t)timing_data->phase_seg1 - 1UL) & 0x1F) <<
  403b9e:	3b01      	subs	r3, #1
		uint32_t dbtp_sjw = can->dbtp & CAN_MCAN_DBTP_DSJW_MSK;
  403ba0:	68c4      	ldr	r4, [r0, #12]
			    (((uint32_t)timing_data->phase_seg2 - 1UL) & 0x0F) <<
  403ba2:	3901      	subs	r1, #1
		can->dbtp = (((uint32_t)timing_data->phase_seg1 - 1UL) & 0x1F) <<
  403ba4:	021b      	lsls	r3, r3, #8
			    (((uint32_t)timing_data->phase_seg2 - 1UL) & 0x0F) <<
  403ba6:	0109      	lsls	r1, r1, #4
		can->dbtp = (((uint32_t)timing_data->phase_seg1 - 1UL) & 0x1F) <<
  403ba8:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
			    (((uint32_t)timing_data->phase_seg2 - 1UL) & 0x0F) <<
  403bac:	b2c9      	uxtb	r1, r1
				CAN_MCAN_DBTP_DTSEG1_POS |
  403bae:	430b      	orrs	r3, r1
			    (((uint32_t)timing_data->prescaler  - 1UL) & 0x1F) <<
  403bb0:	8911      	ldrh	r1, [r2, #8]
  403bb2:	3901      	subs	r1, #1
  403bb4:	0409      	lsls	r1, r1, #16
  403bb6:	f401 11f8 	and.w	r1, r1, #2031616	; 0x1f0000
				CAN_MCAN_DBTP_DTSEG2_POS |
  403bba:	430b      	orrs	r3, r1
		can->dbtp = (((uint32_t)timing_data->phase_seg1 - 1UL) & 0x1F) <<
  403bbc:	60c3      	str	r3, [r0, #12]
		if (timing_data->sjw == CAN_SJW_NO_CHANGE) {
  403bbe:	8813      	ldrh	r3, [r2, #0]
  403bc0:	b94b      	cbnz	r3, 403bd6 <can_mcan_configure_timing+0x72>
			can->dbtp |= dbtp_sjw;
  403bc2:	68c3      	ldr	r3, [r0, #12]
		uint32_t dbtp_sjw = can->dbtp & CAN_MCAN_DBTP_DSJW_MSK;
  403bc4:	f004 040f 	and.w	r4, r4, #15
			can->dbtp |= dbtp_sjw;
  403bc8:	431c      	orrs	r4, r3
  403bca:	60c4      	str	r4, [r0, #12]
}
  403bcc:	bd70      	pop	{r4, r5, r6, pc}
			can->nbtp |= (((uint32_t)timing->sjw - 1UL) & 0x7F) <<
  403bce:	3b01      	subs	r3, #1
  403bd0:	ea41 6343 	orr.w	r3, r1, r3, lsl #25
  403bd4:	e7df      	b.n	403b96 <can_mcan_configure_timing+0x32>
			can->dbtp |= (((uint32_t)timing_data->sjw - 1UL) & 0x0F) <<
  403bd6:	3b01      	subs	r3, #1
  403bd8:	68c2      	ldr	r2, [r0, #12]
  403bda:	f003 030f 	and.w	r3, r3, #15
  403bde:	4313      	orrs	r3, r2
  403be0:	60c3      	str	r3, [r0, #12]
}
  403be2:	e7f3      	b.n	403bcc <can_mcan_configure_timing+0x68>
  403be4:	01ff0000 	.word	0x01ff0000

00403be8 <can_mcan_set_timing>:
{
  403be8:	b570      	push	{r4, r5, r6, lr}
	struct can_mcan_reg *can = cfg->can;
  403bea:	6804      	ldr	r4, [r0, #0]
{
  403bec:	b088      	sub	sp, #32
  403bee:	4616      	mov	r6, r2
	ret = can_enter_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403bf0:	2300      	movs	r3, #0
  403bf2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403bf6:	4620      	mov	r0, r4
{
  403bf8:	460d      	mov	r5, r1
	ret = can_enter_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403bfa:	f002 feec 	bl	4069d6 <can_enter_init_mode.constprop.0>
	if (ret) {
  403bfe:	b170      	cbz	r0, 403c1e <can_mcan_set_timing+0x36>
		LOG_ERR("Failed to enter init mode");
  403c00:	4b10      	ldr	r3, [pc, #64]	; (403c44 <can_mcan_set_timing+0x5c>)
		LOG_ERR("Failed to leave init mode");
  403c02:	9306      	str	r3, [sp, #24]
  403c04:	2302      	movs	r3, #2
  403c06:	4810      	ldr	r0, [pc, #64]	; (403c48 <can_mcan_set_timing+0x60>)
  403c08:	aa05      	add	r2, sp, #20
  403c0a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403c0e:	9301      	str	r3, [sp, #4]
  403c10:	9305      	str	r3, [sp, #20]
  403c12:	f002 fedb 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		return -EIO;
  403c16:	f06f 0004 	mvn.w	r0, #4
}
  403c1a:	b008      	add	sp, #32
  403c1c:	bd70      	pop	{r4, r5, r6, pc}
	can->cccr |= CAN_MCAN_CCCR_CCE;
  403c1e:	69a3      	ldr	r3, [r4, #24]
	can_mcan_configure_timing(can, timing, timing_data);
  403c20:	4632      	mov	r2, r6
  403c22:	4629      	mov	r1, r5
  403c24:	4620      	mov	r0, r4
	can->cccr |= CAN_MCAN_CCCR_CCE;
  403c26:	f043 0302 	orr.w	r3, r3, #2
  403c2a:	61a3      	str	r3, [r4, #24]
	can_mcan_configure_timing(can, timing, timing_data);
  403c2c:	f7ff ff9a 	bl	403b64 <can_mcan_configure_timing>
	ret = can_leave_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403c30:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403c34:	2300      	movs	r3, #0
  403c36:	f002 feef 	bl	406a18 <can_leave_init_mode.constprop.0>
	if (ret) {
  403c3a:	2800      	cmp	r0, #0
  403c3c:	d0ed      	beq.n	403c1a <can_mcan_set_timing+0x32>
		LOG_ERR("Failed to leave init mode");
  403c3e:	4b03      	ldr	r3, [pc, #12]	; (403c4c <can_mcan_set_timing+0x64>)
  403c40:	e7df      	b.n	403c02 <can_mcan_set_timing+0x1a>
  403c42:	bf00      	nop
  403c44:	00407ce8 	.word	0x00407ce8
  403c48:	00407270 	.word	0x00407270
  403c4c:	00407d02 	.word	0x00407d02

00403c50 <can_mcan_set_mode>:
{
  403c50:	b530      	push	{r4, r5, lr}
	struct can_mcan_reg *can = cfg->can;
  403c52:	6804      	ldr	r4, [r0, #0]
{
  403c54:	b089      	sub	sp, #36	; 0x24
	ret = can_enter_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403c56:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403c5a:	2300      	movs	r3, #0
  403c5c:	4620      	mov	r0, r4
{
  403c5e:	460d      	mov	r5, r1
	ret = can_enter_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403c60:	f002 feb9 	bl	4069d6 <can_enter_init_mode.constprop.0>
	if (ret) {
  403c64:	b170      	cbz	r0, 403c84 <can_mcan_set_mode+0x34>
		LOG_ERR("Failed to enter init mode");
  403c66:	4b25      	ldr	r3, [pc, #148]	; (403cfc <can_mcan_set_mode+0xac>)
  403c68:	aa05      	add	r2, sp, #20
  403c6a:	4825      	ldr	r0, [pc, #148]	; (403d00 <can_mcan_set_mode+0xb0>)
  403c6c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403c70:	9306      	str	r3, [sp, #24]
  403c72:	2302      	movs	r3, #2
  403c74:	9301      	str	r3, [sp, #4]
  403c76:	9305      	str	r3, [sp, #20]
  403c78:	f002 fea8 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		return -EIO;
  403c7c:	f06f 0004 	mvn.w	r0, #4
}
  403c80:	b009      	add	sp, #36	; 0x24
  403c82:	bd30      	pop	{r4, r5, pc}
	can->cccr |= CAN_MCAN_CCCR_CCE;
  403c84:	69a3      	ldr	r3, [r4, #24]
  403c86:	f043 0302 	orr.w	r3, r3, #2
  403c8a:	61a3      	str	r3, [r4, #24]
	switch (mode) {
  403c8c:	2d03      	cmp	r5, #3
  403c8e:	d807      	bhi.n	403ca0 <can_mcan_set_mode+0x50>
  403c90:	e8df f005 	tbb	[pc, r5]
  403c94:	30231b02 	.word	0x30231b02
		can->cccr &= ~(CAN_MCAN_CCCR_TEST | CAN_MCAN_CCCR_MON);
  403c98:	69a3      	ldr	r3, [r4, #24]
  403c9a:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
		can->cccr |= CAN_MCAN_CCCR_MON;
  403c9e:	61a3      	str	r3, [r4, #24]
	ret = can_leave_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403ca0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403ca4:	2300      	movs	r3, #0
  403ca6:	4620      	mov	r0, r4
  403ca8:	f002 feb6 	bl	406a18 <can_leave_init_mode.constprop.0>
	if (ret) {
  403cac:	2800      	cmp	r0, #0
  403cae:	d0e7      	beq.n	403c80 <can_mcan_set_mode+0x30>
		LOG_ERR("Failed to leave init mode");
  403cb0:	4b14      	ldr	r3, [pc, #80]	; (403d04 <can_mcan_set_mode+0xb4>)
  403cb2:	aa05      	add	r2, sp, #20
  403cb4:	4812      	ldr	r0, [pc, #72]	; (403d00 <can_mcan_set_mode+0xb0>)
  403cb6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403cba:	9306      	str	r3, [sp, #24]
  403cbc:	2302      	movs	r3, #2
  403cbe:	9301      	str	r3, [sp, #4]
  403cc0:	9305      	str	r3, [sp, #20]
  403cc2:	f002 fe83 	bl	4069cc <z_log_msg2_static_create.constprop.0>
	return 0;
  403cc6:	2000      	movs	r0, #0
		LOG_ERR("Failed to leave init mode");
  403cc8:	e7da      	b.n	403c80 <can_mcan_set_mode+0x30>
		can->cccr &= ~CAN_MCAN_CCCR_TEST;
  403cca:	69a3      	ldr	r3, [r4, #24]
  403ccc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  403cd0:	61a3      	str	r3, [r4, #24]
		can->cccr |= CAN_MCAN_CCCR_MON;
  403cd2:	69a3      	ldr	r3, [r4, #24]
  403cd4:	f043 0320 	orr.w	r3, r3, #32
  403cd8:	e7e1      	b.n	403c9e <can_mcan_set_mode+0x4e>
		can->cccr &= ~CAN_MCAN_CCCR_MON;
  403cda:	69a3      	ldr	r3, [r4, #24]
  403cdc:	f023 0320 	bic.w	r3, r3, #32
  403ce0:	61a3      	str	r3, [r4, #24]
		can->cccr |= CAN_MCAN_CCCR_TEST;
  403ce2:	69a3      	ldr	r3, [r4, #24]
  403ce4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
		can->cccr |= (CAN_MCAN_CCCR_TEST | CAN_MCAN_CCCR_MON);
  403ce8:	61a3      	str	r3, [r4, #24]
		can->test |= CAN_MCAN_TEST_LBCK;
  403cea:	6923      	ldr	r3, [r4, #16]
  403cec:	f043 0310 	orr.w	r3, r3, #16
  403cf0:	6123      	str	r3, [r4, #16]
		break;
  403cf2:	e7d5      	b.n	403ca0 <can_mcan_set_mode+0x50>
		can->cccr |= (CAN_MCAN_CCCR_TEST | CAN_MCAN_CCCR_MON);
  403cf4:	69a3      	ldr	r3, [r4, #24]
  403cf6:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
  403cfa:	e7f5      	b.n	403ce8 <can_mcan_set_mode+0x98>
  403cfc:	00407ce8 	.word	0x00407ce8
  403d00:	00407270 	.word	0x00407270
  403d04:	00407d02 	.word	0x00407d02

00403d08 <can_mcan_init>:
{
  403d08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  403d0c:	4607      	mov	r7, r0
  403d0e:	b08f      	sub	sp, #60	; 0x3c
  403d10:	460e      	mov	r6, r1
  403d12:	4615      	mov	r5, r2
  403d14:	4698      	mov	r8, r3
	struct can_mcan_reg  *can = cfg->can;
  403d16:	680c      	ldr	r4, [r1, #0]
	return z_impl_k_mutex_init(mutex);
  403d18:	4618      	mov	r0, r3
  403d1a:	f002 ff6b 	bl	406bf4 <z_impl_k_mutex_init>
  403d1e:	f108 0024 	add.w	r0, r8, #36	; 0x24
  403d22:	f002 ff67 	bl	406bf4 <z_impl_k_mutex_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
  403d26:	2201      	movs	r2, #1
  403d28:	f108 0014 	add.w	r0, r8, #20
  403d2c:	4611      	mov	r1, r2
  403d2e:	f002 ff68 	bl	406c02 <z_impl_k_sem_init>
  403d32:	2201      	movs	r2, #1
  403d34:	2100      	movs	r1, #0
  403d36:	f108 0038 	add.w	r0, r8, #56	; 0x38
		if (k_cycle_get_32() - start_time >
  403d3a:	f8df 9218 	ldr.w	r9, [pc, #536]	; 403f54 <can_mcan_init+0x24c>
  403d3e:	f002 ff60 	bl	406c02 <z_impl_k_sem_init>
	can->cccr &= ~CAN_MCAN_CCCR_CSR;
  403d42:	69a3      	ldr	r3, [r4, #24]
  403d44:	f023 0310 	bic.w	r3, r3, #16
  403d48:	61a3      	str	r3, [r4, #24]
  403d4a:	f000 fdcf 	bl	4048ec <sys_clock_cycle_get_32>
  403d4e:	4680      	mov	r8, r0
	while ((can->cccr & CAN_MCAN_CCCR_CSA) == CAN_MCAN_CCCR_CSA) {
  403d50:	69a3      	ldr	r3, [r4, #24]
  403d52:	071b      	lsls	r3, r3, #28
  403d54:	d408      	bmi.n	403d68 <can_mcan_init+0x60>
	ret = can_enter_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403d56:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403d5a:	2300      	movs	r3, #0
  403d5c:	4620      	mov	r0, r4
  403d5e:	f002 fe3a 	bl	4069d6 <can_enter_init_mode.constprop.0>
	if (ret) {
  403d62:	b1d8      	cbz	r0, 403d9c <can_mcan_init+0x94>
		LOG_ERR("Failed to enter init mode");
  403d64:	4b7c      	ldr	r3, [pc, #496]	; (403f58 <can_mcan_init+0x250>)
  403d66:	e00a      	b.n	403d7e <can_mcan_init+0x76>
  403d68:	f000 fdc0 	bl	4048ec <sys_clock_cycle_get_32>
		if (k_cycle_get_32() - start_time >
  403d6c:	eba0 0008 	sub.w	r0, r0, r8
  403d70:	4548      	cmp	r0, r9
  403d72:	d9ed      	bls.n	403d50 <can_mcan_init+0x48>
			can->cccr |= CAN_MCAN_CCCR_CSR;
  403d74:	69a3      	ldr	r3, [r4, #24]
  403d76:	f043 0310 	orr.w	r3, r3, #16
  403d7a:	61a3      	str	r3, [r4, #24]
		LOG_ERR("Failed to exit sleep mode");
  403d7c:	4b77      	ldr	r3, [pc, #476]	; (403f5c <can_mcan_init+0x254>)
		LOG_ERR("Failed to enter init mode");
  403d7e:	930c      	str	r3, [sp, #48]	; 0x30
  403d80:	2302      	movs	r3, #2
  403d82:	9305      	str	r3, [sp, #20]
		LOG_ERR("Failed to leave init mode");
  403d84:	4876      	ldr	r0, [pc, #472]	; (403f60 <can_mcan_init+0x258>)
  403d86:	aa0b      	add	r2, sp, #44	; 0x2c
  403d88:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403d8c:	930b      	str	r3, [sp, #44]	; 0x2c
  403d8e:	f002 fe1d 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		return -EIO;
  403d92:	f06f 0004 	mvn.w	r0, #4
}
  403d96:	b00f      	add	sp, #60	; 0x3c
  403d98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	can->cccr |= CAN_MCAN_CCCR_CCE;
  403d9c:	69a3      	ldr	r3, [r4, #24]
  403d9e:	f043 0302 	orr.w	r3, r3, #2
  403da2:	61a3      	str	r3, [r4, #24]
	can->sidfc = (((uint32_t)msg_ram->std_filt - mrba) & CAN_MCAN_SIDFC_FLSSA_MSK) |
  403da4:	f64f 73fc 	movw	r3, #65532	; 0xfffc
  403da8:	ea05 0203 	and.w	r2, r5, r3
  403dac:	f442 12e0 	orr.w	r2, r2, #1835008	; 0x1c0000
  403db0:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
	can->xidfc = (((uint32_t)msg_ram->ext_filt - mrba) & CAN_MCAN_XIDFC_FLESA_MSK) |
  403db4:	f105 0270 	add.w	r2, r5, #112	; 0x70
  403db8:	401a      	ands	r2, r3
  403dba:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
  403dbe:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	can->rxf0c = (((uint32_t)msg_ram->rx_fifo0 - mrba) & CAN_MCAN_RXF0C_F0SA) |
  403dc2:	f105 02b0 	add.w	r2, r5, #176	; 0xb0
  403dc6:	401a      	ands	r2, r3
  403dc8:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
  403dcc:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	can->rxf1c = (((uint32_t)msg_ram->rx_fifo1 - mrba) & CAN_MCAN_RXF1C_F1SA) |
  403dd0:	f505 72c4 	add.w	r2, r5, #392	; 0x188
  403dd4:	401a      	ands	r2, r3
  403dd6:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
  403dda:	f8c4 20b0 	str.w	r2, [r4, #176]	; 0xb0
	can->rxbc = (((uint32_t)msg_ram->rx_buffer - mrba) & CAN_MCAN_RXBC_RBSA);
  403dde:	f505 7218 	add.w	r2, r5, #608	; 0x260
  403de2:	401a      	ands	r2, r3
  403de4:	f8c4 20ac 	str.w	r2, [r4, #172]	; 0xac
	can->txefc = (((uint32_t)msg_ram->tx_event_fifo - mrba) & CAN_MCAN_TXEFC_EFSA_MSK) |
  403de8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  403dec:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
	can->txbc = (((uint32_t)msg_ram->tx_buffer - mrba) & CAN_MCAN_TXBC_TBSA) |
  403df0:	f505 721a 	add.w	r2, r5, #616	; 0x268
  403df4:	4013      	ands	r3, r2
  403df6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  403dfa:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
		can->txesc = (sizeof(msg_ram->tx_buffer[0].data) - 32) / 16 + 5;
  403dfe:	2307      	movs	r3, #7
  403e00:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
		can->rxesc = (((sizeof(msg_ram->rx_fifo0[0].data) - 32)
  403e04:	f240 7377 	movw	r3, #1911	; 0x777
  403e08:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
	can->cccr |= CAN_MCAN_CCCR_FDOE | CAN_MCAN_CCCR_BRSE;
  403e0c:	69a3      	ldr	r3, [r4, #24]
  403e0e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
  403e12:	61a3      	str	r3, [r4, #24]
	can->cccr &= ~(CAN_MCAN_CCCR_TEST | CAN_MCAN_CCCR_MON |
  403e14:	69a3      	ldr	r3, [r4, #24]
  403e16:	f023 03a4 	bic.w	r3, r3, #164	; 0xa4
  403e1a:	61a3      	str	r3, [r4, #24]
	can->test &= ~(CAN_MCAN_TEST_LBCK);
  403e1c:	6923      	ldr	r3, [r4, #16]
  403e1e:	f023 0310 	bic.w	r3, r3, #16
  403e22:	6123      	str	r3, [r4, #16]
	can->dbtp |= CAN_MCAN_DBTP_TDC;
  403e24:	68e3      	ldr	r3, [r4, #12]
  403e26:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  403e2a:	60e3      	str	r3, [r4, #12]
	can->tdcr |=  cfg->tx_delay_comp_offset << CAN_MCAN_TDCR_TDCO_POS;
  403e2c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403e2e:	7e72      	ldrb	r2, [r6, #25]
  403e30:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  403e34:	64a3      	str	r3, [r4, #72]	; 0x48
	can->gfc |= (0x2 << CAN_MCAN_GFC_ANFE_POS) |
  403e36:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
  403e3a:	f043 0328 	orr.w	r3, r3, #40	; 0x28
  403e3e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	if (cfg->sample_point) {
  403e42:	89f3      	ldrh	r3, [r6, #14]
  403e44:	b143      	cbz	r3, 403e58 <can_mcan_init+0x150>
		ret = can_calc_timing(dev, &timing, cfg->bus_speed,
  403e46:	6872      	ldr	r2, [r6, #4]
  403e48:	a902      	add	r1, sp, #8
  403e4a:	4638      	mov	r0, r7
  403e4c:	f002 fd68 	bl	406920 <can_calc_timing>
		if (ret == -EINVAL) {
  403e50:	3016      	adds	r0, #22
  403e52:	d11c      	bne.n	403e8e <can_mcan_init+0x186>
			LOG_ERR("Can't find timing for given param");
  403e54:	4b43      	ldr	r3, [pc, #268]	; (403f64 <can_mcan_init+0x25c>)
  403e56:	e792      	b.n	403d7e <can_mcan_init+0x76>
	} else if (cfg->prop_ts1) {
  403e58:	8a32      	ldrh	r2, [r6, #16]
  403e5a:	b1c2      	cbz	r2, 403e8e <can_mcan_init+0x186>
		timing.prop_seg = 0;
  403e5c:	f8ad 300a 	strh.w	r3, [sp, #10]
		ret = can_calc_prescaler(dev, &timing, cfg->bus_speed);
  403e60:	a902      	add	r1, sp, #8
		timing.phase_seg2 = cfg->ts2;
  403e62:	8a73      	ldrh	r3, [r6, #18]
		ret = can_calc_prescaler(dev, &timing, cfg->bus_speed);
  403e64:	4638      	mov	r0, r7
		timing.phase_seg1 = cfg->prop_ts1;
  403e66:	f8ad 200c 	strh.w	r2, [sp, #12]
		ret = can_calc_prescaler(dev, &timing, cfg->bus_speed);
  403e6a:	6872      	ldr	r2, [r6, #4]
		timing.phase_seg2 = cfg->ts2;
  403e6c:	f8ad 300e 	strh.w	r3, [sp, #14]
		ret = can_calc_prescaler(dev, &timing, cfg->bus_speed);
  403e70:	f002 fd82 	bl	406978 <can_calc_prescaler>
		if (ret) {
  403e74:	b158      	cbz	r0, 403e8e <can_mcan_init+0x186>
			LOG_WRN("Bitrate error: %d", ret);
  403e76:	4b3c      	ldr	r3, [pc, #240]	; (403f68 <can_mcan_init+0x260>)
  403e78:	aa0b      	add	r2, sp, #44	; 0x2c
  403e7a:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
  403e7e:	e9cd 300c 	strd	r3, r0, [sp, #48]	; 0x30
  403e82:	2303      	movs	r3, #3
  403e84:	4836      	ldr	r0, [pc, #216]	; (403f60 <can_mcan_init+0x258>)
  403e86:	9305      	str	r3, [sp, #20]
  403e88:	930b      	str	r3, [sp, #44]	; 0x2c
  403e8a:	f002 fd9f 	bl	4069cc <z_log_msg2_static_create.constprop.0>
	if (cfg->sample_point_data) {
  403e8e:	8ab3      	ldrh	r3, [r6, #20]
  403e90:	b15b      	cbz	r3, 403eaa <can_mcan_init+0x1a2>
		ret = can_calc_timing_data(dev, &timing_data,
  403e92:	68b2      	ldr	r2, [r6, #8]
  403e94:	a905      	add	r1, sp, #20
  403e96:	4638      	mov	r0, r7
  403e98:	f002 fd58 	bl	40694c <can_calc_timing_data>
		if (ret == -EINVAL) {
  403e9c:	3016      	adds	r0, #22
  403e9e:	d11f      	bne.n	403ee0 <can_mcan_init+0x1d8>
			LOG_ERR("Can't find timing for given dataphase param");
  403ea0:	4b32      	ldr	r3, [pc, #200]	; (403f6c <can_mcan_init+0x264>)
		LOG_ERR("Failed to leave init mode");
  403ea2:	930c      	str	r3, [sp, #48]	; 0x30
  403ea4:	2302      	movs	r3, #2
  403ea6:	9301      	str	r3, [sp, #4]
  403ea8:	e76c      	b.n	403d84 <can_mcan_init+0x7c>
	} else if (cfg->prop_ts1_data) {
  403eaa:	7df2      	ldrb	r2, [r6, #23]
  403eac:	b1c2      	cbz	r2, 403ee0 <can_mcan_init+0x1d8>
		timing_data.prop_seg = 0;
  403eae:	f8ad 3016 	strh.w	r3, [sp, #22]
		ret = can_calc_prescaler(dev, &timing_data,
  403eb2:	a905      	add	r1, sp, #20
		timing_data.phase_seg2 = cfg->ts2_data;
  403eb4:	7e33      	ldrb	r3, [r6, #24]
		ret = can_calc_prescaler(dev, &timing_data,
  403eb6:	4638      	mov	r0, r7
		timing_data.phase_seg1 = cfg->prop_ts1_data;
  403eb8:	f8ad 2018 	strh.w	r2, [sp, #24]
		ret = can_calc_prescaler(dev, &timing_data,
  403ebc:	68b2      	ldr	r2, [r6, #8]
		timing_data.phase_seg2 = cfg->ts2_data;
  403ebe:	f8ad 301a 	strh.w	r3, [sp, #26]
		ret = can_calc_prescaler(dev, &timing_data,
  403ec2:	f002 fd59 	bl	406978 <can_calc_prescaler>
		if (ret) {
  403ec6:	b158      	cbz	r0, 403ee0 <can_mcan_init+0x1d8>
			LOG_WRN("Dataphase bitrate error: %d", ret);
  403ec8:	4b29      	ldr	r3, [pc, #164]	; (403f70 <can_mcan_init+0x268>)
  403eca:	aa0b      	add	r2, sp, #44	; 0x2c
  403ecc:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
  403ed0:	e9cd 300c 	strd	r3, r0, [sp, #48]	; 0x30
  403ed4:	2303      	movs	r3, #3
  403ed6:	4822      	ldr	r0, [pc, #136]	; (403f60 <can_mcan_init+0x258>)
  403ed8:	9301      	str	r3, [sp, #4]
  403eda:	930b      	str	r3, [sp, #44]	; 0x2c
  403edc:	f002 fd76 	bl	4069cc <z_log_msg2_static_create.constprop.0>
	timing.sjw = cfg->sjw;
  403ee0:	89b3      	ldrh	r3, [r6, #12]
	can_mcan_configure_timing(can, &timing, &timing_data);
  403ee2:	aa05      	add	r2, sp, #20
  403ee4:	a902      	add	r1, sp, #8
  403ee6:	4620      	mov	r0, r4
	timing.sjw = cfg->sjw;
  403ee8:	f8ad 3008 	strh.w	r3, [sp, #8]
	timing_data.sjw = cfg->sjw_data;
  403eec:	7db3      	ldrb	r3, [r6, #22]
  403eee:	f8ad 3014 	strh.w	r3, [sp, #20]
	can_mcan_configure_timing(can, &timing, &timing_data);
  403ef2:	f7ff fe37 	bl	403b64 <can_mcan_configure_timing>
	can->ie = CAN_MCAN_IE_BO | CAN_MCAN_IE_EW | CAN_MCAN_IE_EP |
  403ef6:	4b1f      	ldr	r3, [pc, #124]	; (403f74 <can_mcan_init+0x26c>)
  403ef8:	f505 722c 	add.w	r2, r5, #688	; 0x2b0
		*dst++ = val;
  403efc:	2100      	movs	r1, #0
	can->ie = CAN_MCAN_IE_BO | CAN_MCAN_IE_EW | CAN_MCAN_IE_EP |
  403efe:	6563      	str	r3, [r4, #84]	; 0x54
	can->ils = CAN_MCAN_ILS_RF0N | CAN_MCAN_ILS_RF1N;
  403f00:	2311      	movs	r3, #17
  403f02:	65a3      	str	r3, [r4, #88]	; 0x58
	can->ile = CAN_MCAN_ILE_EINT0 | CAN_MCAN_ILE_EINT1;
  403f04:	2303      	movs	r3, #3
  403f06:	65e3      	str	r3, [r4, #92]	; 0x5c
	can->txbtie = CAN_MCAN_TXBTIE_TIE;
  403f08:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  403f0c:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
	volatile uint32_t *dst = dst_;
  403f10:	462b      	mov	r3, r5
	while (len--) {
  403f12:	429a      	cmp	r2, r3
  403f14:	d11b      	bne.n	403f4e <can_mcan_init+0x246>
*/
__STATIC_FORCEINLINE void SCB_CleanDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  403f16:	f005 031f 	and.w	r3, r5, #31
  403f1a:	f503 732c 	add.w	r3, r3, #688	; 0x2b0
  __ASM volatile ("dsb 0xF":::"memory");
  403f1e:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;

      __DSB();

      do {
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  403f22:	4a15      	ldr	r2, [pc, #84]	; (403f78 <can_mcan_init+0x270>)
  403f24:	3b20      	subs	r3, #32
  403f26:	f8c2 5268 	str.w	r5, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  403f2a:	3520      	adds	r5, #32
        op_size -= __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
  403f2c:	2b00      	cmp	r3, #0
  403f2e:	dcf9      	bgt.n	403f24 <can_mcan_init+0x21c>
  403f30:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  403f34:	f3bf 8f6f 	isb	sy
	ret = can_leave_init_mode(can, K_MSEC(CAN_INIT_TIMEOUT));
  403f38:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  403f3c:	2300      	movs	r3, #0
  403f3e:	4620      	mov	r0, r4
  403f40:	f002 fd6a 	bl	406a18 <can_leave_init_mode.constprop.0>
	if (ret) {
  403f44:	2800      	cmp	r0, #0
  403f46:	f43f af26 	beq.w	403d96 <can_mcan_init+0x8e>
		LOG_ERR("Failed to leave init mode");
  403f4a:	4b0c      	ldr	r3, [pc, #48]	; (403f7c <can_mcan_init+0x274>)
  403f4c:	e7a9      	b.n	403ea2 <can_mcan_init+0x19a>
		*dst++ = val;
  403f4e:	f843 1b04 	str.w	r1, [r3], #4
  403f52:	e7de      	b.n	403f12 <can_mcan_init+0x20a>
  403f54:	01c9c380 	.word	0x01c9c380
  403f58:	00407ce8 	.word	0x00407ce8
  403f5c:	00407d1c 	.word	0x00407d1c
  403f60:	00407270 	.word	0x00407270
  403f64:	00407d36 	.word	0x00407d36
  403f68:	00407d58 	.word	0x00407d58
  403f6c:	00407d6a 	.word	0x00407d6a
  403f70:	00407d96 	.word	0x00407d96
  403f74:	03829099 	.word	0x03829099
  403f78:	e000ed00 	.word	0xe000ed00
  403f7c:	00407d02 	.word	0x00407d02

00403f80 <can_mcan_line_1_isr>:

void can_mcan_line_1_isr(const struct can_mcan_config *cfg,
			 struct can_mcan_msg_sram *msg_ram,
			 struct can_mcan_data *data)
{
  403f80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  403f84:	460d      	mov	r5, r1
  403f86:	b089      	sub	sp, #36	; 0x24
  403f88:	4616      	mov	r6, r2
	struct can_mcan_reg *can = cfg->can;
  403f8a:	6804      	ldr	r4, [r0, #0]
					     &can->rxf1s, &can->rxf1a);
		}

		if (can->ir & CAN_MCAN_IR_RF0L) {
			can->ir  = CAN_MCAN_IR_RF0L;
			LOG_ERR("Message lost on FIFO0");
  403f8c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 40401c <can_mcan_line_1_isr+0x9c>
  403f90:	4f23      	ldr	r7, [pc, #140]	; (404020 <can_mcan_line_1_isr+0xa0>)
		}

		if (can->ir & CAN_MCAN_IR_RF1L) {
			can->ir  = CAN_MCAN_IR_RF1L;
			LOG_ERR("Message lost on FIFO1");
  403f92:	f8df 9090 	ldr.w	r9, [pc, #144]	; 404024 <can_mcan_line_1_isr+0xa4>
		if (can->ir & CAN_MCAN_IR_RF0N) {
  403f96:	6d23      	ldr	r3, [r4, #80]	; 0x50
  403f98:	07d8      	lsls	r0, r3, #31
  403f9a:	d50a      	bpl.n	403fb2 <can_mcan_line_1_isr+0x32>
			can->ir  = CAN_MCAN_IR_RF0N;
  403f9c:	2301      	movs	r3, #1
			can_mcan_get_message(data, msg_ram->rx_fifo0,
  403f9e:	f104 02a4 	add.w	r2, r4, #164	; 0xa4
  403fa2:	f105 01b0 	add.w	r1, r5, #176	; 0xb0
  403fa6:	4630      	mov	r0, r6
			can->ir  = CAN_MCAN_IR_RF0N;
  403fa8:	6523      	str	r3, [r4, #80]	; 0x50
			can_mcan_get_message(data, msg_ram->rx_fifo0,
  403faa:	f104 03a8 	add.w	r3, r4, #168	; 0xa8
  403fae:	f7ff fd07 	bl	4039c0 <can_mcan_get_message>
		if (can->ir & CAN_MCAN_IR_RF1N) {
  403fb2:	6d23      	ldr	r3, [r4, #80]	; 0x50
  403fb4:	06d9      	lsls	r1, r3, #27
  403fb6:	d50a      	bpl.n	403fce <can_mcan_line_1_isr+0x4e>
			can->ir  = CAN_MCAN_IR_RF1N;
  403fb8:	2310      	movs	r3, #16
			can_mcan_get_message(data, msg_ram->rx_fifo1,
  403fba:	f104 02b4 	add.w	r2, r4, #180	; 0xb4
  403fbe:	f505 71c4 	add.w	r1, r5, #392	; 0x188
  403fc2:	4630      	mov	r0, r6
			can->ir  = CAN_MCAN_IR_RF1N;
  403fc4:	6523      	str	r3, [r4, #80]	; 0x50
			can_mcan_get_message(data, msg_ram->rx_fifo1,
  403fc6:	f104 03b8 	add.w	r3, r4, #184	; 0xb8
  403fca:	f7ff fcf9 	bl	4039c0 <can_mcan_get_message>
		if (can->ir & CAN_MCAN_IR_RF0L) {
  403fce:	6d23      	ldr	r3, [r4, #80]	; 0x50
  403fd0:	071a      	lsls	r2, r3, #28
  403fd2:	d50c      	bpl.n	403fee <can_mcan_line_1_isr+0x6e>
			can->ir  = CAN_MCAN_IR_RF0L;
  403fd4:	2308      	movs	r3, #8
			LOG_ERR("Message lost on FIFO0");
  403fd6:	aa05      	add	r2, sp, #20
  403fd8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403fdc:	4638      	mov	r0, r7
			can->ir  = CAN_MCAN_IR_RF0L;
  403fde:	6523      	str	r3, [r4, #80]	; 0x50
			LOG_ERR("Message lost on FIFO0");
  403fe0:	2302      	movs	r3, #2
  403fe2:	f8cd 8018 	str.w	r8, [sp, #24]
  403fe6:	9301      	str	r3, [sp, #4]
  403fe8:	9305      	str	r3, [sp, #20]
  403fea:	f002 fcef 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		if (can->ir & CAN_MCAN_IR_RF1L) {
  403fee:	6d23      	ldr	r3, [r4, #80]	; 0x50
  403ff0:	061b      	lsls	r3, r3, #24
  403ff2:	d50c      	bpl.n	40400e <can_mcan_line_1_isr+0x8e>
			can->ir  = CAN_MCAN_IR_RF1L;
  403ff4:	2380      	movs	r3, #128	; 0x80
			LOG_ERR("Message lost on FIFO1");
  403ff6:	aa05      	add	r2, sp, #20
  403ff8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  403ffc:	4638      	mov	r0, r7
			can->ir  = CAN_MCAN_IR_RF1L;
  403ffe:	6523      	str	r3, [r4, #80]	; 0x50
			LOG_ERR("Message lost on FIFO1");
  404000:	2302      	movs	r3, #2
  404002:	f8cd 9018 	str.w	r9, [sp, #24]
  404006:	9301      	str	r3, [sp, #4]
  404008:	9305      	str	r3, [sp, #20]
  40400a:	f002 fcdf 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		}

	} while (can->ir & (CAN_MCAN_IR_RF0N | CAN_MCAN_IR_RF1N |
  40400e:	6d23      	ldr	r3, [r4, #80]	; 0x50
			    CAN_MCAN_IR_RF0L | CAN_MCAN_IR_RF1L));
  404010:	f013 0f99 	tst.w	r3, #153	; 0x99
  404014:	d1bf      	bne.n	403f96 <can_mcan_line_1_isr+0x16>
}
  404016:	b009      	add	sp, #36	; 0x24
  404018:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40401c:	00407db2 	.word	0x00407db2
  404020:	00407270 	.word	0x00407270
  404024:	00407dc8 	.word	0x00407dc8

00404028 <can_mcan_line_0_isr>:
{
  404028:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40402c:	4607      	mov	r7, r0
  40402e:	b089      	sub	sp, #36	; 0x24
  404030:	4688      	mov	r8, r1
  404032:	4615      	mov	r5, r2
	struct can_mcan_reg *can = cfg->can;
  404034:	6804      	ldr	r4, [r0, #0]
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  404036:	f8df 9120 	ldr.w	r9, [pc, #288]	; 404158 <can_mcan_line_0_isr+0x130>
			LOG_ERR("TX FIFO element lost");
  40403a:	f8df a120 	ldr.w	sl, [pc, #288]	; 40415c <can_mcan_line_0_isr+0x134>
		if (can->ir & (CAN_MCAN_IR_BO | CAN_MCAN_IR_EP |
  40403e:	6d23      	ldr	r3, [r4, #80]	; 0x50
  404040:	f013 7f60 	tst.w	r3, #58720256	; 0x3800000
  404044:	d00f      	beq.n	404066 <can_mcan_line_0_isr+0x3e>
			can->ir = CAN_MCAN_IR_BO | CAN_MCAN_IR_EP |
  404046:	f04f 7360 	mov.w	r3, #58720256	; 0x3800000
	(void)can_mcan_get_state(cfg, &state, &err_cnt);
  40404a:	aa02      	add	r2, sp, #8
  40404c:	a901      	add	r1, sp, #4
  40404e:	4638      	mov	r0, r7
			can->ir = CAN_MCAN_IR_BO | CAN_MCAN_IR_EP |
  404050:	6523      	str	r3, [r4, #80]	; 0x50
	void *cb_data = data->state_change_cb_data;
  404052:	e9d5 6b5c 	ldrd	r6, fp, [r5, #368]	; 0x170
	(void)can_mcan_get_state(cfg, &state, &err_cnt);
  404056:	f002 fcfc 	bl	406a52 <can_mcan_get_state>
	if (cb != NULL) {
  40405a:	b126      	cbz	r6, 404066 <can_mcan_line_0_isr+0x3e>
		cb(state, err_cnt, cb_data);
  40405c:	465a      	mov	r2, fp
  40405e:	9902      	ldr	r1, [sp, #8]
  404060:	f89d 0004 	ldrb.w	r0, [sp, #4]
  404064:	47b0      	blx	r6
		if (can->ir & CAN_MCAN_IR_TEFN) {
  404066:	6d23      	ldr	r3, [r4, #80]	; 0x50
  404068:	04de      	lsls	r6, r3, #19
  40406a:	d43d      	bmi.n	4040e8 <can_mcan_line_0_isr+0xc0>
		if (can->ir & CAN_MCAN_IR_TEFL) {
  40406c:	6d23      	ldr	r3, [r4, #80]	; 0x50
  40406e:	0418      	lsls	r0, r3, #16
  404070:	d511      	bpl.n	404096 <can_mcan_line_0_isr+0x6e>
			can->ir = CAN_MCAN_IR_TEFL;
  404072:	f44f 4300 	mov.w	r3, #32768	; 0x8000
			LOG_ERR("TX FIFO element lost");
  404076:	aa05      	add	r2, sp, #20
  404078:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  40407c:	4838      	ldr	r0, [pc, #224]	; (404160 <can_mcan_line_0_isr+0x138>)
			can->ir = CAN_MCAN_IR_TEFL;
  40407e:	6523      	str	r3, [r4, #80]	; 0x50
			LOG_ERR("TX FIFO element lost");
  404080:	2302      	movs	r3, #2
  404082:	f8cd a018 	str.w	sl, [sp, #24]
  404086:	9301      	str	r3, [sp, #4]
  404088:	9305      	str	r3, [sp, #20]
  40408a:	f002 fc9f 	bl	4069cc <z_log_msg2_static_create.constprop.0>
	z_impl_k_sem_give(sem);
  40408e:	f105 0014 	add.w	r0, r5, #20
  404092:	f000 ff25 	bl	404ee0 <z_impl_k_sem_give>
		if (can->ir & CAN_MCAN_IR_ARA) {
  404096:	6d23      	ldr	r3, [r4, #80]	; 0x50
  404098:	009a      	lsls	r2, r3, #2
  40409a:	d50d      	bpl.n	4040b8 <can_mcan_line_0_isr+0x90>
			can->ir  = CAN_MCAN_IR_ARA;
  40409c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
			LOG_ERR("Access to reserved address");
  4040a0:	aa05      	add	r2, sp, #20
  4040a2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  4040a6:	482e      	ldr	r0, [pc, #184]	; (404160 <can_mcan_line_0_isr+0x138>)
			can->ir  = CAN_MCAN_IR_ARA;
  4040a8:	6523      	str	r3, [r4, #80]	; 0x50
			LOG_ERR("Access to reserved address");
  4040aa:	4b2e      	ldr	r3, [pc, #184]	; (404164 <can_mcan_line_0_isr+0x13c>)
  4040ac:	9306      	str	r3, [sp, #24]
  4040ae:	2302      	movs	r3, #2
  4040b0:	9301      	str	r3, [sp, #4]
  4040b2:	9305      	str	r3, [sp, #20]
  4040b4:	f002 fc8a 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		if (can->ir & CAN_MCAN_IR_MRAF) {
  4040b8:	6d23      	ldr	r3, [r4, #80]	; 0x50
  4040ba:	039b      	lsls	r3, r3, #14
  4040bc:	d50d      	bpl.n	4040da <can_mcan_line_0_isr+0xb2>
			can->ir  = CAN_MCAN_IR_MRAF;
  4040be:	f44f 3300 	mov.w	r3, #131072	; 0x20000
			LOG_ERR("Message RAM access failure");
  4040c2:	aa05      	add	r2, sp, #20
  4040c4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  4040c8:	4825      	ldr	r0, [pc, #148]	; (404160 <can_mcan_line_0_isr+0x138>)
			can->ir  = CAN_MCAN_IR_MRAF;
  4040ca:	6523      	str	r3, [r4, #80]	; 0x50
			LOG_ERR("Message RAM access failure");
  4040cc:	4b26      	ldr	r3, [pc, #152]	; (404168 <can_mcan_line_0_isr+0x140>)
  4040ce:	9306      	str	r3, [sp, #24]
  4040d0:	2302      	movs	r3, #2
  4040d2:	9301      	str	r3, [sp, #4]
  4040d4:	9305      	str	r3, [sp, #20]
  4040d6:	f002 fc79 	bl	4069cc <z_log_msg2_static_create.constprop.0>
	} while (can->ir & (CAN_MCAN_IR_BO | CAN_MCAN_IR_EW | CAN_MCAN_IR_EP |
  4040da:	6d22      	ldr	r2, [r4, #80]	; 0x50
			    CAN_MCAN_IR_TEFL | CAN_MCAN_IR_TEFN));
  4040dc:	4b23      	ldr	r3, [pc, #140]	; (40416c <can_mcan_line_0_isr+0x144>)
  4040de:	421a      	tst	r2, r3
  4040e0:	d1ad      	bne.n	40403e <can_mcan_line_0_isr+0x16>
}
  4040e2:	b009      	add	sp, #36	; 0x24
  4040e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			can->ir = CAN_MCAN_IR_TEFN;
  4040e8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
		k_sem_give(&data->tx_sem);
  4040ec:	f105 0b14 	add.w	fp, r5, #20
			can->ir = CAN_MCAN_IR_TEFN;
  4040f0:	6523      	str	r3, [r4, #80]	; 0x50
	while (can->txefs & CAN_MCAN_TXEFS_EFFL) {
  4040f2:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
  4040f6:	0699      	lsls	r1, r3, #26
  4040f8:	d0b8      	beq.n	40406c <can_mcan_line_0_isr+0x44>
		event_idx = (can->txefs & CAN_MCAN_TXEFS_EFGI) >>
  4040fa:	f8d4 20f4 	ldr.w	r2, [r4, #244]	; 0xf4
  4040fe:	f3c2 2204 	ubfx	r2, r2, #8, #5
		CACHE_INVALIDATE(&msg_ram->tx_event_fifo[event_idx],
  404102:	f102 014c 	add.w	r1, r2, #76	; 0x4c
  404106:	eb08 00c1 	add.w	r0, r8, r1, lsl #3
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  40410a:	f000 031f 	and.w	r3, r0, #31
  40410e:	3308      	adds	r3, #8
  __ASM volatile ("dsb 0xF":::"memory");
  404110:	f3bf 8f4f 	dsb	sy
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  404114:	3b20      	subs	r3, #32
  404116:	f8c9 025c 	str.w	r0, [r9, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
  40411a:	3020      	adds	r0, #32
      } while ( op_size > 0 );
  40411c:	2b00      	cmp	r3, #0
  40411e:	dcf9      	bgt.n	404114 <can_mcan_line_0_isr+0xec>
  404120:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  404124:	f3bf 8f6f 	isb	sy
		tx_idx = tx_event->mm.idx;
  404128:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
  40412c:	79ce      	ldrb	r6, [r1, #7]
		can->txefa = event_idx;
  40412e:	f8c4 20f8 	str.w	r2, [r4, #248]	; 0xf8
		tx_idx = tx_event->mm.idx;
  404132:	f006 061f 	and.w	r6, r6, #31
  404136:	4658      	mov	r0, fp
  404138:	f000 fed2 	bl	404ee0 <z_impl_k_sem_give>
		tx_cb = data->tx_fin_cb[tx_idx];
  40413c:	eb05 0286 	add.w	r2, r5, r6, lsl #2
  404140:	6c93      	ldr	r3, [r2, #72]	; 0x48
		if (tx_cb == NULL) {
  404142:	b92b      	cbnz	r3, 404150 <can_mcan_line_0_isr+0x128>
			k_sem_give(&data->tx_fin_sem[tx_idx]);
  404144:	eb05 1006 	add.w	r0, r5, r6, lsl #4
  404148:	3038      	adds	r0, #56	; 0x38
  40414a:	f000 fec9 	bl	404ee0 <z_impl_k_sem_give>
}
  40414e:	e7d0      	b.n	4040f2 <can_mcan_line_0_isr+0xca>
			tx_cb(0, data->tx_fin_cb_arg[tx_idx]);
  404150:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
  404152:	2000      	movs	r0, #0
  404154:	4798      	blx	r3
  404156:	e7cc      	b.n	4040f2 <can_mcan_line_0_isr+0xca>
  404158:	e000ed00 	.word	0xe000ed00
  40415c:	00407dde 	.word	0x00407dde
  404160:	00407270 	.word	0x00407270
  404164:	00407df3 	.word	0x00407df3
  404168:	00407e0e 	.word	0x00407e0e
  40416c:	03809000 	.word	0x03809000

00404170 <can_mcan_send>:
		  struct can_mcan_data *data,
		  struct can_mcan_msg_sram *msg_ram,
		  const struct zcan_frame *frame,
		  k_timeout_t timeout,
		  can_tx_callback_t callback, void *user_data)
{
  404170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404174:	b08f      	sub	sp, #60	; 0x3c
  404176:	4699      	mov	r9, r3
  404178:	460c      	mov	r4, r1
  40417a:	af00      	add	r7, sp, #0
	struct can_mcan_reg  *can = cfg->can;
  40417c:	6803      	ldr	r3, [r0, #0]
{
  40417e:	60ba      	str	r2, [r7, #8]
	size_t data_length = can_dlc_to_bytes(frame->dlc);
  404180:	f899 2004 	ldrb.w	r2, [r9, #4]
	struct can_mcan_reg  *can = cfg->can;
  404184:	60fb      	str	r3, [r7, #12]
  404186:	2a0f      	cmp	r2, #15
	struct can_mcan_tx_buffer_hdr tx_hdr = {
		.rtr = frame->rtr  == CAN_REMOTEREQUEST,
  404188:	f899 1003 	ldrb.w	r1, [r9, #3]
  40418c:	bf98      	it	ls
  40418e:	4b73      	ldrls	r3, [pc, #460]	; (40435c <can_mcan_send+0x1ec>)
		.xtd = frame->id_type == CAN_EXTENDED_IDENTIFIER,
  404190:	ea4f 10d1 	mov.w	r0, r1, lsr #7
  404194:	bf8c      	ite	hi
  404196:	2540      	movhi	r5, #64	; 0x40
  404198:	5c9d      	ldrbls	r5, [r3, r2]
	struct can_mcan_tx_buffer_hdr tx_hdr = {
  40419a:	2300      	movs	r3, #0
  40419c:	e9c7 3306 	strd	r3, r3, [r7, #24]
		.rtr = frame->rtr  == CAN_REMOTEREQUEST,
  4041a0:	f3c1 1380 	ubfx	r3, r1, #6, #1
				  "standard" : "extended",
		frame->rtr == CAN_DATAFRAME ? "" : "RTR",
		frame->fd == CAN_DATAFRAME ? "" : "FD frame",
		frame->brs == CAN_DATAFRAME ? "" : "BRS");

	if (data_length > sizeof(frame->data)) {
  4041a4:	2d40      	cmp	r5, #64	; 0x40
	struct can_mcan_tx_buffer_hdr tx_hdr = {
  4041a6:	ea4f 1343 	mov.w	r3, r3, lsl #5
  4041aa:	f360 1386 	bfi	r3, r0, #6, #1
		.brs = frame->brs == true,
  4041ae:	f899 0005 	ldrb.w	r0, [r9, #5]
	struct can_mcan_tx_buffer_hdr tx_hdr = {
  4041b2:	76fb      	strb	r3, [r7, #27]
  4041b4:	f002 030f 	and.w	r3, r2, #15
  4041b8:	f360 1304 	bfi	r3, r0, #4, #1
		.fdf = frame->fd,
  4041bc:	f3c1 1040 	ubfx	r0, r1, #5, #1
	struct can_mcan_tx_buffer_hdr tx_hdr = {
  4041c0:	f360 1345 	bfi	r3, r0, #5, #1
  4041c4:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4041c8:	77bb      	strb	r3, [r7, #30]
	if (data_length > sizeof(frame->data)) {
  4041ca:	d918      	bls.n	4041fe <can_mcan_send+0x8e>
		LOG_ERR("data length (%zu) > max frame data length (%zu)",
  4041cc:	466c      	mov	r4, sp
  4041ce:	b088      	sub	sp, #32
  4041d0:	4b63      	ldr	r3, [pc, #396]	; (404360 <can_mcan_send+0x1f0>)
  4041d2:	f44f 5101 	mov.w	r1, #8256	; 0x2040
  4041d6:	466a      	mov	r2, sp
  4041d8:	4862      	ldr	r0, [pc, #392]	; (404364 <can_mcan_send+0x1f4>)
  4041da:	e9c2 3504 	strd	r3, r5, [r2, #16]
  4041de:	2340      	movs	r3, #64	; 0x40
  4041e0:	6193      	str	r3, [r2, #24]
  4041e2:	2304      	movs	r3, #4
  4041e4:	f842 3f0c 	str.w	r3, [r2, #12]!
  4041e8:	623b      	str	r3, [r7, #32]
  4041ea:	f002 fbef 	bl	4069cc <z_log_msg2_static_create.constprop.0>
  4041ee:	46a5      	mov	sp, r4
		return -EINVAL;
	}

	if (frame->fd != 1 && frame->dlc > MCAN_MAX_DLC) {
		LOG_ERR("DLC of %d without fd flag set.", frame->dlc);
		return -EINVAL;
  4041f0:	f06f 0815 	mvn.w	r8, #21
		LOG_DBG("Waiting for TX complete");
		k_sem_take(&data->tx_fin_sem[put_idx], K_FOREVER);
	}

	return 0;
}
  4041f4:	4640      	mov	r0, r8
  4041f6:	373c      	adds	r7, #60	; 0x3c
  4041f8:	46bd      	mov	sp, r7
  4041fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (frame->fd != 1 && frame->dlc > MCAN_MAX_DLC) {
  4041fe:	0689      	lsls	r1, r1, #26
  404200:	d40f      	bmi.n	404222 <can_mcan_send+0xb2>
  404202:	2a0f      	cmp	r2, #15
  404204:	d90d      	bls.n	404222 <can_mcan_send+0xb2>
		LOG_ERR("DLC of %d without fd flag set.", frame->dlc);
  404206:	4b58      	ldr	r3, [pc, #352]	; (404368 <can_mcan_send+0x1f8>)
  404208:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
  40420c:	4855      	ldr	r0, [pc, #340]	; (404364 <can_mcan_send+0x1f4>)
  40420e:	e9c7 320c 	strd	r3, r2, [r7, #48]	; 0x30
  404212:	2303      	movs	r3, #3
  404214:	f107 022c 	add.w	r2, r7, #44	; 0x2c
  404218:	617b      	str	r3, [r7, #20]
  40421a:	62fb      	str	r3, [r7, #44]	; 0x2c
  40421c:	f002 fbd6 	bl	4069cc <z_log_msg2_static_create.constprop.0>
  404220:	e7e6      	b.n	4041f0 <can_mcan_send+0x80>
	if (can->psr & CAN_MCAN_PSR_BO) {
  404222:	68fb      	ldr	r3, [r7, #12]
  404224:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  404226:	061b      	lsls	r3, r3, #24
  404228:	f100 8091 	bmi.w	40434e <can_mcan_send+0x1de>
	return z_impl_k_sem_take(sem, timeout);
  40422c:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
  404230:	f104 0014 	add.w	r0, r4, #20
  404234:	f000 fe74 	bl	404f20 <z_impl_k_sem_take>
	if (ret != 0) {
  404238:	4680      	mov	r8, r0
  40423a:	2800      	cmp	r0, #0
  40423c:	f040 808a 	bne.w	404354 <can_mcan_send+0x1e4>
	k_mutex_lock(&data->tx_mtx, K_FOREVER);
  404240:	f104 0b24 	add.w	fp, r4, #36	; 0x24
	return z_impl_k_mutex_lock(mutex, timeout);
  404244:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  404248:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  40424c:	4658      	mov	r0, fp
			  ROUND_UP(data_length, 4));
  40424e:	3503      	adds	r5, #3
  404250:	f000 fd8c 	bl	404d6c <z_impl_k_mutex_lock>
	put_idx = ((can->txfqs & CAN_MCAN_TXFQS_TFQPI) >>
  404254:	68fb      	ldr	r3, [r7, #12]
	mm.idx = put_idx;
  404256:	f04f 0000 	mov.w	r0, #0
	memcpy32_volatile(msg_ram->tx_buffer[put_idx].data_32, frame->data_32,
  40425a:	f025 0503 	bic.w	r5, r5, #3
	put_idx = ((can->txfqs & CAN_MCAN_TXFQS_TFQPI) >>
  40425e:	f8d3 20c4 	ldr.w	r2, [r3, #196]	; 0xc4
  404262:	f3c2 4a04 	ubfx	sl, r2, #16, #5
	mm.cnt = data->mm.cnt++;
  404266:	f894 2182 	ldrb.w	r2, [r4, #386]	; 0x182
  40426a:	f894 1182 	ldrb.w	r1, [r4, #386]	; 0x182
  40426e:	0952      	lsrs	r2, r2, #5
	mm.idx = put_idx;
  404270:	f36a 0004 	bfi	r0, sl, #0, #5
	mm.cnt = data->mm.cnt++;
  404274:	f362 1047 	bfi	r0, r2, #5, #3
  404278:	1c56      	adds	r6, r2, #1
	if (frame->id_type == CAN_STANDARD_IDENTIFIER) {
  40427a:	f999 2003 	ldrsb.w	r2, [r9, #3]
	tx_hdr.mm = mm;
  40427e:	77f8      	strb	r0, [r7, #31]
	if (frame->id_type == CAN_STANDARD_IDENTIFIER) {
  404280:	2048      	movs	r0, #72	; 0x48
	mm.cnt = data->mm.cnt++;
  404282:	f366 1147 	bfi	r1, r6, #5, #3
	if (frame->id_type == CAN_STANDARD_IDENTIFIER) {
  404286:	2a00      	cmp	r2, #0
  404288:	fb00 f30a 	mul.w	r3, r0, sl
	mm.cnt = data->mm.cnt++;
  40428c:	f884 1182 	strb.w	r1, [r4, #386]	; 0x182
		tx_hdr.std_id = frame->id & CAN_STD_ID_MASK;
  404290:	69ba      	ldr	r2, [r7, #24]
	memcpy32_volatile(&msg_ram->tx_buffer[put_idx].hdr, &tx_hdr, sizeof(tx_hdr));
  404292:	f503 761a 	add.w	r6, r3, #616	; 0x268
  404296:	f8d9 1000 	ldr.w	r1, [r9]
  40429a:	607b      	str	r3, [r7, #4]
  40429c:	68bb      	ldr	r3, [r7, #8]
		tx_hdr.std_id = frame->id & CAN_STD_ID_MASK;
  40429e:	bfac      	ite	ge
  4042a0:	f361 429c 	bfige	r2, r1, #18, #11
		tx_hdr.ext_id = frame->id;
  4042a4:	f361 021c 	bfilt	r2, r1, #0, #29
	memcpy32_volatile(&msg_ram->tx_buffer[put_idx].hdr, &tx_hdr, sizeof(tx_hdr));
  4042a8:	f107 0118 	add.w	r1, r7, #24
  4042ac:	441e      	add	r6, r3
		tx_hdr.ext_id = frame->id;
  4042ae:	61ba      	str	r2, [r7, #24]
	memcpy32_volatile(&msg_ram->tx_buffer[put_idx].hdr, &tx_hdr, sizeof(tx_hdr));
  4042b0:	2208      	movs	r2, #8
  4042b2:	4630      	mov	r0, r6
  4042b4:	f002 fb7f 	bl	4069b6 <memcpy32_volatile>
	memcpy32_volatile(msg_ram->tx_buffer[put_idx].data_32, frame->data_32,
  4042b8:	687b      	ldr	r3, [r7, #4]
  4042ba:	462a      	mov	r2, r5
  4042bc:	f109 0108 	add.w	r1, r9, #8
  4042c0:	f503 701c 	add.w	r0, r3, #624	; 0x270
  4042c4:	68bb      	ldr	r3, [r7, #8]
  4042c6:	4418      	add	r0, r3
  4042c8:	60b8      	str	r0, [r7, #8]
  4042ca:	f002 fb74 	bl	4069b6 <memcpy32_volatile>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  4042ce:	f006 021f 	and.w	r2, r6, #31
  4042d2:	3208      	adds	r2, #8
  __ASM volatile ("dsb 0xF":::"memory");
  4042d4:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  4042d8:	4924      	ldr	r1, [pc, #144]	; (40436c <can_mcan_send+0x1fc>)
  4042da:	68b8      	ldr	r0, [r7, #8]
  4042dc:	3a20      	subs	r2, #32
  4042de:	f8c1 6268 	str.w	r6, [r1, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  4042e2:	3620      	adds	r6, #32
      } while ( op_size > 0 );
  4042e4:	2a00      	cmp	r2, #0
  4042e6:	dcf9      	bgt.n	4042dc <can_mcan_send+0x16c>
  4042e8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4042ec:	f3bf 8f6f 	isb	sy
    if ( dsize > 0 ) {
  4042f0:	b185      	cbz	r5, 404314 <can_mcan_send+0x1a4>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  4042f2:	f000 021f 	and.w	r2, r0, #31
  4042f6:	4415      	add	r5, r2
  __ASM volatile ("dsb 0xF":::"memory");
  4042f8:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  4042fc:	491b      	ldr	r1, [pc, #108]	; (40436c <can_mcan_send+0x1fc>)
      } while ( op_size > 0 );
  4042fe:	4405      	add	r5, r0
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  404300:	f8c1 0268 	str.w	r0, [r1, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  404304:	3020      	adds	r0, #32
      } while ( op_size > 0 );
  404306:	1a2a      	subs	r2, r5, r0
  404308:	2a00      	cmp	r2, #0
  40430a:	dcf9      	bgt.n	404300 <can_mcan_send+0x190>
  40430c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  404310:	f3bf 8f6f 	isb	sy
	data->tx_fin_cb[put_idx] = callback;
  404314:	eb04 028a 	add.w	r2, r4, sl, lsl #2
  404318:	6ebb      	ldr	r3, [r7, #104]	; 0x68
	data->tx_fin_cb_arg[put_idx] = user_data;
  40431a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	k_mutex_unlock(&data->tx_mtx);
  40431c:	4658      	mov	r0, fp
	data->tx_fin_cb[put_idx] = callback;
  40431e:	6493      	str	r3, [r2, #72]	; 0x48
	data->tx_fin_cb_arg[put_idx] = user_data;
  404320:	64d1      	str	r1, [r2, #76]	; 0x4c
	can->txbar = (1U << put_idx);
  404322:	2201      	movs	r2, #1
  404324:	68fb      	ldr	r3, [r7, #12]
  404326:	fa02 f20a 	lsl.w	r2, r2, sl
  40432a:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
	k_mutex_unlock(&data->tx_mtx);
  40432e:	f002 fb50 	bl	4069d2 <k_mutex_unlock.isra.0>
	if (callback == NULL) {
  404332:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  404334:	2b00      	cmp	r3, #0
  404336:	f47f af5d 	bne.w	4041f4 <can_mcan_send+0x84>
		k_sem_take(&data->tx_fin_sem[put_idx], K_FOREVER);
  40433a:	eb04 100a 	add.w	r0, r4, sl, lsl #4
	return z_impl_k_sem_take(sem, timeout);
  40433e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  404342:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  404346:	3038      	adds	r0, #56	; 0x38
  404348:	f000 fdea 	bl	404f20 <z_impl_k_sem_take>
  40434c:	e752      	b.n	4041f4 <can_mcan_send+0x84>
		return -ENETDOWN;
  40434e:	f06f 0872 	mvn.w	r8, #114	; 0x72
  404352:	e74f      	b.n	4041f4 <can_mcan_send+0x84>
		return -EAGAIN;
  404354:	f06f 080a 	mvn.w	r8, #10
  404358:	e74c      	b.n	4041f4 <can_mcan_send+0x84>
  40435a:	bf00      	nop
  40435c:	00407edc 	.word	0x00407edc
  404360:	00407e29 	.word	0x00407e29
  404364:	00407270 	.word	0x00407270
  404368:	00407e59 	.word	0x00407e59
  40436c:	e000ed00 	.word	0xe000ed00

00404370 <can_mcan_add_rx_filter_std>:
 */
int can_mcan_add_rx_filter_std(struct can_mcan_data *data,
			       struct can_mcan_msg_sram *msg_ram,
			       can_rx_callback_t callback, void *user_data,
			       const struct zcan_filter *filter)
{
  404370:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404374:	b089      	sub	sp, #36	; 0x24
  404376:	4691      	mov	r9, r2
  404378:	469a      	mov	sl, r3
	struct can_mcan_std_filter filter_element = {
  40437a:	f04f 0300 	mov.w	r3, #0
{
  40437e:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
  404382:	4605      	mov	r5, r0
  404384:	468b      	mov	fp, r1
		.id1 = filter->id,
		.id2 = filter->id_mask,
  404386:	f8d8 2004 	ldr.w	r2, [r8, #4]
	struct can_mcan_std_filter filter_element = {
  40438a:	f362 030a 	bfi	r3, r2, #0, #11
		.id1 = filter->id,
  40438e:	f8d8 2000 	ldr.w	r2, [r8]
	struct can_mcan_std_filter filter_element = {
  404392:	f8ad 3000 	strh.w	r3, [sp]
  404396:	f04f 0300 	mov.w	r3, #0
  40439a:	f362 030a 	bfi	r3, r2, #0, #11
  40439e:	2202      	movs	r2, #2
  4043a0:	f8ad 3002 	strh.w	r3, [sp, #2]
  4043a4:	f3c3 2307 	ubfx	r3, r3, #8, #8
  4043a8:	f362 1387 	bfi	r3, r2, #6, #2
  4043ac:	f88d 3003 	strb.w	r3, [sp, #3]
	for (int i = 0; i < NUM_STD_FILTER_DATA; ++i) {
  4043b0:	2400      	movs	r4, #0
	return z_impl_k_mutex_lock(mutex, timeout);
  4043b2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  4043b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  4043ba:	f000 fcd7 	bl	404d6c <z_impl_k_mutex_lock>
		if (filters[i].sfce == CAN_MCAN_FCE_DISABLE) {
  4043be:	f85b 3024 	ldr.w	r3, [fp, r4, lsl #2]
  4043c2:	00a7      	lsls	r7, r4, #2
  4043c4:	eb0b 0684 	add.w	r6, fp, r4, lsl #2
  4043c8:	f013 5f60 	tst.w	r3, #939524096	; 0x38000000
  4043cc:	d010      	beq.n	4043f0 <can_mcan_add_rx_filter_std+0x80>
	for (int i = 0; i < NUM_STD_FILTER_DATA; ++i) {
  4043ce:	3401      	adds	r4, #1
  4043d0:	2c1c      	cmp	r4, #28
  4043d2:	d1f4      	bne.n	4043be <can_mcan_add_rx_filter_std+0x4e>

	k_mutex_lock(&data->inst_mutex, K_FOREVER);
	filter_id = can_mcan_get_free_std(msg_ram->std_filt);

	if (filter_id == -ENOSPC) {
		LOG_INF("No free standard id filter left");
  4043d4:	4b27      	ldr	r3, [pc, #156]	; (404474 <can_mcan_add_rx_filter_std+0x104>)
  4043d6:	aa05      	add	r2, sp, #20
  4043d8:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
  4043dc:	4826      	ldr	r0, [pc, #152]	; (404478 <can_mcan_add_rx_filter_std+0x108>)
  4043de:	9306      	str	r3, [sp, #24]
  4043e0:	2302      	movs	r3, #2
		return -ENOSPC;
  4043e2:	f06f 041b 	mvn.w	r4, #27
		LOG_INF("No free standard id filter left");
  4043e6:	9301      	str	r3, [sp, #4]
  4043e8:	9305      	str	r3, [sp, #20]
  4043ea:	f002 faef 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		return -ENOSPC;
  4043ee:	e03c      	b.n	40446a <can_mcan_add_rx_filter_std+0xfa>
	}

	/* TODO propper fifo balancing */
	filter_element.sfce = filter_id & 0x01 ? CAN_MCAN_FCE_FIFO1 :
  4043f0:	f004 0301 	and.w	r3, r4, #1
  4043f4:	9a00      	ldr	r2, [sp, #0]
						 CAN_MCAN_FCE_FIFO0;

	memcpy32_volatile(&msg_ram->std_filt[filter_id], &filter_element,
  4043f6:	4669      	mov	r1, sp
  4043f8:	4630      	mov	r0, r6
	filter_element.sfce = filter_id & 0x01 ? CAN_MCAN_FCE_FIFO1 :
  4043fa:	3301      	adds	r3, #1
  4043fc:	f363 62dd 	bfi	r2, r3, #27, #3
  404400:	9200      	str	r2, [sp, #0]
	memcpy32_volatile(&msg_ram->std_filt[filter_id], &filter_element,
  404402:	2204      	movs	r2, #4
  404404:	f002 fad7 	bl	4069b6 <memcpy32_volatile>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  404408:	f006 031f 	and.w	r3, r6, #31
  40440c:	3304      	adds	r3, #4
  __ASM volatile ("dsb 0xF":::"memory");
  40440e:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  404412:	4a1a      	ldr	r2, [pc, #104]	; (40447c <can_mcan_add_rx_filter_std+0x10c>)
  404414:	3b20      	subs	r3, #32
  404416:	f8c2 6268 	str.w	r6, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  40441a:	3620      	adds	r6, #32
      } while ( op_size > 0 );
  40441c:	2b00      	cmp	r3, #0
  40441e:	dcf9      	bgt.n	404414 <can_mcan_add_rx_filter_std+0xa4>
  404420:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  404424:	f3bf 8f6f 	isb	sy
			 sizeof(struct can_mcan_std_filter));
	CACHE_CLEAN(&msg_ram->std_filt[filter_id],
		    sizeof(struct can_mcan_std_filter));

	k_mutex_unlock(&data->inst_mutex);
  404428:	4628      	mov	r0, r5
  40442a:	f002 fad2 	bl	4069d2 <k_mutex_unlock.isra.0>

	LOG_DBG("Attached std filter at %d", filter_id);

	if (filter->rtr) {
  40442e:	f898 2003 	ldrb.w	r2, [r8, #3]
		data->std_filt_rtr |= (1U << filter_id);
  404432:	2301      	movs	r3, #1
	} else {
		data->std_filt_rtr &= ~(1U << filter_id);
	}

	if (filter->rtr_mask) {
  404434:	f898 1007 	ldrb.w	r1, [r8, #7]
	if (filter->rtr) {
  404438:	f012 0f40 	tst.w	r2, #64	; 0x40
  40443c:	f8d5 2178 	ldr.w	r2, [r5, #376]	; 0x178
		data->std_filt_rtr |= (1U << filter_id);
  404440:	fa03 f304 	lsl.w	r3, r3, r4
  404444:	bf14      	ite	ne
  404446:	431a      	orrne	r2, r3
		data->std_filt_rtr &= ~(1U << filter_id);
  404448:	439a      	biceq	r2, r3
	if (filter->rtr_mask) {
  40444a:	0649      	lsls	r1, r1, #25
  40444c:	f8c5 2178 	str.w	r2, [r5, #376]	; 0x178
		data->std_filt_rtr_mask |= (1U << filter_id);
  404450:	f8d5 217c 	ldr.w	r2, [r5, #380]	; 0x17c
  404454:	bf4c      	ite	mi
  404456:	4313      	orrmi	r3, r2
	} else {
		data->std_filt_rtr_mask &= ~(1U << filter_id);
  404458:	ea22 0303 	bicpl.w	r3, r2, r3
  40445c:	f8c5 317c 	str.w	r3, [r5, #380]	; 0x17c
	}

	data->rx_cb_std[filter_id] = callback;
  404460:	443d      	add	r5, r7
  404462:	f8c5 9050 	str.w	r9, [r5, #80]	; 0x50
	data->cb_arg_std[filter_id] = user_data;
  404466:	f8c5 a0e0 	str.w	sl, [r5, #224]	; 0xe0

	return filter_id;
}
  40446a:	4620      	mov	r0, r4
  40446c:	b009      	add	sp, #36	; 0x24
  40446e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404472:	bf00      	nop
  404474:	00407e78 	.word	0x00407e78
  404478:	00407270 	.word	0x00407270
  40447c:	e000ed00 	.word	0xe000ed00

00404480 <can_mcan_add_rx_filter>:

int can_mcan_add_rx_filter(struct can_mcan_data *data,
			   struct can_mcan_msg_sram *msg_ram,
			   can_rx_callback_t callback, void *user_data,
			   const struct zcan_filter *filter)
{
  404480:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  404484:	b08d      	sub	sp, #52	; 0x34
  404486:	4606      	mov	r6, r0
  404488:	460d      	mov	r5, r1
  40448a:	4699      	mov	r9, r3
  40448c:	9f14      	ldr	r7, [sp, #80]	; 0x50
	int filter_id;

	if (callback == NULL) {
  40448e:	4690      	mov	r8, r2
  404490:	2a00      	cmp	r2, #0
  404492:	d045      	beq.n	404520 <can_mcan_add_rx_filter+0xa0>
		return -EINVAL;
	}

	if (filter->id_type == CAN_STANDARD_IDENTIFIER) {
  404494:	f997 4003 	ldrsb.w	r4, [r7, #3]
  404498:	2c00      	cmp	r4, #0
  40449a:	db12      	blt.n	4044c2 <can_mcan_add_rx_filter+0x42>
		filter_id = can_mcan_add_rx_filter_std(data, msg_ram, callback,
  40449c:	9700      	str	r7, [sp, #0]
  40449e:	f7ff ff67 	bl	404370 <can_mcan_add_rx_filter_std>
		filter_id = can_mcan_add_rx_filter_ext(data, msg_ram, callback,
						       user_data, filter);
		filter_id += NUM_STD_FILTER_DATA;
	}

	if (filter_id == -ENOSPC) {
  4044a2:	f110 0f1c 	cmn.w	r0, #28
		filter_id = can_mcan_add_rx_filter_std(data, msg_ram, callback,
  4044a6:	4604      	mov	r4, r0
	if (filter_id == -ENOSPC) {
  4044a8:	d17e      	bne.n	4045a8 <can_mcan_add_rx_filter+0x128>
		LOG_INF("No free filter left");
  4044aa:	4b41      	ldr	r3, [pc, #260]	; (4045b0 <can_mcan_add_rx_filter+0x130>)
  4044ac:	aa09      	add	r2, sp, #36	; 0x24
  4044ae:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
  4044b2:	4840      	ldr	r0, [pc, #256]	; (4045b4 <can_mcan_add_rx_filter+0x134>)
  4044b4:	930a      	str	r3, [sp, #40]	; 0x28
  4044b6:	2302      	movs	r3, #2
  4044b8:	9304      	str	r3, [sp, #16]
  4044ba:	9309      	str	r3, [sp, #36]	; 0x24
  4044bc:	f002 fa86 	bl	4069cc <z_log_msg2_static_create.constprop.0>
  4044c0:	e072      	b.n	4045a8 <can_mcan_add_rx_filter+0x128>
	struct can_mcan_ext_filter filter_element = {
  4044c2:	2400      	movs	r4, #0
		.id1 = filter->id,
  4044c4:	683a      	ldr	r2, [r7, #0]
	struct can_mcan_ext_filter filter_element = {
  4044c6:	4623      	mov	r3, r4
  4044c8:	f362 031c 	bfi	r3, r2, #0, #29
		.id2 = filter->id_mask,
  4044cc:	687a      	ldr	r2, [r7, #4]
	struct can_mcan_ext_filter filter_element = {
  4044ce:	9304      	str	r3, [sp, #16]
  4044d0:	4623      	mov	r3, r4
  4044d2:	f362 031c 	bfi	r3, r2, #0, #29
  4044d6:	2202      	movs	r2, #2
  4044d8:	9305      	str	r3, [sp, #20]
  4044da:	f3c3 6307 	ubfx	r3, r3, #24, #8
  4044de:	f362 1387 	bfi	r3, r2, #6, #2
  4044e2:	f88d 3017 	strb.w	r3, [sp, #23]
  4044e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  4044ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  4044ee:	f000 fc3d 	bl	404d6c <z_impl_k_mutex_lock>
	for (int i = 0; i < NUM_EXT_FILTER_DATA; ++i) {
  4044f2:	f105 0370 	add.w	r3, r5, #112	; 0x70
		if (filters[i].efce == CAN_MCAN_FCE_DISABLE) {
  4044f6:	681a      	ldr	r2, [r3, #0]
  4044f8:	0f52      	lsrs	r2, r2, #29
  4044fa:	d014      	beq.n	404526 <can_mcan_add_rx_filter+0xa6>
	for (int i = 0; i < NUM_EXT_FILTER_DATA; ++i) {
  4044fc:	3401      	adds	r4, #1
  4044fe:	3308      	adds	r3, #8
  404500:	2c08      	cmp	r4, #8
  404502:	d1f8      	bne.n	4044f6 <can_mcan_add_rx_filter+0x76>
		LOG_INF("No free extended id filter left");
  404504:	4b2c      	ldr	r3, [pc, #176]	; (4045b8 <can_mcan_add_rx_filter+0x138>)
  404506:	aa09      	add	r2, sp, #36	; 0x24
  404508:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
  40450c:	4829      	ldr	r0, [pc, #164]	; (4045b4 <can_mcan_add_rx_filter+0x134>)
  40450e:	930a      	str	r3, [sp, #40]	; 0x28
  404510:	2302      	movs	r3, #2
		return -ENOSPC;
  404512:	f06f 041b 	mvn.w	r4, #27
		LOG_INF("No free extended id filter left");
  404516:	9303      	str	r3, [sp, #12]
  404518:	9309      	str	r3, [sp, #36]	; 0x24
  40451a:	f002 fa57 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		return -ENOSPC;
  40451e:	e042      	b.n	4045a6 <can_mcan_add_rx_filter+0x126>
		return -EINVAL;
  404520:	f06f 0415 	mvn.w	r4, #21
  404524:	e040      	b.n	4045a8 <can_mcan_add_rx_filter+0x128>
	filter_element.efce = filter_id & 0x01 ? CAN_MCAN_FCE_FIFO1 :
  404526:	f004 0301 	and.w	r3, r4, #1
  40452a:	9a04      	ldr	r2, [sp, #16]
	memcpy32_volatile(&msg_ram->ext_filt[filter_id], &filter_element,
  40452c:	f104 000e 	add.w	r0, r4, #14
  404530:	a904      	add	r1, sp, #16
	filter_element.efce = filter_id & 0x01 ? CAN_MCAN_FCE_FIFO1 :
  404532:	3301      	adds	r3, #1
	memcpy32_volatile(&msg_ram->ext_filt[filter_id], &filter_element,
  404534:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
	filter_element.efce = filter_id & 0x01 ? CAN_MCAN_FCE_FIFO1 :
  404538:	f363 725f 	bfi	r2, r3, #29, #3
	memcpy32_volatile(&msg_ram->ext_filt[filter_id], &filter_element,
  40453c:	4628      	mov	r0, r5
	filter_element.efce = filter_id & 0x01 ? CAN_MCAN_FCE_FIFO1 :
  40453e:	9204      	str	r2, [sp, #16]
	memcpy32_volatile(&msg_ram->ext_filt[filter_id], &filter_element,
  404540:	2208      	movs	r2, #8
  404542:	f002 fa38 	bl	4069b6 <memcpy32_volatile>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  404546:	f005 031f 	and.w	r3, r5, #31
  40454a:	3308      	adds	r3, #8
  __ASM volatile ("dsb 0xF":::"memory");
  40454c:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  404550:	4a1a      	ldr	r2, [pc, #104]	; (4045bc <can_mcan_add_rx_filter+0x13c>)
  404552:	3b20      	subs	r3, #32
  404554:	f8c2 5268 	str.w	r5, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  404558:	3520      	adds	r5, #32
      } while ( op_size > 0 );
  40455a:	2b00      	cmp	r3, #0
  40455c:	dcf9      	bgt.n	404552 <can_mcan_add_rx_filter+0xd2>
  40455e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  404562:	f3bf 8f6f 	isb	sy
	k_mutex_unlock(&data->inst_mutex);
  404566:	4630      	mov	r0, r6
  404568:	f002 fa33 	bl	4069d2 <k_mutex_unlock.isra.0>
		data->ext_filt_rtr |= (1U << filter_id);
  40456c:	2301      	movs	r3, #1
	if (filter->rtr) {
  40456e:	78fa      	ldrb	r2, [r7, #3]
		data->ext_filt_rtr |= (1U << filter_id);
  404570:	40a3      	lsls	r3, r4
	if (filter->rtr) {
  404572:	f012 0f40 	tst.w	r2, #64	; 0x40
  404576:	f896 2180 	ldrb.w	r2, [r6, #384]	; 0x180
		data->ext_filt_rtr |= (1U << filter_id);
  40457a:	b2db      	uxtb	r3, r3
  40457c:	bf14      	ite	ne
  40457e:	431a      	orrne	r2, r3
		data->ext_filt_rtr &= ~(1U << filter_id);
  404580:	439a      	biceq	r2, r3
  404582:	f886 2180 	strb.w	r2, [r6, #384]	; 0x180
	if (filter->rtr_mask) {
  404586:	79f9      	ldrb	r1, [r7, #7]
		data->ext_filt_rtr_mask |= (1U << filter_id);
  404588:	f896 2181 	ldrb.w	r2, [r6, #385]	; 0x181
	if (filter->rtr_mask) {
  40458c:	0649      	lsls	r1, r1, #25
		data->ext_filt_rtr_mask |= (1U << filter_id);
  40458e:	bf4c      	ite	mi
  404590:	4313      	orrmi	r3, r2
		data->ext_filt_rtr_mask &= ~(1U << filter_id);
  404592:	ea22 0303 	bicpl.w	r3, r2, r3
  404596:	f886 3181 	strb.w	r3, [r6, #385]	; 0x181
	data->rx_cb_ext[filter_id] = callback;
  40459a:	eb06 0684 	add.w	r6, r6, r4, lsl #2
  40459e:	f8c6 80c0 	str.w	r8, [r6, #192]	; 0xc0
	data->cb_arg_ext[filter_id] = user_data;
  4045a2:	f8c6 9150 	str.w	r9, [r6, #336]	; 0x150
		filter_id += NUM_STD_FILTER_DATA;
  4045a6:	341c      	adds	r4, #28
	}

	return filter_id;
}
  4045a8:	4620      	mov	r0, r4
  4045aa:	b00d      	add	sp, #52	; 0x34
  4045ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4045b0:	00407e98 	.word	0x00407e98
  4045b4:	00407270 	.word	0x00407270
  4045b8:	00407eac 	.word	0x00407eac
  4045bc:	e000ed00 	.word	0xe000ed00

004045c0 <can_mcan_remove_rx_filter>:

void can_mcan_remove_rx_filter(struct can_mcan_data *data,
			       struct can_mcan_msg_sram *msg_ram, int filter_id)
{
  4045c0:	b570      	push	{r4, r5, r6, lr}
  4045c2:	4606      	mov	r6, r0
  4045c4:	b088      	sub	sp, #32
  4045c6:	460c      	mov	r4, r1
  4045c8:	4615      	mov	r5, r2
  4045ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  4045ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  4045d2:	f000 fbcb 	bl	404d6c <z_impl_k_mutex_lock>
	k_mutex_lock(&data->inst_mutex, K_FOREVER);
	if (filter_id >= NUM_STD_FILTER_DATA) {
  4045d6:	2d1b      	cmp	r5, #27
  4045d8:	dd2d      	ble.n	404636 <can_mcan_remove_rx_filter+0x76>
		filter_id -= NUM_STD_FILTER_DATA;
  4045da:	f1a5 031c 	sub.w	r3, r5, #28
		if (filter_id >= NUM_STD_FILTER_DATA) {
  4045de:	2b1b      	cmp	r3, #27
  4045e0:	dd0c      	ble.n	4045fc <can_mcan_remove_rx_filter+0x3c>
			LOG_ERR("Wrong filter id");
  4045e2:	4b1e      	ldr	r3, [pc, #120]	; (40465c <can_mcan_remove_rx_filter+0x9c>)
  4045e4:	aa05      	add	r2, sp, #20
  4045e6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  4045ea:	481d      	ldr	r0, [pc, #116]	; (404660 <can_mcan_remove_rx_filter+0xa0>)
  4045ec:	9306      	str	r3, [sp, #24]
  4045ee:	2302      	movs	r3, #2
  4045f0:	9301      	str	r3, [sp, #4]
  4045f2:	9305      	str	r3, [sp, #20]
  4045f4:	f002 f9ea 	bl	4069cc <z_log_msg2_static_create.constprop.0>
		CACHE_CLEAN(&msg_ram->std_filt[filter_id],
			    sizeof(struct can_mcan_std_filter));
	}

	k_mutex_unlock(&data->inst_mutex);
}
  4045f8:	b008      	add	sp, #32
  4045fa:	bd70      	pop	{r4, r5, r6, pc}
		memset32_volatile(&msg_ram->ext_filt[filter_id], 0,
  4045fc:	3d0e      	subs	r5, #14
		*dst++ = val;
  4045fe:	2200      	movs	r2, #0
		memset32_volatile(&msg_ram->ext_filt[filter_id], 0,
  404600:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
		*dst++ = val;
  404604:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
  404608:	605a      	str	r2, [r3, #4]
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  40460a:	f003 021f 	and.w	r2, r3, #31
  40460e:	3208      	adds	r2, #8
  __ASM volatile ("dsb 0xF":::"memory");
  404610:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  404614:	4913      	ldr	r1, [pc, #76]	; (404664 <can_mcan_remove_rx_filter+0xa4>)
  404616:	3a20      	subs	r2, #32
  404618:	f8c1 3268 	str.w	r3, [r1, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  40461c:	3320      	adds	r3, #32
      } while ( op_size > 0 );
  40461e:	2a00      	cmp	r2, #0
  404620:	dcf9      	bgt.n	404616 <can_mcan_remove_rx_filter+0x56>
  404622:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  404626:	f3bf 8f6f 	isb	sy
	k_mutex_unlock(&data->inst_mutex);
  40462a:	4630      	mov	r0, r6
}
  40462c:	b008      	add	sp, #32
  40462e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_mutex_unlock(&data->inst_mutex);
  404632:	f002 b9ce 	b.w	4069d2 <k_mutex_unlock.isra.0>
		*dst++ = val;
  404636:	2300      	movs	r3, #0
  404638:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
  40463c:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  404640:	f004 031f 	and.w	r3, r4, #31
  404644:	3304      	adds	r3, #4
  __ASM volatile ("dsb 0xF":::"memory");
  404646:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
  40464a:	4a06      	ldr	r2, [pc, #24]	; (404664 <can_mcan_remove_rx_filter+0xa4>)
  40464c:	3b20      	subs	r3, #32
  40464e:	f8c2 4268 	str.w	r4, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
  404652:	3420      	adds	r4, #32
      } while ( op_size > 0 );
  404654:	2b00      	cmp	r3, #0
  404656:	dcf9      	bgt.n	40464c <can_mcan_remove_rx_filter+0x8c>
  404658:	e7e3      	b.n	404622 <can_mcan_remove_rx_filter+0x62>
  40465a:	bf00      	nop
  40465c:	00407ecc 	.word	0x00407ecc
  404660:	00407270 	.word	0x00407270
  404664:	e000ed00 	.word	0xe000ed00

00404668 <can_sam_get_core_clock>:
};


static int can_sam_get_core_clock(const struct device *dev, uint32_t *rate)
{
	*rate = SOC_ATMEL_SAM_MCK_FREQ_HZ / (CONFIG_CAN_SAM_CKDIV + 1); //we put here instead of 1 we put 3
  404668:	4b01      	ldr	r3, [pc, #4]	; (404670 <can_sam_get_core_clock+0x8>)
	return 0;
}
  40466a:	2000      	movs	r0, #0
	*rate = SOC_ATMEL_SAM_MCK_FREQ_HZ / (CONFIG_CAN_SAM_CKDIV + 1); //we put here instead of 1 we put 3
  40466c:	600b      	str	r3, [r1, #0]
}
  40466e:	4770      	bx	lr
  404670:	01c9c380 	.word	0x01c9c380

00404674 <can_sam_init>:
	PMC->PMC_SCER = PMC_SCER_PCK5; // enable clock 5*/

}

static int can_sam_init(const struct device *dev)
{
  404674:	b570      	push	{r4, r5, r6, lr}
	REG_PMC_PCK5 = PMC_PCK_CSS_PLLA_CLK | PMC_PCK_PRES(CONFIG_CAN_SAM_CKDIV); //umjesto PLLA STAVILI SMO UPLL
  404676:	4b11      	ldr	r3, [pc, #68]	; (4046bc <can_sam_init+0x48>)
  404678:	2242      	movs	r2, #66	; 0x42
	const struct can_sam_config *cfg = dev->config;
  40467a:	6845      	ldr	r5, [r0, #4]
{
  40467c:	4604      	mov	r4, r0
	PMC->PMC_SCER |= PMC_SCER_PCK5;
  40467e:	4910      	ldr	r1, [pc, #64]	; (4046c0 <can_sam_init+0x4c>)
	const struct can_mcan_config *mcan_cfg = &cfg->mcan_cfg;
	struct can_sam_data *data = dev->data;
  404680:	6906      	ldr	r6, [r0, #16]
	struct can_mcan_data *mcan_data = &data->mcan_data;
	struct can_mcan_msg_sram *msg_ram = &data->msg_ram;
	int ret;

	can_sam_clock_enable(cfg);
  404682:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
	REG_PMC_PCK5 = PMC_PCK_CSS_PLLA_CLK | PMC_PCK_PRES(CONFIG_CAN_SAM_CKDIV); //umjesto PLLA STAVILI SMO UPLL
  404686:	f8c3 2654 	str.w	r2, [r3, #1620]	; 0x654
	PMC->PMC_SCER |= PMC_SCER_PCK5;
  40468a:	680a      	ldr	r2, [r1, #0]
  40468c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  404690:	600a      	str	r2, [r1, #0]
	soc_pmc_peripheral_enable(cfg->pmc_id);
  404692:	f7fd fd55 	bl	402140 <soc_pmc_peripheral_enable>
	soc_gpio_list_configure(cfg->pin_list, ARRAY_SIZE(cfg->pin_list));
  404696:	2102      	movs	r1, #2
  404698:	f105 0020 	add.w	r0, r5, #32
  40469c:	f001 fe8f 	bl	4063be <soc_gpio_list_configure>
	ret = can_mcan_init(dev, mcan_cfg, msg_ram, mcan_data);
  4046a0:	4620      	mov	r0, r4
  4046a2:	4633      	mov	r3, r6
  4046a4:	f506 72c2 	add.w	r2, r6, #388	; 0x184
  4046a8:	4629      	mov	r1, r5
  4046aa:	f7ff fb2d 	bl	403d08 <can_mcan_init>
	if (ret) {
  4046ae:	4604      	mov	r4, r0
  4046b0:	b908      	cbnz	r0, 4046b6 <can_sam_init+0x42>
		return ret;
	}

	cfg->config_irq();
  4046b2:	69eb      	ldr	r3, [r5, #28]
  4046b4:	4798      	blx	r3

	return ret;
}
  4046b6:	4620      	mov	r0, r4
  4046b8:	bd70      	pop	{r4, r5, r6, pc}
  4046ba:	bf00      	nop
  4046bc:	400e0000 	.word	0x400e0000
  4046c0:	400e0600 	.word	0x400e0600

004046c4 <uart_sam_init>:
static int baudrate_set(Uart *const uart, uint32_t baudrate,
			uint32_t mck_freq_hz);


static int uart_sam_init(const struct device *dev)
{
  4046c4:	b570      	push	{r4, r5, r6, lr}
	int retval;
	const struct uart_sam_dev_cfg *const cfg = dev->config;
  4046c6:	6845      	ldr	r5, [r0, #4]
	struct uart_sam_dev_data *const dev_data = dev->data;
  4046c8:	6906      	ldr	r6, [r0, #16]
	Uart *const uart = cfg->regs;

	/* Enable UART clock in PMC */
	soc_pmc_peripheral_enable(cfg->periph_id);
  4046ca:	e9d5 4000 	ldrd	r4, r0, [r5]
  4046ce:	f7fd fd37 	bl	402140 <soc_pmc_peripheral_enable>

	/* Connect pins to the peripheral */
	soc_gpio_configure(&cfg->pin_rx);
  4046d2:	f105 0008 	add.w	r0, r5, #8
  4046d6:	f001 fdf9 	bl	4062cc <soc_gpio_configure>
	soc_gpio_configure(&cfg->pin_tx);
  4046da:	f105 0018 	add.w	r0, r5, #24
  4046de:	f001 fdf5 	bl	4062cc <soc_gpio_configure>

	/* Reset and disable UART */
	uart->UART_CR =   UART_CR_RSTRX | UART_CR_RSTTX
  4046e2:	f44f 73d6 	mov.w	r3, #428	; 0x1ac
	__ASSERT(baudrate,
		 "baud rate has to be bigger than 0");
	__ASSERT(mck_freq_hz/16U >= baudrate,
		 "MCK frequency is too small to set required baud rate");

	divisor = mck_freq_hz / 16U / baudrate;
  4046e6:	6832      	ldr	r2, [r6, #0]
	uart->UART_CR =   UART_CR_RSTRX | UART_CR_RSTTX
  4046e8:	6023      	str	r3, [r4, #0]
	uart->UART_IDR = 0xFFFFFFFF;
  4046ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  4046ee:	60e3      	str	r3, [r4, #12]
	uart->UART_MR =   UART_MR_PAR_NO
  4046f0:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4046f4:	6063      	str	r3, [r4, #4]
	divisor = mck_freq_hz / 16U / baudrate;
  4046f6:	4b07      	ldr	r3, [pc, #28]	; (404714 <uart_sam_init+0x50>)
  4046f8:	fbb3 f3f2 	udiv	r3, r3, r2

	if (divisor > 0xFFFF) {
  4046fc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  404700:	d204      	bcs.n	40470c <uart_sam_init+0x48>
		return -EINVAL;
	}

	uart->UART_BRGR = UART_BRGR_CD(divisor);
  404702:	6223      	str	r3, [r4, #32]
	return 0;
  404704:	2000      	movs	r0, #0
	uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  404706:	2350      	movs	r3, #80	; 0x50
  404708:	6023      	str	r3, [r4, #0]
}
  40470a:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
  40470c:	f06f 0015 	mvn.w	r0, #21
  404710:	e7fb      	b.n	40470a <uart_sam_init+0x46>
  404712:	bf00      	nop
  404714:	008f0d18 	.word	0x008f0d18

00404718 <elapsed>:
 *     - and until the current call of the function is completed.
 * - the function is invoked with interrupts disabled.
 */
static uint32_t elapsed(void)
{
	uint32_t val1 = SysTick->VAL;	/* A */
  404718:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
  40471c:	699a      	ldr	r2, [r3, #24]
	uint32_t ctrl = SysTick->CTRL;	/* B */
  40471e:	6919      	ldr	r1, [r3, #16]
	uint32_t val2 = SysTick->VAL;	/* C */
  404720:	6998      	ldr	r0, [r3, #24]
	 * 4) After C we'll see it next time
	 *
	 * So the count in val2 is post-wrap and last_load needs to be
	 * added if and only if COUNTFLAG is set or val1 < val2.
	 */
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
  404722:	f411 3f80 	tst.w	r1, #65536	; 0x10000
  404726:	4b09      	ldr	r3, [pc, #36]	; (40474c <elapsed+0x34>)
  404728:	4909      	ldr	r1, [pc, #36]	; (404750 <elapsed+0x38>)
{
  40472a:	b510      	push	{r4, lr}
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
  40472c:	d101      	bne.n	404732 <elapsed+0x1a>
	    || (val1 < val2)) {
  40472e:	4282      	cmp	r2, r0
  404730:	d206      	bcs.n	404740 <elapsed+0x28>
		overflow_cyc += last_load;
  404732:	681a      	ldr	r2, [r3, #0]
  404734:	680c      	ldr	r4, [r1, #0]
  404736:	4422      	add	r2, r4
  404738:	601a      	str	r2, [r3, #0]

		/* We know there was a wrap, but we might not have
		 * seen it in CTRL, so clear it. */
		(void)SysTick->CTRL;
  40473a:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
  40473e:	6912      	ldr	r2, [r2, #16]
	}

	return (last_load - val2) + overflow_cyc;
  404740:	681b      	ldr	r3, [r3, #0]
  404742:	680a      	ldr	r2, [r1, #0]
  404744:	4413      	add	r3, r2
}
  404746:	1a18      	subs	r0, r3, r0
  404748:	bd10      	pop	{r4, pc}
  40474a:	bf00      	nop
  40474c:	20400bd0 	.word	0x20400bd0
  404750:	20400bcc 	.word	0x20400bcc

00404754 <sys_clock_driver_init>:
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  404754:	4b09      	ldr	r3, [pc, #36]	; (40477c <sys_clock_driver_init+0x28>)
  404756:	2220      	movs	r2, #32
{
	ARG_UNUSED(dev);

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
	overflow_cyc = 0U;
  404758:	2000      	movs	r0, #0
  40475a:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	last_load = CYC_PER_TICK - 1;
  40475e:	f247 522f 	movw	r2, #29999	; 0x752f
  404762:	4b07      	ldr	r3, [pc, #28]	; (404780 <sys_clock_driver_init+0x2c>)
  404764:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
  404766:	4b07      	ldr	r3, [pc, #28]	; (404784 <sys_clock_driver_init+0x30>)
  404768:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
  40476a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
  40476e:	615a      	str	r2, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
  404770:	6198      	str	r0, [r3, #24]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
  404772:	691a      	ldr	r2, [r3, #16]
  404774:	f042 0207 	orr.w	r2, r2, #7
  404778:	611a      	str	r2, [r3, #16]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
  40477a:	4770      	bx	lr
  40477c:	e000ed00 	.word	0xe000ed00
  404780:	20400bcc 	.word	0x20400bcc
  404784:	20400bd0 	.word	0x20400bd0

00404788 <sys_clock_isr>:
{
  404788:	b508      	push	{r3, lr}
	elapsed();
  40478a:	f7ff ffc5 	bl	404718 <elapsed>
	cycle_count += overflow_cyc;
  40478e:	4b0c      	ldr	r3, [pc, #48]	; (4047c0 <sys_clock_isr+0x38>)
  404790:	4a0c      	ldr	r2, [pc, #48]	; (4047c4 <sys_clock_isr+0x3c>)
  404792:	6818      	ldr	r0, [r3, #0]
  404794:	6811      	ldr	r1, [r2, #0]
  404796:	4408      	add	r0, r1
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
  404798:	f247 5130 	movw	r1, #30000	; 0x7530
	cycle_count += overflow_cyc;
  40479c:	6010      	str	r0, [r2, #0]
	overflow_cyc = 0;
  40479e:	2200      	movs	r2, #0
  4047a0:	601a      	str	r2, [r3, #0]
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
  4047a2:	4a09      	ldr	r2, [pc, #36]	; (4047c8 <sys_clock_isr+0x40>)
  4047a4:	6813      	ldr	r3, [r2, #0]
  4047a6:	1ac0      	subs	r0, r0, r3
  4047a8:	fbb0 f0f1 	udiv	r0, r0, r1
		announced_cycles += dticks * CYC_PER_TICK;
  4047ac:	fb01 3300 	mla	r3, r1, r0, r3
  4047b0:	6013      	str	r3, [r2, #0]
		sys_clock_announce(dticks);
  4047b2:	f001 f8db 	bl	40596c <sys_clock_announce>
}
  4047b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
  4047ba:	f7fe baa1 	b.w	402d00 <z_arm_exc_exit>
  4047be:	bf00      	nop
  4047c0:	20400bd0 	.word	0x20400bd0
  4047c4:	20400bc8 	.word	0x20400bc8
  4047c8:	20400bc4 	.word	0x20400bc4

004047cc <sys_clock_set_timeout>:
{
  4047cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4047ce:	4c33      	ldr	r4, [pc, #204]	; (40489c <sys_clock_set_timeout+0xd0>)
	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
  4047d0:	b159      	cbz	r1, 4047ea <sys_clock_set_timeout+0x1e>
  4047d2:	1c42      	adds	r2, r0, #1
  4047d4:	d109      	bne.n	4047ea <sys_clock_set_timeout+0x1e>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
  4047d6:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
  4047da:	6913      	ldr	r3, [r2, #16]
  4047dc:	f023 0301 	bic.w	r3, r3, #1
  4047e0:	6113      	str	r3, [r2, #16]
		last_load = TIMER_STOPPED;
  4047e2:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
  4047e6:	6023      	str	r3, [r4, #0]
}
  4047e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
  4047ea:	1c43      	adds	r3, r0, #1
	uint32_t last_load_ = last_load;
  4047ec:	6826      	ldr	r6, [r4, #0]
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
  4047ee:	d023      	beq.n	404838 <sys_clock_set_timeout+0x6c>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
  4047f0:	2801      	cmp	r0, #1
  4047f2:	dd24      	ble.n	40483e <sys_clock_set_timeout+0x72>
  4047f4:	f240 232e 	movw	r3, #558	; 0x22e
  4047f8:	4298      	cmp	r0, r3
  4047fa:	dc22      	bgt.n	404842 <sys_clock_set_timeout+0x76>
  4047fc:	1e47      	subs	r7, r0, #1
	__asm__ volatile(
  4047fe:	f04f 0320 	mov.w	r3, #32
  404802:	f3ef 8511 	mrs	r5, BASEPRI
  404806:	f383 8812 	msr	BASEPRI_MAX, r3
  40480a:	f3bf 8f6f 	isb	sy
	uint32_t pending = elapsed();
  40480e:	f7ff ff83 	bl	404718 <elapsed>
	val1 = SysTick->VAL;
  404812:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	cycle_count += pending;
  404816:	4922      	ldr	r1, [pc, #136]	; (4048a0 <sys_clock_set_timeout+0xd4>)
	overflow_cyc = 0U;
  404818:	2200      	movs	r2, #0
	val1 = SysTick->VAL;
  40481a:	f8d3 c018 	ldr.w	ip, [r3, #24]
	cycle_count += pending;
  40481e:	680b      	ldr	r3, [r1, #0]
  404820:	4418      	add	r0, r3
	overflow_cyc = 0U;
  404822:	4b20      	ldr	r3, [pc, #128]	; (4048a4 <sys_clock_set_timeout+0xd8>)
  404824:	601a      	str	r2, [r3, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
  404826:	4b20      	ldr	r3, [pc, #128]	; (4048a8 <sys_clock_set_timeout+0xdc>)
	cycle_count += pending;
  404828:	6008      	str	r0, [r1, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
  40482a:	681a      	ldr	r2, [r3, #0]
	if ((int32_t)unannounced < 0) {
  40482c:	1a83      	subs	r3, r0, r2
  40482e:	d50a      	bpl.n	404846 <sys_clock_set_timeout+0x7a>
		last_load = MIN_DELAY;
  404830:	f240 7353 	movw	r3, #1875	; 0x753
			last_load = delay;
  404834:	6023      	str	r3, [r4, #0]
  404836:	e01a      	b.n	40486e <sys_clock_set_timeout+0xa2>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
  404838:	f240 202e 	movw	r0, #558	; 0x22e
  40483c:	e7de      	b.n	4047fc <sys_clock_set_timeout+0x30>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
  40483e:	2700      	movs	r7, #0
  404840:	e7dd      	b.n	4047fe <sys_clock_set_timeout+0x32>
  404842:	461f      	mov	r7, r3
  404844:	e7db      	b.n	4047fe <sys_clock_set_timeout+0x32>
		delay = ticks * CYC_PER_TICK;
  404846:	f247 5e30 	movw	lr, #30000	; 0x7530
		delay -= unannounced;
  40484a:	1a12      	subs	r2, r2, r0
		delay += unannounced;
  40484c:	fb0e 3307 	mla	r3, lr, r7, r3
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
  404850:	f503 43ea 	add.w	r3, r3, #29952	; 0x7500
  404854:	332f      	adds	r3, #47	; 0x2f
  404856:	fbb3 f3fe 	udiv	r3, r3, lr
		delay -= unannounced;
  40485a:	fb0e 2303 	mla	r3, lr, r3, r2
		delay = MAX(delay, MIN_DELAY);
  40485e:	f240 7253 	movw	r2, #1875	; 0x753
  404862:	4293      	cmp	r3, r2
  404864:	d918      	bls.n	404898 <sys_clock_set_timeout+0xcc>
		if (delay > MAX_CYCLES) {
  404866:	4a11      	ldr	r2, [pc, #68]	; (4048ac <sys_clock_set_timeout+0xe0>)
  404868:	4293      	cmp	r3, r2
  40486a:	d9e3      	bls.n	404834 <sys_clock_set_timeout+0x68>
			last_load = MAX_CYCLES;
  40486c:	6022      	str	r2, [r4, #0]
	val2 = SysTick->VAL;
  40486e:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
	SysTick->LOAD = last_load - 1;
  404872:	6824      	ldr	r4, [r4, #0]
	val2 = SysTick->VAL;
  404874:	6993      	ldr	r3, [r2, #24]
	SysTick->LOAD = last_load - 1;
  404876:	3c01      	subs	r4, #1
	if (val1 < val2) {
  404878:	459c      	cmp	ip, r3
	SysTick->LOAD = last_load - 1;
  40487a:	6154      	str	r4, [r2, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
  40487c:	f04f 0400 	mov.w	r4, #0
		cycle_count += (val1 + (last_load_ - val2));
  404880:	bf38      	it	cc
  404882:	44b4      	addcc	ip, r6
	SysTick->VAL = 0; /* resets timer to last_load */
  404884:	6194      	str	r4, [r2, #24]
		cycle_count += (val1 - val2);
  404886:	ebac 0c03 	sub.w	ip, ip, r3
  40488a:	4460      	add	r0, ip
  40488c:	6008      	str	r0, [r1, #0]
	__asm__ volatile(
  40488e:	f385 8811 	msr	BASEPRI, r5
  404892:	f3bf 8f6f 	isb	sy
  404896:	e7a7      	b.n	4047e8 <sys_clock_set_timeout+0x1c>
		delay = MAX(delay, MIN_DELAY);
  404898:	4613      	mov	r3, r2
  40489a:	e7cb      	b.n	404834 <sys_clock_set_timeout+0x68>
  40489c:	20400bcc 	.word	0x20400bcc
  4048a0:	20400bc8 	.word	0x20400bc8
  4048a4:	20400bd0 	.word	0x20400bd0
  4048a8:	20400bc4 	.word	0x20400bc4
  4048ac:	00ff6ea0 	.word	0x00ff6ea0

004048b0 <sys_clock_elapsed>:
{
  4048b0:	b510      	push	{r4, lr}
	__asm__ volatile(
  4048b2:	f04f 0320 	mov.w	r3, #32
  4048b6:	f3ef 8411 	mrs	r4, BASEPRI
  4048ba:	f383 8812 	msr	BASEPRI_MAX, r3
  4048be:	f3bf 8f6f 	isb	sy
	uint32_t cyc = elapsed() + cycle_count - announced_cycles;
  4048c2:	f7ff ff29 	bl	404718 <elapsed>
  4048c6:	4b07      	ldr	r3, [pc, #28]	; (4048e4 <sys_clock_elapsed+0x34>)
  4048c8:	4a07      	ldr	r2, [pc, #28]	; (4048e8 <sys_clock_elapsed+0x38>)
  4048ca:	681b      	ldr	r3, [r3, #0]
  4048cc:	6812      	ldr	r2, [r2, #0]
  4048ce:	1a9b      	subs	r3, r3, r2
  4048d0:	4403      	add	r3, r0
	__asm__ volatile(
  4048d2:	f384 8811 	msr	BASEPRI, r4
  4048d6:	f3bf 8f6f 	isb	sy
}
  4048da:	f247 5030 	movw	r0, #30000	; 0x7530
  4048de:	fbb3 f0f0 	udiv	r0, r3, r0
  4048e2:	bd10      	pop	{r4, pc}
  4048e4:	20400bc8 	.word	0x20400bc8
  4048e8:	20400bc4 	.word	0x20400bc4

004048ec <sys_clock_cycle_get_32>:
{
  4048ec:	b510      	push	{r4, lr}
	__asm__ volatile(
  4048ee:	f04f 0320 	mov.w	r3, #32
  4048f2:	f3ef 8411 	mrs	r4, BASEPRI
  4048f6:	f383 8812 	msr	BASEPRI_MAX, r3
  4048fa:	f3bf 8f6f 	isb	sy
	uint32_t ret = elapsed() + cycle_count;
  4048fe:	f7ff ff0b 	bl	404718 <elapsed>
  404902:	4b04      	ldr	r3, [pc, #16]	; (404914 <sys_clock_cycle_get_32+0x28>)
  404904:	681b      	ldr	r3, [r3, #0]
  404906:	4418      	add	r0, r3
	__asm__ volatile(
  404908:	f384 8811 	msr	BASEPRI, r4
  40490c:	f3bf 8f6f 	isb	sy
}
  404910:	bd10      	pop	{r4, pc}
  404912:	bf00      	nop
  404914:	20400bc8 	.word	0x20400bc8

00404918 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  404918:	4b0e      	ldr	r3, [pc, #56]	; (404954 <z_sys_init_run_level+0x3c>)
{
  40491a:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40491c:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
  404920:	3001      	adds	r0, #1
  404922:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
  404926:	42a6      	cmp	r6, r4
  404928:	d800      	bhi.n	40492c <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
  40492a:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
  40492c:	e9d4 3500 	ldrd	r3, r5, [r4]
  404930:	4628      	mov	r0, r5
  404932:	4798      	blx	r3
		if (dev != NULL) {
  404934:	b165      	cbz	r5, 404950 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
  404936:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
  404938:	b130      	cbz	r0, 404948 <z_sys_init_run_level+0x30>
				if (rc < 0) {
  40493a:	2800      	cmp	r0, #0
  40493c:	bfb8      	it	lt
  40493e:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
  404940:	28ff      	cmp	r0, #255	; 0xff
  404942:	bfa8      	it	ge
  404944:	20ff      	movge	r0, #255	; 0xff
  404946:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
  404948:	785a      	ldrb	r2, [r3, #1]
  40494a:	f042 0201 	orr.w	r2, r2, #1
  40494e:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  404950:	3408      	adds	r4, #8
  404952:	e7e8      	b.n	404926 <z_sys_init_run_level+0xe>
  404954:	00407540 	.word	0x00407540

00404958 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  404958:	b510      	push	{r4, lr}
  40495a:	4604      	mov	r4, r0
  40495c:	b088      	sub	sp, #32
	z_impl_log_panic();
  40495e:	f7fd fdbb 	bl	4024d8 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  404962:	4b07      	ldr	r3, [pc, #28]	; (404980 <k_sys_fatal_error_handler+0x28>)
  404964:	9306      	str	r3, [sp, #24]
  404966:	2302      	movs	r3, #2
  404968:	9301      	str	r3, [sp, #4]
  40496a:	9305      	str	r3, [sp, #20]
  40496c:	4805      	ldr	r0, [pc, #20]	; (404984 <k_sys_fatal_error_handler+0x2c>)
  40496e:	2300      	movs	r3, #0
  404970:	aa05      	add	r2, sp, #20
  404972:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  404976:	f001 fdb0 	bl	4064da <z_impl_z_log_msg2_static_create>
	arch_system_halt(reason);
  40497a:	4620      	mov	r0, r4
  40497c:	f002 f910 	bl	406ba0 <arch_system_halt>
  404980:	00407ef9 	.word	0x00407ef9
  404984:	004072a0 	.word	0x004072a0

00404988 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  404988:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40498c:	4605      	mov	r5, r0
  40498e:	b08e      	sub	sp, #56	; 0x38
  404990:	460e      	mov	r6, r1
	__asm__ volatile(
  404992:	f04f 0320 	mov.w	r3, #32
  404996:	f3ef 8811 	mrs	r8, BASEPRI
  40499a:	f383 8812 	msr	BASEPRI_MAX, r3
  40499e:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
  4049a2:	f000 fe99 	bl	4056d8 <z_impl_z_current_get>
  4049a6:	2d04      	cmp	r5, #4
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  4049a8:	f04f 0700 	mov.w	r7, #0
  4049ac:	4604      	mov	r4, r0
	switch (reason) {
  4049ae:	bf98      	it	ls
  4049b0:	4b22      	ldrls	r3, [pc, #136]	; (404a3c <z_fatal_error+0xb4>)
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  4049b2:	f04f 0201 	mov.w	r2, #1
  4049b6:	bf88      	it	hi
  4049b8:	4b21      	ldrhi	r3, [pc, #132]	; (404a40 <z_fatal_error+0xb8>)
  4049ba:	4638      	mov	r0, r7
  4049bc:	bf98      	it	ls
  4049be:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
  4049c2:	4920      	ldr	r1, [pc, #128]	; (404a44 <z_fatal_error+0xbc>)
  4049c4:	9502      	str	r5, [sp, #8]
  4049c6:	e9cd 3703 	strd	r3, r7, [sp, #12]
  4049ca:	4b1f      	ldr	r3, [pc, #124]	; (404a48 <z_fatal_error+0xc0>)
  4049cc:	e9cd 7300 	strd	r7, r3, [sp]
  4049d0:	463b      	mov	r3, r7
  4049d2:	f002 f8d6 	bl	406b82 <z_log_msg2_runtime_create.constprop.0>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
  4049d6:	b17e      	cbz	r6, 4049f8 <z_fatal_error+0x70>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
  4049d8:	69f3      	ldr	r3, [r6, #28]
  4049da:	f3c3 0308 	ubfx	r3, r3, #0, #9
  4049de:	b15b      	cbz	r3, 4049f8 <z_fatal_error+0x70>
		LOG_ERR("Fault during interrupt handling\n");
  4049e0:	4b1a      	ldr	r3, [pc, #104]	; (404a4c <z_fatal_error+0xc4>)
  4049e2:	930c      	str	r3, [sp, #48]	; 0x30
  4049e4:	2302      	movs	r3, #2
  4049e6:	9307      	str	r3, [sp, #28]
  4049e8:	930b      	str	r3, [sp, #44]	; 0x2c
  4049ea:	f44f 5182 	mov.w	r1, #4160	; 0x1040
  4049ee:	463b      	mov	r3, r7
  4049f0:	aa0b      	add	r2, sp, #44	; 0x2c
  4049f2:	4814      	ldr	r0, [pc, #80]	; (404a44 <z_fatal_error+0xbc>)
  4049f4:	f001 fd71 	bl	4064da <z_impl_z_log_msg2_static_create>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  4049f8:	b12c      	cbz	r4, 404a06 <z_fatal_error+0x7e>
  4049fa:	4620      	mov	r0, r4
  4049fc:	f002 f8e2 	bl	406bc4 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  404a00:	b108      	cbz	r0, 404a06 <z_fatal_error+0x7e>
  404a02:	7803      	ldrb	r3, [r0, #0]
  404a04:	b903      	cbnz	r3, 404a08 <z_fatal_error+0x80>
		thread_name = "unknown";
  404a06:	4812      	ldr	r0, [pc, #72]	; (404a50 <z_fatal_error+0xc8>)
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  404a08:	4b12      	ldr	r3, [pc, #72]	; (404a54 <z_fatal_error+0xcc>)
  404a0a:	2201      	movs	r2, #1
  404a0c:	490d      	ldr	r1, [pc, #52]	; (404a44 <z_fatal_error+0xbc>)
  404a0e:	9301      	str	r3, [sp, #4]
  404a10:	2300      	movs	r3, #0
  404a12:	e9cd 4002 	strd	r4, r0, [sp, #8]
  404a16:	9300      	str	r3, [sp, #0]
  404a18:	4618      	mov	r0, r3
  404a1a:	f002 f8b2 	bl	406b82 <z_log_msg2_runtime_create.constprop.0>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
  404a1e:	4631      	mov	r1, r6
  404a20:	4628      	mov	r0, r5
  404a22:	f7ff ff99 	bl	404958 <k_sys_fatal_error_handler>
	__asm__ volatile(
  404a26:	f388 8811 	msr	BASEPRI, r8
  404a2a:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
  404a2e:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  404a30:	b00e      	add	sp, #56	; 0x38
  404a32:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  404a36:	f7fe bc6b 	b.w	403310 <z_impl_k_thread_abort>
  404a3a:	bf00      	nop
  404a3c:	00407558 	.word	0x00407558
  404a40:	00407f08 	.word	0x00407f08
  404a44:	004072a0 	.word	0x004072a0
  404a48:	00407f1e 	.word	0x00407f1e
  404a4c:	00407f46 	.word	0x00407f46
  404a50:	00407f16 	.word	0x00407f16
  404a54:	00407f67 	.word	0x00407f67

00404a58 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
  404a58:	b530      	push	{r4, r5, lr}
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
  404a5a:	2300      	movs	r3, #0
{
  404a5c:	b087      	sub	sp, #28
	z_setup_new_thread(thread, stack,
  404a5e:	2201      	movs	r2, #1
	struct k_thread *thread = &z_idle_threads[i];
  404a60:	4c0f      	ldr	r4, [pc, #60]	; (404aa0 <init_idle_thread+0x48>)
	z_setup_new_thread(thread, stack,
  404a62:	9301      	str	r3, [sp, #4]
  404a64:	f44f 75b0 	mov.w	r5, #352	; 0x160
	struct k_thread *thread = &z_idle_threads[i];
  404a68:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
  404a6c:	490d      	ldr	r1, [pc, #52]	; (404aa4 <init_idle_thread+0x4c>)
  404a6e:	e9cd 2304 	strd	r2, r3, [sp, #16]
  404a72:	220f      	movs	r2, #15
  404a74:	fb05 1100 	mla	r1, r5, r0, r1
  404a78:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  404a7c:	2218      	movs	r2, #24
  404a7e:	4b0a      	ldr	r3, [pc, #40]	; (404aa8 <init_idle_thread+0x50>)
  404a80:	fb02 3300 	mla	r3, r2, r0, r3
	z_setup_new_thread(thread, stack,
  404a84:	f44f 72a0 	mov.w	r2, #320	; 0x140
  404a88:	4620      	mov	r0, r4
  404a8a:	9300      	str	r3, [sp, #0]
  404a8c:	4b07      	ldr	r3, [pc, #28]	; (404aac <init_idle_thread+0x54>)
  404a8e:	f000 f8c5 	bl	404c1c <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  404a92:	7b63      	ldrb	r3, [r4, #13]
  404a94:	f023 0304 	bic.w	r3, r3, #4
  404a98:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
  404a9a:	b007      	add	sp, #28
  404a9c:	bd30      	pop	{r4, r5, pc}
  404a9e:	bf00      	nop
  404aa0:	20400508 	.word	0x20400508
  404aa4:	20401360 	.word	0x20401360
  404aa8:	20400bd4 	.word	0x20400bd4
  404aac:	00406bcd 	.word	0x00406bcd

00404ab0 <bg_thread_main>:
	z_sys_post_kernel = true;
  404ab0:	2201      	movs	r2, #1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
  404ab2:	2002      	movs	r0, #2
{
  404ab4:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
  404ab6:	4b09      	ldr	r3, [pc, #36]	; (404adc <bg_thread_main+0x2c>)
  404ab8:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
  404aba:	f7ff ff2d 	bl	404918 <z_sys_init_run_level>
	boot_banner();
  404abe:	f001 f861 	bl	405b84 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
  404ac2:	2003      	movs	r0, #3
  404ac4:	f7ff ff28 	bl	404918 <z_sys_init_run_level>
	z_init_static_threads();
  404ac8:	f000 f906 	bl	404cd8 <z_init_static_threads>
	main();
  404acc:	f7fc fb78 	bl	4011c0 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  404ad0:	4a03      	ldr	r2, [pc, #12]	; (404ae0 <bg_thread_main+0x30>)
  404ad2:	7b13      	ldrb	r3, [r2, #12]
  404ad4:	f023 0301 	bic.w	r3, r3, #1
  404ad8:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  404ada:	bd08      	pop	{r3, pc}
  404adc:	20400c15 	.word	0x20400c15
  404ae0:	20400588 	.word	0x20400588

00404ae4 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
  404ae4:	4802      	ldr	r0, [pc, #8]	; (404af0 <z_bss_zero+0xc>)
  404ae6:	2100      	movs	r1, #0
  404ae8:	4a02      	ldr	r2, [pc, #8]	; (404af4 <z_bss_zero+0x10>)
  404aea:	1a12      	subs	r2, r2, r0
  404aec:	f001 bd42 	b.w	406574 <memset>
  404af0:	20400050 	.word	0x20400050
  404af4:	20400c18 	.word	0x20400c18

00404af8 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
  404af8:	b580      	push	{r7, lr}
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
  404afa:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 404bb8 <z_cstart+0xc0>
  404afe:	b0a6      	sub	sp, #152	; 0x98
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
  404b00:	f388 8808 	msr	MSP, r8
  404b04:	2400      	movs	r4, #0
  404b06:	4d2d      	ldr	r5, [pc, #180]	; (404bbc <z_cstart+0xc4>)
  404b08:	23e0      	movs	r3, #224	; 0xe0
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
  404b0a:	4e2d      	ldr	r6, [pc, #180]	; (404bc0 <z_cstart+0xc8>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  404b0c:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 404bc4 <z_cstart+0xcc>
  404b10:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
  404b14:	77ec      	strb	r4, [r5, #31]
  404b16:	762c      	strb	r4, [r5, #24]
  404b18:	766c      	strb	r4, [r5, #25]
  404b1a:	76ac      	strb	r4, [r5, #26]
  404b1c:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
  404b20:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  404b22:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
  404b26:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
  404b28:	f7fe fbbe 	bl	4032a8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
  404b2c:	f7fd ff76 	bl	402a1c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
  404b30:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  404b34:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
  404b36:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
  404b38:	f7fe fcac 	bl	403494 <z_arm_mpu_init>
	_kernel.ready_q.cache = &z_main_thread;
  404b3c:	4d22      	ldr	r5, [pc, #136]	; (404bc8 <z_cstart+0xd0>)
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
  404b3e:	f7fe fbf9 	bl	403334 <z_arm_configure_static_mpu_regions>
	gcov_static_init();

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
  404b42:	f7fd fbd3 	bl	4022ec <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
  404b46:	f240 1301 	movw	r3, #257	; 0x101
	dummy_thread->resource_pool = NULL;
  404b4a:	9422      	str	r4, [sp, #136]	; 0x88
	dummy_thread->base.user_options = K_ESSENTIAL;
  404b4c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
  404b50:	ab06      	add	r3, sp, #24
	dummy_thread->stack_info.size = 0U;
  404b52:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	_current_cpu->current = dummy_thread;
  404b56:	60b3      	str	r3, [r6, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  404b58:	f002 f808 	bl	406b6c <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  404b5c:	4620      	mov	r0, r4
  404b5e:	f7ff fedb 	bl	404918 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  404b62:	2001      	movs	r0, #1
  404b64:	f7ff fed8 	bl	404918 <z_sys_init_run_level>
	z_sched_init();
  404b68:	f000 fd0a 	bl	405580 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  404b6c:	4b17      	ldr	r3, [pc, #92]	; (404bcc <z_cstart+0xd4>)
  404b6e:	4918      	ldr	r1, [pc, #96]	; (404bd0 <z_cstart+0xd8>)
  404b70:	f44f 6280 	mov.w	r2, #1024	; 0x400
  404b74:	9305      	str	r3, [sp, #20]
  404b76:	2301      	movs	r3, #1
  404b78:	4628      	mov	r0, r5
  404b7a:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
  404b7c:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  404b7e:	e9cd 4303 	strd	r4, r3, [sp, #12]
  404b82:	e9cd 4401 	strd	r4, r4, [sp, #4]
  404b86:	464b      	mov	r3, r9
  404b88:	f000 f848 	bl	404c1c <z_setup_new_thread>
  404b8c:	7b6a      	ldrb	r2, [r5, #13]
  404b8e:	4607      	mov	r7, r0
	z_ready_thread(&z_main_thread);
  404b90:	4628      	mov	r0, r5
  404b92:	f022 0204 	bic.w	r2, r2, #4
  404b96:	736a      	strb	r2, [r5, #13]
  404b98:	f002 f888 	bl	406cac <z_ready_thread>
		init_idle_thread(i);
  404b9c:	4620      	mov	r0, r4
  404b9e:	f7ff ff5b 	bl	404a58 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
  404ba2:	4b0c      	ldr	r3, [pc, #48]	; (404bd4 <z_cstart+0xdc>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  404ba4:	464a      	mov	r2, r9
  404ba6:	4639      	mov	r1, r7
  404ba8:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
  404baa:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
  404bac:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
  404bae:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  404bb2:	f7fe f87b 	bl	402cac <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  404bb6:	bf00      	nop
  404bb8:	20401ce0 	.word	0x20401ce0
  404bbc:	e000ed00 	.word	0xe000ed00
  404bc0:	20400bd4 	.word	0x20400bd4
  404bc4:	00404ab1 	.word	0x00404ab1
  404bc8:	20400588 	.word	0x20400588
  404bcc:	00407fc9 	.word	0x00407fc9
  404bd0:	20400f40 	.word	0x20400f40
  404bd4:	20400508 	.word	0x20400508

00404bd8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
  404bd8:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  404bda:	4b0e      	ldr	r3, [pc, #56]	; (404c14 <init_mem_slab_module+0x3c>)
  404bdc:	4c0e      	ldr	r4, [pc, #56]	; (404c18 <init_mem_slab_module+0x40>)
  404bde:	42a3      	cmp	r3, r4
  404be0:	d301      	bcc.n	404be6 <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
  404be2:	2000      	movs	r0, #0
	return rc;
}
  404be4:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  404be6:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
  404bea:	ea41 0200 	orr.w	r2, r1, r0
  404bee:	f012 0203 	ands.w	r2, r2, #3
  404bf2:	d10b      	bne.n	404c0c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
  404bf4:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
  404bf6:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
  404bf8:	42aa      	cmp	r2, r5
  404bfa:	d101      	bne.n	404c00 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  404bfc:	331c      	adds	r3, #28
  404bfe:	e7ee      	b.n	404bde <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
  404c00:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
  404c02:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
  404c04:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
  404c06:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
  404c08:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
  404c0a:	e7f5      	b.n	404bf8 <init_mem_slab_module+0x20>
	return rc;
  404c0c:	f06f 0015 	mvn.w	r0, #21
  404c10:	e7e8      	b.n	404be4 <init_mem_slab_module+0xc>
  404c12:	bf00      	nop
  404c14:	20400040 	.word	0x20400040
  404c18:	20400040 	.word	0x20400040

00404c1c <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
  404c1c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
  404c20:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  404c22:	f100 0558 	add.w	r5, r0, #88	; 0x58
{
  404c26:	460f      	mov	r7, r1
  404c28:	4604      	mov	r4, r0
	thread_base->user_options = (uint8_t)options;
  404c2a:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
  404c2c:	2604      	movs	r6, #4

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
  404c2e:	3720      	adds	r7, #32
  404c30:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
  404c32:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  404c34:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  404c36:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  404c38:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  404c3a:	f026 0607 	bic.w	r6, r6, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
  404c3e:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
  404c42:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  404c44:	f106 0820 	add.w	r8, r6, #32
	thread_base->pended_on = NULL;
  404c48:	6085      	str	r5, [r0, #8]
	stack_ptr = (char *)stack + stack_obj_size;
  404c4a:	4488      	add	r8, r1

	thread_base->sched_locked = 0U;
  404c4c:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
  404c4e:	66c5      	str	r5, [r0, #108]	; 0x6c
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
  404c50:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
  404c54:	e9c0 7619 	strd	r7, r6, [r0, #100]	; 0x64
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  404c58:	9202      	str	r2, [sp, #8]
  404c5a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  404c5c:	9201      	str	r2, [sp, #4]
  404c5e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  404c60:	9200      	str	r2, [sp, #0]
  404c62:	4642      	mov	r2, r8
  404c64:	f7fd fff6 	bl	402c54 <arch_new_thread>
	if (!_current) {
  404c68:	4b04      	ldr	r3, [pc, #16]	; (404c7c <z_setup_new_thread+0x60>)
	new_thread->init_data = NULL;
  404c6a:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
  404c6c:	689b      	ldr	r3, [r3, #8]
  404c6e:	b103      	cbz	r3, 404c72 <z_setup_new_thread+0x56>
	new_thread->resource_pool = _current->resource_pool;
  404c70:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
  404c72:	4640      	mov	r0, r8
  404c74:	6723      	str	r3, [r4, #112]	; 0x70
  404c76:	b004      	add	sp, #16
  404c78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404c7c:	20400bd4 	.word	0x20400bd4

00404c80 <z_impl_k_thread_create>:
{
  404c80:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  404c82:	2700      	movs	r7, #0
{
  404c84:	b087      	sub	sp, #28
  404c86:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  404c88:	9705      	str	r7, [sp, #20]
  404c8a:	9f10      	ldr	r7, [sp, #64]	; 0x40
  404c8c:	9704      	str	r7, [sp, #16]
  404c8e:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
  404c90:	9703      	str	r7, [sp, #12]
  404c92:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  404c94:	9702      	str	r7, [sp, #8]
  404c96:	9f0d      	ldr	r7, [sp, #52]	; 0x34
  404c98:	9701      	str	r7, [sp, #4]
  404c9a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
{
  404c9c:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  404ca0:	9700      	str	r7, [sp, #0]
  404ca2:	f7ff ffbb 	bl	404c1c <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  404ca6:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
  404caa:	bf08      	it	eq
  404cac:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
  404cb0:	d005      	beq.n	404cbe <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  404cb2:	ea55 0306 	orrs.w	r3, r5, r6
  404cb6:	d105      	bne.n	404cc4 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
  404cb8:	4620      	mov	r0, r4
  404cba:	f000 fb5b 	bl	405374 <z_sched_start>
}
  404cbe:	4620      	mov	r0, r4
  404cc0:	b007      	add	sp, #28
  404cc2:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  404cc4:	4632      	mov	r2, r6
  404cc6:	462b      	mov	r3, r5
  404cc8:	4902      	ldr	r1, [pc, #8]	; (404cd4 <z_impl_k_thread_create+0x54>)
  404cca:	f104 0018 	add.w	r0, r4, #24
  404cce:	f000 fdd3 	bl	405878 <z_add_timeout>
  404cd2:	e7f4      	b.n	404cbe <z_impl_k_thread_create+0x3e>
  404cd4:	00406ccd 	.word	0x00406ccd

00404cd8 <z_init_static_threads>:
{
  404cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
  404cda:	4c21      	ldr	r4, [pc, #132]	; (404d60 <z_init_static_threads+0x88>)
  404cdc:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
  404cde:	4d21      	ldr	r5, [pc, #132]	; (404d64 <z_init_static_threads+0x8c>)
  404ce0:	4626      	mov	r6, r4
  404ce2:	3430      	adds	r4, #48	; 0x30
  404ce4:	42ae      	cmp	r6, r5
  404ce6:	d30b      	bcc.n	404d00 <z_init_static_threads+0x28>
	_FOREACH_STATIC_THREAD(thread_data) {
  404ce8:	4c1d      	ldr	r4, [pc, #116]	; (404d60 <z_init_static_threads+0x88>)
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
  404cea:	260a      	movs	r6, #10
  404cec:	4f1e      	ldr	r7, [pc, #120]	; (404d68 <z_init_static_threads+0x90>)
	k_sched_lock();
  404cee:	f000 fa5d 	bl	4051ac <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
  404cf2:	42ac      	cmp	r4, r5
  404cf4:	d320      	bcc.n	404d38 <z_init_static_threads+0x60>
}
  404cf6:	b007      	add	sp, #28
  404cf8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
  404cfc:	f000 bc24 	b.w	405548 <k_sched_unlock>
		z_setup_new_thread(
  404d00:	f854 3c04 	ldr.w	r3, [r4, #-4]
  404d04:	9305      	str	r3, [sp, #20]
  404d06:	f854 3c10 	ldr.w	r3, [r4, #-16]
  404d0a:	9304      	str	r3, [sp, #16]
  404d0c:	f854 3c14 	ldr.w	r3, [r4, #-20]
  404d10:	9303      	str	r3, [sp, #12]
  404d12:	f854 3c18 	ldr.w	r3, [r4, #-24]
  404d16:	9302      	str	r3, [sp, #8]
  404d18:	f854 3c1c 	ldr.w	r3, [r4, #-28]
  404d1c:	9301      	str	r3, [sp, #4]
  404d1e:	f854 3c20 	ldr.w	r3, [r4, #-32]
  404d22:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
  404d26:	9300      	str	r3, [sp, #0]
  404d28:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
  404d2c:	f7ff ff76 	bl	404c1c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  404d30:	f854 3c30 	ldr.w	r3, [r4, #-48]
  404d34:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
  404d36:	e7d3      	b.n	404ce0 <z_init_static_threads+0x8>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  404d38:	6a62      	ldr	r2, [r4, #36]	; 0x24
  404d3a:	1c53      	adds	r3, r2, #1
  404d3c:	d009      	beq.n	404d52 <z_init_static_threads+0x7a>
					    K_MSEC(thread_data->init_delay));
  404d3e:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
			schedule_new_thread(thread_data->init_thread,
  404d42:	6820      	ldr	r0, [r4, #0]
  404d44:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  404d48:	ea52 0103 	orrs.w	r1, r2, r3
  404d4c:	d103      	bne.n	404d56 <z_init_static_threads+0x7e>
	z_sched_start(thread);
  404d4e:	f000 fb11 	bl	405374 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
  404d52:	3430      	adds	r4, #48	; 0x30
  404d54:	e7cd      	b.n	404cf2 <z_init_static_threads+0x1a>
  404d56:	4639      	mov	r1, r7
  404d58:	3018      	adds	r0, #24
  404d5a:	f000 fd8d 	bl	405878 <z_add_timeout>
  404d5e:	e7f8      	b.n	404d52 <z_init_static_threads+0x7a>
  404d60:	20400040 	.word	0x20400040
  404d64:	20400040 	.word	0x20400040
  404d68:	00406ccd 	.word	0x00406ccd

00404d6c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  404d6c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  404d70:	4604      	mov	r4, r0
  404d72:	4617      	mov	r7, r2
  404d74:	461e      	mov	r6, r3
	__asm__ volatile(
  404d76:	f04f 0320 	mov.w	r3, #32
  404d7a:	f3ef 8811 	mrs	r8, BASEPRI
  404d7e:	f383 8812 	msr	BASEPRI_MAX, r3
  404d82:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  404d86:	68c3      	ldr	r3, [r0, #12]
  404d88:	4a32      	ldr	r2, [pc, #200]	; (404e54 <z_impl_k_mutex_lock+0xe8>)
  404d8a:	b16b      	cbz	r3, 404da8 <z_impl_k_mutex_lock+0x3c>
  404d8c:	6880      	ldr	r0, [r0, #8]
  404d8e:	6891      	ldr	r1, [r2, #8]
  404d90:	4288      	cmp	r0, r1
  404d92:	d019      	beq.n	404dc8 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  404d94:	ea57 0306 	orrs.w	r3, r7, r6
  404d98:	d118      	bne.n	404dcc <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
  404d9a:	f388 8811 	msr	BASEPRI, r8
  404d9e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  404da2:	f06f 000f 	mvn.w	r0, #15
  404da6:	e00c      	b.n	404dc2 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
  404da8:	6891      	ldr	r1, [r2, #8]
  404daa:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
  404dae:	3301      	adds	r3, #1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  404db0:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
  404db2:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
  404db4:	6893      	ldr	r3, [r2, #8]
  404db6:	60a3      	str	r3, [r4, #8]
  404db8:	f388 8811 	msr	BASEPRI, r8
  404dbc:	f3bf 8f6f 	isb	sy
		return 0;
  404dc0:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
  404dc2:	b002      	add	sp, #8
  404dc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
  404dc8:	6921      	ldr	r1, [r4, #16]
  404dca:	e7f0      	b.n	404dae <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
  404dcc:	f991 100e 	ldrsb.w	r1, [r1, #14]
  404dd0:	f06f 027e 	mvn.w	r2, #126	; 0x7e
  404dd4:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
  404dd8:	4299      	cmp	r1, r3
  404dda:	bfa8      	it	ge
  404ddc:	4619      	movge	r1, r3
  404dde:	4291      	cmp	r1, r2
  404de0:	bfb8      	it	lt
  404de2:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  404de4:	428b      	cmp	r3, r1
  404de6:	dd2e      	ble.n	404e46 <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
  404de8:	f001 fefc 	bl	406be4 <adjust_owner_prio.isra.0>
  404dec:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  404dee:	4622      	mov	r2, r4
  404df0:	4641      	mov	r1, r8
  404df2:	4819      	ldr	r0, [pc, #100]	; (404e58 <z_impl_k_mutex_lock+0xec>)
  404df4:	e9cd 7600 	strd	r7, r6, [sp]
  404df8:	f000 fb18 	bl	40542c <z_pend_curr>
	if (got_mutex == 0) {
  404dfc:	2800      	cmp	r0, #0
  404dfe:	d0e0      	beq.n	404dc2 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
  404e00:	f04f 0320 	mov.w	r3, #32
  404e04:	f3ef 8611 	mrs	r6, BASEPRI
  404e08:	f383 8812 	msr	BASEPRI_MAX, r3
  404e0c:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  404e10:	6823      	ldr	r3, [r4, #0]
  404e12:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  404e14:	429c      	cmp	r4, r3
  404e16:	d00a      	beq.n	404e2e <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  404e18:	b14b      	cbz	r3, 404e2e <z_impl_k_mutex_lock+0xc2>
  404e1a:	f993 300e 	ldrsb.w	r3, [r3, #14]
  404e1e:	4299      	cmp	r1, r3
  404e20:	bfa8      	it	ge
  404e22:	4619      	movge	r1, r3
  404e24:	f06f 037e 	mvn.w	r3, #126	; 0x7e
  404e28:	4299      	cmp	r1, r3
  404e2a:	bfb8      	it	lt
  404e2c:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
  404e2e:	68a0      	ldr	r0, [r4, #8]
  404e30:	f001 fed8 	bl	406be4 <adjust_owner_prio.isra.0>
  404e34:	b900      	cbnz	r0, 404e38 <z_impl_k_mutex_lock+0xcc>
	if (resched) {
  404e36:	b145      	cbz	r5, 404e4a <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
  404e38:	4631      	mov	r1, r6
  404e3a:	4807      	ldr	r0, [pc, #28]	; (404e58 <z_impl_k_mutex_lock+0xec>)
  404e3c:	f000 f9a4 	bl	405188 <z_reschedule>
	return -EAGAIN;
  404e40:	f06f 000a 	mvn.w	r0, #10
  404e44:	e7bd      	b.n	404dc2 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
  404e46:	2500      	movs	r5, #0
  404e48:	e7d1      	b.n	404dee <z_impl_k_mutex_lock+0x82>
	__asm__ volatile(
  404e4a:	f386 8811 	msr	BASEPRI, r6
  404e4e:	f3bf 8f6f 	isb	sy
  404e52:	e7f5      	b.n	404e40 <z_impl_k_mutex_lock+0xd4>
  404e54:	20400bd4 	.word	0x20400bd4
  404e58:	20400c16 	.word	0x20400c16

00404e5c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  404e5c:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
  404e5e:	6883      	ldr	r3, [r0, #8]
{
  404e60:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
  404e62:	2b00      	cmp	r3, #0
  404e64:	d032      	beq.n	404ecc <z_impl_k_mutex_unlock+0x70>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
  404e66:	4a1c      	ldr	r2, [pc, #112]	; (404ed8 <z_impl_k_mutex_unlock+0x7c>)
  404e68:	6892      	ldr	r2, [r2, #8]
  404e6a:	4293      	cmp	r3, r2
  404e6c:	d131      	bne.n	404ed2 <z_impl_k_mutex_unlock+0x76>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
  404e6e:	7bda      	ldrb	r2, [r3, #15]
  404e70:	3a01      	subs	r2, #1
  404e72:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  404e74:	68c3      	ldr	r3, [r0, #12]
  404e76:	2b01      	cmp	r3, #1
  404e78:	d905      	bls.n	404e86 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
  404e7a:	3b01      	subs	r3, #1
  404e7c:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
  404e7e:	f000 fb63 	bl	405548 <k_sched_unlock>

	return 0;
  404e82:	2000      	movs	r0, #0
}
  404e84:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
  404e86:	f04f 0320 	mov.w	r3, #32
  404e8a:	f3ef 8511 	mrs	r5, BASEPRI
  404e8e:	f383 8812 	msr	BASEPRI_MAX, r3
  404e92:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  404e96:	6901      	ldr	r1, [r0, #16]
  404e98:	6880      	ldr	r0, [r0, #8]
  404e9a:	f001 fea3 	bl	406be4 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  404e9e:	4620      	mov	r0, r4
  404ea0:	f001 ff75 	bl	406d8e <z_unpend_first_thread>
	mutex->owner = new_owner;
  404ea4:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
  404ea6:	b158      	cbz	r0, 404ec0 <z_impl_k_mutex_unlock+0x64>
		mutex->owner_orig_prio = new_owner->base.prio;
  404ea8:	f990 200e 	ldrsb.w	r2, [r0, #14]
  404eac:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
  404eae:	2200      	movs	r2, #0
  404eb0:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
  404eb2:	f001 fefb 	bl	406cac <z_ready_thread>
		z_reschedule(&lock, key);
  404eb6:	4629      	mov	r1, r5
  404eb8:	4808      	ldr	r0, [pc, #32]	; (404edc <z_impl_k_mutex_unlock+0x80>)
  404eba:	f000 f965 	bl	405188 <z_reschedule>
  404ebe:	e7de      	b.n	404e7e <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
  404ec0:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
  404ec2:	f385 8811 	msr	BASEPRI, r5
  404ec6:	f3bf 8f6f 	isb	sy
  404eca:	e7d8      	b.n	404e7e <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
  404ecc:	f06f 0015 	mvn.w	r0, #21
  404ed0:	e7d8      	b.n	404e84 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
  404ed2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  404ed6:	e7d5      	b.n	404e84 <z_impl_k_mutex_unlock+0x28>
  404ed8:	20400bd4 	.word	0x20400bd4
  404edc:	20400c16 	.word	0x20400c16

00404ee0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  404ee0:	b538      	push	{r3, r4, r5, lr}
  404ee2:	4604      	mov	r4, r0
	__asm__ volatile(
  404ee4:	f04f 0320 	mov.w	r3, #32
  404ee8:	f3ef 8511 	mrs	r5, BASEPRI
  404eec:	f383 8812 	msr	BASEPRI_MAX, r3
  404ef0:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  404ef4:	f001 ff4b 	bl	406d8e <z_unpend_first_thread>

	if (thread != NULL) {
  404ef8:	b148      	cbz	r0, 404f0e <z_impl_k_sem_give+0x2e>
  404efa:	2200      	movs	r2, #0
  404efc:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  404efe:	f001 fed5 	bl	406cac <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
  404f02:	4629      	mov	r1, r5
  404f04:	4805      	ldr	r0, [pc, #20]	; (404f1c <z_impl_k_sem_give+0x3c>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  404f06:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
  404f0a:	f000 b93d 	b.w	405188 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  404f0e:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
  404f12:	429a      	cmp	r2, r3
  404f14:	bf18      	it	ne
  404f16:	3301      	addne	r3, #1
  404f18:	60a3      	str	r3, [r4, #8]
}
  404f1a:	e7f2      	b.n	404f02 <z_impl_k_sem_give+0x22>
  404f1c:	20400c16 	.word	0x20400c16

00404f20 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  404f20:	b513      	push	{r0, r1, r4, lr}
  404f22:	f04f 0420 	mov.w	r4, #32
  404f26:	f3ef 8111 	mrs	r1, BASEPRI
  404f2a:	f384 8812 	msr	BASEPRI_MAX, r4
  404f2e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  404f32:	6884      	ldr	r4, [r0, #8]
  404f34:	b144      	cbz	r4, 404f48 <z_impl_k_sem_take+0x28>
		sem->count--;
  404f36:	3c01      	subs	r4, #1
  404f38:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
  404f3a:	f381 8811 	msr	BASEPRI, r1
  404f3e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
  404f42:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  404f44:	b002      	add	sp, #8
  404f46:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  404f48:	ea52 0403 	orrs.w	r4, r2, r3
  404f4c:	d106      	bne.n	404f5c <z_impl_k_sem_take+0x3c>
  404f4e:	f381 8811 	msr	BASEPRI, r1
  404f52:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
  404f56:	f06f 000f 	mvn.w	r0, #15
  404f5a:	e7f3      	b.n	404f44 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  404f5c:	e9cd 2300 	strd	r2, r3, [sp]
  404f60:	4602      	mov	r2, r0
  404f62:	4802      	ldr	r0, [pc, #8]	; (404f6c <z_impl_k_sem_take+0x4c>)
  404f64:	f000 fa62 	bl	40542c <z_pend_curr>
	return ret;
  404f68:	e7ec      	b.n	404f44 <z_impl_k_sem_take+0x24>
  404f6a:	bf00      	nop
  404f6c:	20400c16 	.word	0x20400c16

00404f70 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
  404f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404f74:	4604      	mov	r4, r0
  404f76:	b085      	sub	sp, #20
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  404f78:	4e46      	ldr	r6, [pc, #280]	; (405094 <work_queue_main+0x124>)
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
  404f7a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  404f7e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	__asm__ volatile(
  404f82:	f04f 0320 	mov.w	r3, #32
  404f86:	f3ef 8711 	mrs	r7, BASEPRI
  404f8a:	f383 8812 	msr	BASEPRI_MAX, r3
  404f8e:	f3bf 8f6f 	isb	sy
  404f92:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
  404f96:	b98d      	cbnz	r5, 404fbc <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
  404f98:	2102      	movs	r1, #2
  404f9a:	f104 0098 	add.w	r0, r4, #152	; 0x98
  404f9e:	f001 fe3c 	bl	406c1a <flag_test_and_clear>
  404fa2:	2800      	cmp	r0, #0
  404fa4:	d135      	bne.n	405012 <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
  404fa6:	2300      	movs	r3, #0
  404fa8:	f104 0288 	add.w	r2, r4, #136	; 0x88
  404fac:	4639      	mov	r1, r7
  404fae:	483a      	ldr	r0, [pc, #232]	; (405098 <work_queue_main+0x128>)
  404fb0:	9302      	str	r3, [sp, #8]
  404fb2:	e9cd 8900 	strd	r8, r9, [sp]
  404fb6:	f000 fbe7 	bl	405788 <z_sched_wait>
			continue;
  404fba:	e7e2      	b.n	404f82 <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  404fbc:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
  404fc0:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  404fc2:	4295      	cmp	r5, r2
	list->head = node;
  404fc4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  404fc8:	d101      	bne.n	404fce <work_queue_main+0x5e>
	list->tail = node;
  404fca:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
  404fce:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
  404fd2:	f043 0302 	orr.w	r3, r3, #2
  404fd6:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
  404fda:	68eb      	ldr	r3, [r5, #12]
  404fdc:	f023 0304 	bic.w	r3, r3, #4
  404fe0:	f043 0301 	orr.w	r3, r3, #1
  404fe4:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
  404fe6:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
  404fe8:	f387 8811 	msr	BASEPRI, r7
  404fec:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
  404ff0:	4628      	mov	r0, r5
  404ff2:	4798      	blx	r3
	__asm__ volatile(
  404ff4:	f04f 0320 	mov.w	r3, #32
  404ff8:	f3ef 8b11 	mrs	fp, BASEPRI
  404ffc:	f383 8812 	msr	BASEPRI_MAX, r3
  405000:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
  405004:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  405006:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
  405008:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40500c:	d40b      	bmi.n	405026 <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
  40500e:	60ea      	str	r2, [r5, #12]
  405010:	e00e      	b.n	405030 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  405012:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  405016:	2200      	movs	r2, #0
  405018:	2101      	movs	r1, #1
  40501a:	4628      	mov	r0, r5
  40501c:	f001 fecf 	bl	406dbe <z_sched_wake>
  405020:	2800      	cmp	r0, #0
  405022:	d1f8      	bne.n	405016 <work_queue_main+0xa6>
  405024:	e7bf      	b.n	404fa6 <work_queue_main+0x36>
	*flagp &= ~BIT(bit);
  405026:	f023 0303 	bic.w	r3, r3, #3
	return list->head;
  40502a:	6830      	ldr	r0, [r6, #0]
  40502c:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40502e:	b970      	cbnz	r0, 40504e <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
  405030:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
  405034:	f023 0302 	bic.w	r3, r3, #2
  405038:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
  40503c:	f38b 8811 	msr	BASEPRI, fp
  405040:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
  405044:	05d8      	lsls	r0, r3, #23
  405046:	d49c      	bmi.n	404f82 <work_queue_main+0x12>
	z_impl_k_yield();
  405048:	f000 faa6 	bl	405598 <z_impl_k_yield>
}
  40504c:	e799      	b.n	404f82 <work_queue_main+0x12>
	return node->next;
  40504e:	2700      	movs	r7, #0
  405050:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
  405054:	463b      	mov	r3, r7
		if (wc->work == work) {
  405056:	6842      	ldr	r2, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  405058:	4601      	mov	r1, r0
		if (wc->work == work) {
  40505a:	4295      	cmp	r5, r2
  40505c:	d10c      	bne.n	405078 <work_queue_main+0x108>
	return node->next;
  40505e:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
  405060:	b997      	cbnz	r7, 405088 <work_queue_main+0x118>
  405062:	6872      	ldr	r2, [r6, #4]
	list->head = node;
  405064:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
  405066:	4282      	cmp	r2, r0
  405068:	d100      	bne.n	40506c <work_queue_main+0xfc>
	list->tail = node;
  40506a:	6071      	str	r1, [r6, #4]
	parent->next = child;
  40506c:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
  405070:	f7ff ff36 	bl	404ee0 <z_impl_k_sem_give>
}
  405074:	4639      	mov	r1, r7
  405076:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  405078:	f1ba 0f00 	cmp.w	sl, #0
  40507c:	d0d8      	beq.n	405030 <work_queue_main+0xc0>
	return node->next;
  40507e:	4650      	mov	r0, sl
  405080:	460f      	mov	r7, r1
  405082:	f8da a000 	ldr.w	sl, [sl]
  405086:	e7e6      	b.n	405056 <work_queue_main+0xe6>
	return list->tail;
  405088:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
  40508a:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
  40508c:	4290      	cmp	r0, r2
	list->tail = node;
  40508e:	bf08      	it	eq
  405090:	6077      	streq	r7, [r6, #4]
}
  405092:	e7eb      	b.n	40506c <work_queue_main+0xfc>
  405094:	20400bf8 	.word	0x20400bf8
  405098:	20400c16 	.word	0x20400c16

0040509c <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
  40509c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40509e:	4604      	mov	r4, r0
	list->head = NULL;
  4050a0:	2000      	movs	r0, #0
  4050a2:	b089      	sub	sp, #36	; 0x24
	list->tail = NULL;
  4050a4:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
  4050a8:	f104 0088 	add.w	r0, r4, #136	; 0x88
  4050ac:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	list->tail = (sys_dnode_t *)list;
  4050ae:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
  4050b2:	f104 0090 	add.w	r0, r4, #144	; 0x90
  4050b6:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
  4050ba:	b31d      	cbz	r5, 405104 <k_work_queue_start+0x68>
  4050bc:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
  4050be:	2800      	cmp	r0, #0
  4050c0:	f240 1001 	movw	r0, #257	; 0x101
  4050c4:	bf08      	it	eq
  4050c6:	2001      	moveq	r0, #1
	*flagp = flags;
  4050c8:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  4050cc:	2000      	movs	r0, #0
  4050ce:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  4050d2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
  4050d6:	9400      	str	r4, [sp, #0]
  4050d8:	e9cd 3003 	strd	r3, r0, [sp, #12]
  4050dc:	e9cd 0001 	strd	r0, r0, [sp, #4]
  4050e0:	4b09      	ldr	r3, [pc, #36]	; (405108 <k_work_queue_start+0x6c>)
  4050e2:	4620      	mov	r0, r4
  4050e4:	e9cd 6706 	strd	r6, r7, [sp, #24]
  4050e8:	f7ff fdca 	bl	404c80 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
  4050ec:	b125      	cbz	r5, 4050f8 <k_work_queue_start+0x5c>
  4050ee:	6829      	ldr	r1, [r5, #0]
  4050f0:	b111      	cbz	r1, 4050f8 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
  4050f2:	4620      	mov	r0, r4
  4050f4:	f001 fd63 	bl	406bbe <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  4050f8:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
  4050fa:	b009      	add	sp, #36	; 0x24
  4050fc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  405100:	f001 bd62 	b.w	406bc8 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
  405104:	2001      	movs	r0, #1
  405106:	e7df      	b.n	4050c8 <k_work_queue_start+0x2c>
  405108:	00404f71 	.word	0x00404f71

0040510c <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
  40510c:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
  40510e:	4c08      	ldr	r4, [pc, #32]	; (405130 <z_reset_time_slice+0x24>)
  405110:	6823      	ldr	r3, [r4, #0]
  405112:	b15b      	cbz	r3, 40512c <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
  405114:	f7ff fbcc 	bl	4048b0 <sys_clock_elapsed>
  405118:	4603      	mov	r3, r0
  40511a:	6820      	ldr	r0, [r4, #0]
		z_set_timeout_expiry(slice_time, false);
  40511c:	2100      	movs	r1, #0
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
  40511e:	4a05      	ldr	r2, [pc, #20]	; (405134 <z_reset_time_slice+0x28>)
  405120:	4403      	add	r3, r0
	}
}
  405122:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
  405126:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
  405128:	f001 be7c 	b.w	406e24 <z_set_timeout_expiry>
}
  40512c:	bd10      	pop	{r4, pc}
  40512e:	bf00      	nop
  405130:	20400c08 	.word	0x20400c08
  405134:	20400bd4 	.word	0x20400bd4

00405138 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
  405138:	b510      	push	{r4, lr}
	__asm__ volatile(
  40513a:	f04f 0320 	mov.w	r3, #32
  40513e:	f3ef 8411 	mrs	r4, BASEPRI
  405142:	f383 8812 	msr	BASEPRI_MAX, r3
  405146:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
  40514a:	2200      	movs	r2, #0
  40514c:	4b0b      	ldr	r3, [pc, #44]	; (40517c <k_sched_time_slice_set+0x44>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
  40514e:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
  405150:	611a      	str	r2, [r3, #16]
			return ((uint32_t)t) * (to_hz / from_hz);
  405152:	f04f 030a 	mov.w	r3, #10
  405156:	4a0a      	ldr	r2, [pc, #40]	; (405180 <k_sched_time_slice_set+0x48>)
  405158:	fb00 f303 	mul.w	r3, r0, r3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
  40515c:	dc09      	bgt.n	405172 <k_sched_time_slice_set+0x3a>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
  40515e:	6013      	str	r3, [r2, #0]
		}
		slice_max_prio = prio;
  405160:	4b08      	ldr	r3, [pc, #32]	; (405184 <k_sched_time_slice_set+0x4c>)
  405162:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
  405164:	f7ff ffd2 	bl	40510c <z_reset_time_slice>
	__asm__ volatile(
  405168:	f384 8811 	msr	BASEPRI, r4
  40516c:	f3bf 8f6f 	isb	sy
	}
}
  405170:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
  405172:	2b02      	cmp	r3, #2
  405174:	bfb8      	it	lt
  405176:	2302      	movlt	r3, #2
  405178:	e7f1      	b.n	40515e <k_sched_time_slice_set+0x26>
  40517a:	bf00      	nop
  40517c:	20400bd4 	.word	0x20400bd4
  405180:	20400c08 	.word	0x20400c08
  405184:	20400c04 	.word	0x20400c04

00405188 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
  405188:	b949      	cbnz	r1, 40519e <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  40518a:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
  40518e:	b930      	cbnz	r0, 40519e <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
  405190:	4b05      	ldr	r3, [pc, #20]	; (4051a8 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
  405192:	699a      	ldr	r2, [r3, #24]
  405194:	689b      	ldr	r3, [r3, #8]
  405196:	429a      	cmp	r2, r3
  405198:	d001      	beq.n	40519e <z_reschedule+0x16>
	ret = arch_swap(key);
  40519a:	f7fd bd07 	b.w	402bac <arch_swap>
  40519e:	f381 8811 	msr	BASEPRI, r1
  4051a2:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
  4051a6:	4770      	bx	lr
  4051a8:	20400bd4 	.word	0x20400bd4

004051ac <k_sched_lock>:
	__asm__ volatile(
  4051ac:	f04f 0320 	mov.w	r3, #32
  4051b0:	f3ef 8111 	mrs	r1, BASEPRI
  4051b4:	f383 8812 	msr	BASEPRI_MAX, r3
  4051b8:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
  4051bc:	4b04      	ldr	r3, [pc, #16]	; (4051d0 <k_sched_lock+0x24>)
  4051be:	689a      	ldr	r2, [r3, #8]
  4051c0:	7bd3      	ldrb	r3, [r2, #15]
  4051c2:	3b01      	subs	r3, #1
  4051c4:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
  4051c6:	f381 8811 	msr	BASEPRI, r1
  4051ca:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
  4051ce:	4770      	bx	lr
  4051d0:	20400bd4 	.word	0x20400bd4

004051d4 <update_cache>:
{
  4051d4:	b538      	push	{r3, r4, r5, lr}
  4051d6:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
  4051d8:	480c      	ldr	r0, [pc, #48]	; (40520c <update_cache+0x38>)
  4051da:	f001 fd61 	bl	406ca0 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  4051de:	4d0c      	ldr	r5, [pc, #48]	; (405210 <update_cache+0x3c>)
  4051e0:	4604      	mov	r4, r0
  4051e2:	b900      	cbnz	r0, 4051e6 <update_cache+0x12>
  4051e4:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
  4051e6:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
  4051e8:	b94a      	cbnz	r2, 4051fe <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
  4051ea:	7b5a      	ldrb	r2, [r3, #13]
  4051ec:	06d2      	lsls	r2, r2, #27
  4051ee:	d106      	bne.n	4051fe <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
  4051f0:	69a2      	ldr	r2, [r4, #24]
  4051f2:	b922      	cbnz	r2, 4051fe <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
  4051f4:	89da      	ldrh	r2, [r3, #14]
  4051f6:	2a7f      	cmp	r2, #127	; 0x7f
  4051f8:	d901      	bls.n	4051fe <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
  4051fa:	61ab      	str	r3, [r5, #24]
}
  4051fc:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
  4051fe:	429c      	cmp	r4, r3
  405200:	d001      	beq.n	405206 <update_cache+0x32>
			z_reset_time_slice();
  405202:	f7ff ff83 	bl	40510c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  405206:	61ac      	str	r4, [r5, #24]
}
  405208:	e7f8      	b.n	4051fc <update_cache+0x28>
  40520a:	bf00      	nop
  40520c:	20400bf0 	.word	0x20400bf0
  405210:	20400bd4 	.word	0x20400bd4

00405214 <move_thread_to_end_of_prio_q>:
{
  405214:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
  405216:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
  40521a:	4601      	mov	r1, r0
	return (thread->base.thread_state & state) != 0U;
  40521c:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
  40521e:	2a00      	cmp	r2, #0
  405220:	da04      	bge.n	40522c <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  405222:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  405226:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
  405228:	f001 fd02 	bl	406c30 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  40522c:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
  40522e:	4a15      	ldr	r2, [pc, #84]	; (405284 <move_thread_to_end_of_prio_q+0x70>)
  405230:	f063 037f 	orn	r3, r3, #127	; 0x7f
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405234:	f102 051c 	add.w	r5, r2, #28
  405238:	734b      	strb	r3, [r1, #13]
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  40523a:	e9d2 3407 	ldrd	r3, r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40523e:	42ab      	cmp	r3, r5
  405240:	d01b      	beq.n	40527a <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  405242:	b1d3      	cbz	r3, 40527a <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
  405244:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
  405248:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
  40524c:	4286      	cmp	r6, r0
  40524e:	d00f      	beq.n	405270 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
  405250:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
  405252:	2800      	cmp	r0, #0
  405254:	dd0c      	ble.n	405270 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
  405256:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
  405258:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
  40525c:	6001      	str	r1, [r0, #0]
	successor->prev = node;
  40525e:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
  405260:	6890      	ldr	r0, [r2, #8]
  405262:	1a43      	subs	r3, r0, r1
  405264:	4258      	negs	r0, r3
}
  405266:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
  40526a:	4158      	adcs	r0, r3
  40526c:	f7ff bfb2 	b.w	4051d4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  405270:	42a3      	cmp	r3, r4
  405272:	d002      	beq.n	40527a <move_thread_to_end_of_prio_q+0x66>
  405274:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  405276:	2b00      	cmp	r3, #0
  405278:	d1e6      	bne.n	405248 <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
  40527a:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
  40527e:	6021      	str	r1, [r4, #0]
	list->tail = node;
  405280:	6211      	str	r1, [r2, #32]
}
  405282:	e7ed      	b.n	405260 <move_thread_to_end_of_prio_q+0x4c>
  405284:	20400bd4 	.word	0x20400bd4

00405288 <z_time_slice>:
{
  405288:	4601      	mov	r1, r0
  40528a:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
  40528c:	f04f 0320 	mov.w	r3, #32
  405290:	f3ef 8411 	mrs	r4, BASEPRI
  405294:	f383 8812 	msr	BASEPRI_MAX, r3
  405298:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
  40529c:	4b15      	ldr	r3, [pc, #84]	; (4052f4 <z_time_slice+0x6c>)
  40529e:	4a16      	ldr	r2, [pc, #88]	; (4052f8 <z_time_slice+0x70>)
  4052a0:	6898      	ldr	r0, [r3, #8]
  4052a2:	6815      	ldr	r5, [r2, #0]
  4052a4:	42a8      	cmp	r0, r5
  4052a6:	d106      	bne.n	4052b6 <z_time_slice+0x2e>
			z_reset_time_slice();
  4052a8:	f7ff ff30 	bl	40510c <z_reset_time_slice>
	__asm__ volatile(
  4052ac:	f384 8811 	msr	BASEPRI, r4
  4052b0:	f3bf 8f6f 	isb	sy
}
  4052b4:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
  4052b6:	2500      	movs	r5, #0
  4052b8:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
  4052ba:	4a10      	ldr	r2, [pc, #64]	; (4052fc <z_time_slice+0x74>)
  4052bc:	6812      	ldr	r2, [r2, #0]
  4052be:	b1ba      	cbz	r2, 4052f0 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
  4052c0:	89c2      	ldrh	r2, [r0, #14]
  4052c2:	2a7f      	cmp	r2, #127	; 0x7f
  4052c4:	d814      	bhi.n	4052f0 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
  4052c6:	7b42      	ldrb	r2, [r0, #13]
  4052c8:	06d2      	lsls	r2, r2, #27
  4052ca:	d111      	bne.n	4052f0 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  4052cc:	4a0c      	ldr	r2, [pc, #48]	; (405300 <z_time_slice+0x78>)
  4052ce:	f990 500e 	ldrsb.w	r5, [r0, #14]
  4052d2:	6812      	ldr	r2, [r2, #0]
  4052d4:	4295      	cmp	r5, r2
  4052d6:	db0b      	blt.n	4052f0 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
  4052d8:	4a0a      	ldr	r2, [pc, #40]	; (405304 <z_time_slice+0x7c>)
  4052da:	4290      	cmp	r0, r2
  4052dc:	d008      	beq.n	4052f0 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
  4052de:	691a      	ldr	r2, [r3, #16]
  4052e0:	428a      	cmp	r2, r1
  4052e2:	dc02      	bgt.n	4052ea <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
  4052e4:	f7ff ff96 	bl	405214 <move_thread_to_end_of_prio_q>
  4052e8:	e7de      	b.n	4052a8 <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
  4052ea:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
  4052ec:	611a      	str	r2, [r3, #16]
  4052ee:	e7dd      	b.n	4052ac <z_time_slice+0x24>
  4052f0:	2200      	movs	r2, #0
  4052f2:	e7fb      	b.n	4052ec <z_time_slice+0x64>
  4052f4:	20400bd4 	.word	0x20400bd4
  4052f8:	20400c00 	.word	0x20400c00
  4052fc:	20400c08 	.word	0x20400c08
  405300:	20400c04 	.word	0x20400c04
  405304:	20400508 	.word	0x20400508

00405308 <ready_thread>:
{
  405308:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  40530a:	f990 200d 	ldrsb.w	r2, [r0, #13]
  40530e:	7b43      	ldrb	r3, [r0, #13]
  405310:	2a00      	cmp	r2, #0
  405312:	db2a      	blt.n	40536a <ready_thread+0x62>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  405314:	06da      	lsls	r2, r3, #27
  405316:	d128      	bne.n	40536a <ready_thread+0x62>
  405318:	6982      	ldr	r2, [r0, #24]
  40531a:	bb32      	cbnz	r2, 40536a <ready_thread+0x62>
	thread->base.thread_state |= _THREAD_QUEUED;
  40531c:	f063 037f 	orn	r3, r3, #127	; 0x7f
	return list->head == list;
  405320:	4a13      	ldr	r2, [pc, #76]	; (405370 <ready_thread+0x68>)
  405322:	7343      	strb	r3, [r0, #13]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405324:	f102 051c 	add.w	r5, r2, #28
	return (node == list->tail) ? NULL : node->next;
  405328:	e9d2 3407 	ldrd	r3, r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40532c:	42ab      	cmp	r3, r5
  40532e:	d017      	beq.n	405360 <ready_thread+0x58>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  405330:	b1b3      	cbz	r3, 405360 <ready_thread+0x58>
	int32_t b1 = thread_1->base.prio;
  405332:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
  405336:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
  40533a:	428e      	cmp	r6, r1
  40533c:	d00b      	beq.n	405356 <ready_thread+0x4e>
		return b2 - b1;
  40533e:	1b89      	subs	r1, r1, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
  405340:	2900      	cmp	r1, #0
  405342:	dd08      	ble.n	405356 <ready_thread+0x4e>
	sys_dnode_t *const prev = successor->prev;
  405344:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
  405346:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
  40534a:	6010      	str	r0, [r2, #0]
	successor->prev = node;
  40534c:	6058      	str	r0, [r3, #4]
		update_cache(0);
  40534e:	2000      	movs	r0, #0
}
  405350:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
  405352:	f7ff bf3f 	b.w	4051d4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  405356:	42a3      	cmp	r3, r4
  405358:	d002      	beq.n	405360 <ready_thread+0x58>
  40535a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  40535c:	2b00      	cmp	r3, #0
  40535e:	d1ea      	bne.n	405336 <ready_thread+0x2e>
	node->prev = tail;
  405360:	e9c0 5400 	strd	r5, r4, [r0]
	tail->next = node;
  405364:	6020      	str	r0, [r4, #0]
	list->tail = node;
  405366:	6210      	str	r0, [r2, #32]
}
  405368:	e7f1      	b.n	40534e <ready_thread+0x46>
}
  40536a:	bc70      	pop	{r4, r5, r6}
  40536c:	4770      	bx	lr
  40536e:	bf00      	nop
  405370:	20400bd4 	.word	0x20400bd4

00405374 <z_sched_start>:
{
  405374:	b510      	push	{r4, lr}
	__asm__ volatile(
  405376:	f04f 0220 	mov.w	r2, #32
  40537a:	f3ef 8411 	mrs	r4, BASEPRI
  40537e:	f382 8812 	msr	BASEPRI_MAX, r2
  405382:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  405386:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
  405388:	0751      	lsls	r1, r2, #29
  40538a:	d404      	bmi.n	405396 <z_sched_start+0x22>
	__asm__ volatile(
  40538c:	f384 8811 	msr	BASEPRI, r4
  405390:	f3bf 8f6f 	isb	sy
}
  405394:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
  405396:	f022 0204 	bic.w	r2, r2, #4
  40539a:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
  40539c:	f7ff ffb4 	bl	405308 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  4053a0:	4621      	mov	r1, r4
  4053a2:	4802      	ldr	r0, [pc, #8]	; (4053ac <z_sched_start+0x38>)
}
  4053a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
  4053a8:	f7ff beee 	b.w	405188 <z_reschedule>
  4053ac:	20400c16 	.word	0x20400c16

004053b0 <unready_thread>:
{
  4053b0:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
  4053b2:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
  4053b6:	4601      	mov	r1, r0
	return (thread->base.thread_state & state) != 0U;
  4053b8:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
  4053ba:	2a00      	cmp	r2, #0
  4053bc:	da04      	bge.n	4053c8 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4053be:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  4053c2:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
  4053c4:	f001 fc34 	bl	406c30 <sys_dlist_remove>
	update_cache(thread == _current);
  4053c8:	4b04      	ldr	r3, [pc, #16]	; (4053dc <unready_thread+0x2c>)
  4053ca:	6898      	ldr	r0, [r3, #8]
  4053cc:	1a43      	subs	r3, r0, r1
  4053ce:	4258      	negs	r0, r3
  4053d0:	4158      	adcs	r0, r3
}
  4053d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
  4053d6:	f7ff befd 	b.w	4051d4 <update_cache>
  4053da:	bf00      	nop
  4053dc:	20400bd4 	.word	0x20400bd4

004053e0 <pend>:
{
  4053e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4053e4:	4606      	mov	r6, r0
  4053e6:	4615      	mov	r5, r2
  4053e8:	461c      	mov	r4, r3
	__asm__ volatile(
  4053ea:	f04f 0320 	mov.w	r3, #32
  4053ee:	f3ef 8711 	mrs	r7, BASEPRI
  4053f2:	f383 8812 	msr	BASEPRI_MAX, r3
  4053f6:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
  4053fa:	f001 fc89 	bl	406d10 <add_to_waitq_locked>
	__asm__ volatile(
  4053fe:	f387 8811 	msr	BASEPRI, r7
  405402:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  405406:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
  40540a:	bf08      	it	eq
  40540c:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
  405410:	d008      	beq.n	405424 <pend+0x44>
  405412:	462a      	mov	r2, r5
  405414:	4623      	mov	r3, r4
  405416:	f106 0018 	add.w	r0, r6, #24
  40541a:	4903      	ldr	r1, [pc, #12]	; (405428 <pend+0x48>)
}
  40541c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  405420:	f000 ba2a 	b.w	405878 <z_add_timeout>
  405424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  405428:	00406ccd 	.word	0x00406ccd

0040542c <z_pend_curr>:
	pending_current = _current;
  40542c:	4b07      	ldr	r3, [pc, #28]	; (40544c <z_pend_curr+0x20>)
  40542e:	6898      	ldr	r0, [r3, #8]
  405430:	4b07      	ldr	r3, [pc, #28]	; (405450 <z_pend_curr+0x24>)
{
  405432:	b510      	push	{r4, lr}
  405434:	460c      	mov	r4, r1
	pending_current = _current;
  405436:	6018      	str	r0, [r3, #0]
{
  405438:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
  40543a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40543e:	f7ff ffcf 	bl	4053e0 <pend>
  405442:	4620      	mov	r0, r4
}
  405444:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  405448:	f7fd bbb0 	b.w	402bac <arch_swap>
  40544c:	20400bd4 	.word	0x20400bd4
  405450:	20400c00 	.word	0x20400c00

00405454 <z_set_prio>:
{
  405454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  405456:	4604      	mov	r4, r0
	__asm__ volatile(
  405458:	f04f 0320 	mov.w	r3, #32
  40545c:	f3ef 8611 	mrs	r6, BASEPRI
  405460:	f383 8812 	msr	BASEPRI_MAX, r3
  405464:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
  405468:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
  40546a:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  40546c:	06da      	lsls	r2, r3, #27
  40546e:	d133      	bne.n	4054d8 <z_set_prio+0x84>
		if (need_sched) {
  405470:	6982      	ldr	r2, [r0, #24]
  405472:	bb8a      	cbnz	r2, 4054d8 <z_set_prio+0x84>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  405474:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  405478:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
  40547a:	f001 fbd9 	bl	406c30 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  40547e:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
  405480:	4a17      	ldr	r2, [pc, #92]	; (4054e0 <z_set_prio+0x8c>)
  405482:	f063 037f 	orn	r3, r3, #127	; 0x7f
				thread->base.prio = prio;
  405486:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
  405488:	7343      	strb	r3, [r0, #13]
  40548a:	4610      	mov	r0, r2
  40548c:	f850 3f1c 	ldr.w	r3, [r0, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405490:	4283      	cmp	r3, r0
  405492:	d01b      	beq.n	4054cc <z_set_prio+0x78>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  405494:	b1d3      	cbz	r3, 4054cc <z_set_prio+0x78>
	return (node == list->tail) ? NULL : node->next;
  405496:	6a17      	ldr	r7, [r2, #32]
	int32_t b2 = thread_2->base.prio;
  405498:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
  40549c:	42a9      	cmp	r1, r5
  40549e:	d010      	beq.n	4054c2 <z_set_prio+0x6e>
		return b2 - b1;
  4054a0:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
  4054a2:	2d00      	cmp	r5, #0
  4054a4:	dd0d      	ble.n	4054c2 <z_set_prio+0x6e>
	sys_dnode_t *const prev = successor->prev;
  4054a6:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
  4054a8:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
  4054ac:	6014      	str	r4, [r2, #0]
	successor->prev = node;
  4054ae:	605c      	str	r4, [r3, #4]
			update_cache(1);
  4054b0:	2001      	movs	r0, #1
  4054b2:	f7ff fe8f 	bl	4051d4 <update_cache>
  4054b6:	2001      	movs	r0, #1
	__asm__ volatile(
  4054b8:	f386 8811 	msr	BASEPRI, r6
  4054bc:	f3bf 8f6f 	isb	sy
}
  4054c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
  4054c2:	42bb      	cmp	r3, r7
  4054c4:	d002      	beq.n	4054cc <z_set_prio+0x78>
  4054c6:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4054c8:	2b00      	cmp	r3, #0
  4054ca:	d1e5      	bne.n	405498 <z_set_prio+0x44>
	sys_dnode_t *const tail = list->tail;
  4054cc:	6a13      	ldr	r3, [r2, #32]
	node->prev = tail;
  4054ce:	e9c4 0300 	strd	r0, r3, [r4]
	tail->next = node;
  4054d2:	601c      	str	r4, [r3, #0]
	list->tail = node;
  4054d4:	6214      	str	r4, [r2, #32]
}
  4054d6:	e7eb      	b.n	4054b0 <z_set_prio+0x5c>
			thread->base.prio = prio;
  4054d8:	2000      	movs	r0, #0
  4054da:	73a1      	strb	r1, [r4, #14]
  4054dc:	e7ec      	b.n	4054b8 <z_set_prio+0x64>
  4054de:	bf00      	nop
  4054e0:	20400bd4 	.word	0x20400bd4

004054e4 <z_impl_k_thread_suspend>:
{
  4054e4:	b570      	push	{r4, r5, r6, lr}
  4054e6:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  4054e8:	3018      	adds	r0, #24
  4054ea:	f001 fc85 	bl	406df8 <z_abort_timeout>
	__asm__ volatile(
  4054ee:	f04f 0320 	mov.w	r3, #32
  4054f2:	f3ef 8611 	mrs	r6, BASEPRI
  4054f6:	f383 8812 	msr	BASEPRI_MAX, r3
  4054fa:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
  4054fe:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
  405502:	7b63      	ldrb	r3, [r4, #13]
  405504:	2a00      	cmp	r2, #0
  405506:	da05      	bge.n	405514 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  405508:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
  40550c:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
  40550e:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
  405510:	f001 fb8e 	bl	406c30 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
  405514:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
  405516:	4d0b      	ldr	r5, [pc, #44]	; (405544 <z_impl_k_thread_suspend+0x60>)
  405518:	f043 0310 	orr.w	r3, r3, #16
  40551c:	68a8      	ldr	r0, [r5, #8]
  40551e:	7363      	strb	r3, [r4, #13]
  405520:	1b03      	subs	r3, r0, r4
  405522:	4258      	negs	r0, r3
  405524:	4158      	adcs	r0, r3
  405526:	f7ff fe55 	bl	4051d4 <update_cache>
	__asm__ volatile(
  40552a:	f386 8811 	msr	BASEPRI, r6
  40552e:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
  405532:	68ab      	ldr	r3, [r5, #8]
  405534:	42a3      	cmp	r3, r4
  405536:	d103      	bne.n	405540 <z_impl_k_thread_suspend+0x5c>
}
  405538:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
  40553c:	f001 bba6 	b.w	406c8c <z_reschedule_unlocked>
}
  405540:	bd70      	pop	{r4, r5, r6, pc}
  405542:	bf00      	nop
  405544:	20400bd4 	.word	0x20400bd4

00405548 <k_sched_unlock>:
{
  405548:	b510      	push	{r4, lr}
	__asm__ volatile(
  40554a:	f04f 0320 	mov.w	r3, #32
  40554e:	f3ef 8411 	mrs	r4, BASEPRI
  405552:	f383 8812 	msr	BASEPRI_MAX, r3
  405556:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
  40555a:	4b08      	ldr	r3, [pc, #32]	; (40557c <k_sched_unlock+0x34>)
		update_cache(0);
  40555c:	2000      	movs	r0, #0
		++_current->base.sched_locked;
  40555e:	689a      	ldr	r2, [r3, #8]
  405560:	7bd3      	ldrb	r3, [r2, #15]
  405562:	3301      	adds	r3, #1
  405564:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
  405566:	f7ff fe35 	bl	4051d4 <update_cache>
	__asm__ volatile(
  40556a:	f384 8811 	msr	BASEPRI, r4
  40556e:	f3bf 8f6f 	isb	sy
}
  405572:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
  405576:	f001 bb89 	b.w	406c8c <z_reschedule_unlocked>
  40557a:	bf00      	nop
  40557c:	20400bd4 	.word	0x20400bd4

00405580 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
  405580:	4b04      	ldr	r3, [pc, #16]	; (405594 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  405582:	2100      	movs	r1, #0
  405584:	f103 021c 	add.w	r2, r3, #28
  405588:	4608      	mov	r0, r1
	list->tail = (sys_dnode_t *)list;
  40558a:	e9c3 2207 	strd	r2, r2, [r3, #28]
  40558e:	f7ff bdd3 	b.w	405138 <k_sched_time_slice_set>
  405592:	bf00      	nop
  405594:	20400bd4 	.word	0x20400bd4

00405598 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
  405598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
  40559a:	f04f 0320 	mov.w	r3, #32
  40559e:	f3ef 8511 	mrs	r5, BASEPRI
  4055a2:	f383 8812 	msr	BASEPRI_MAX, r3
  4055a6:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
  4055aa:	491a      	ldr	r1, [pc, #104]	; (405614 <z_impl_k_yield+0x7c>)
  4055ac:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4055ae:	7b43      	ldrb	r3, [r0, #13]
  4055b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  4055b4:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
  4055b6:	f001 fb3b 	bl	406c30 <sys_dlist_remove>
	}
	queue_thread(_current);
  4055ba:	688b      	ldr	r3, [r1, #8]
	return list->head == list;
  4055bc:	4608      	mov	r0, r1
	thread->base.thread_state |= _THREAD_QUEUED;
  4055be:	7b5a      	ldrb	r2, [r3, #13]
  4055c0:	f062 027f 	orn	r2, r2, #127	; 0x7f
  4055c4:	735a      	strb	r2, [r3, #13]
  4055c6:	f850 2f1c 	ldr.w	r2, [r0, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4055ca:	4282      	cmp	r2, r0
  4055cc:	d01c      	beq.n	405608 <z_impl_k_yield+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4055ce:	b1da      	cbz	r2, 405608 <z_impl_k_yield+0x70>
	return (node == list->tail) ? NULL : node->next;
  4055d0:	6a0f      	ldr	r7, [r1, #32]
	int32_t b1 = thread_1->base.prio;
  4055d2:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
  4055d6:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
  4055da:	42a6      	cmp	r6, r4
  4055dc:	d00f      	beq.n	4055fe <z_impl_k_yield+0x66>
		return b2 - b1;
  4055de:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
  4055e0:	2c00      	cmp	r4, #0
  4055e2:	dd0c      	ble.n	4055fe <z_impl_k_yield+0x66>
	sys_dnode_t *const prev = successor->prev;
  4055e4:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
  4055e6:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
  4055ea:	600b      	str	r3, [r1, #0]
	successor->prev = node;
  4055ec:	6053      	str	r3, [r2, #4]
	update_cache(1);
  4055ee:	2001      	movs	r0, #1
  4055f0:	f7ff fdf0 	bl	4051d4 <update_cache>
  4055f4:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
  4055f6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  4055fa:	f7fd bad7 	b.w	402bac <arch_swap>
	return (node == list->tail) ? NULL : node->next;
  4055fe:	42ba      	cmp	r2, r7
  405600:	d002      	beq.n	405608 <z_impl_k_yield+0x70>
  405602:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  405604:	2a00      	cmp	r2, #0
  405606:	d1e6      	bne.n	4055d6 <z_impl_k_yield+0x3e>
	sys_dnode_t *const tail = list->tail;
  405608:	6a0a      	ldr	r2, [r1, #32]
	node->prev = tail;
  40560a:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
  40560e:	6013      	str	r3, [r2, #0]
	list->tail = node;
  405610:	620b      	str	r3, [r1, #32]
}
  405612:	e7ec      	b.n	4055ee <z_impl_k_yield+0x56>
  405614:	20400bd4 	.word	0x20400bd4

00405618 <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
  405618:	ea50 0301 	orrs.w	r3, r0, r1
{
  40561c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  405620:	4605      	mov	r5, r0
  405622:	460e      	mov	r6, r1
	if (ticks == 0) {
  405624:	d103      	bne.n	40562e <z_tick_sleep+0x16>
	z_impl_k_yield();
  405626:	f7ff ffb7 	bl	405598 <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
  40562a:	2000      	movs	r0, #0
  40562c:	e033      	b.n	405696 <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
  40562e:	f06f 0401 	mvn.w	r4, #1
  405632:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  405636:	1a24      	subs	r4, r4, r0
  405638:	eb63 0301 	sbc.w	r3, r3, r1
  40563c:	2c01      	cmp	r4, #1
  40563e:	f173 0300 	sbcs.w	r3, r3, #0
  405642:	da02      	bge.n	40564a <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  405644:	f001 fc08 	bl	406e58 <sys_clock_tick_get_32>
  405648:	1944      	adds	r4, r0, r5
  40564a:	f04f 0320 	mov.w	r3, #32
  40564e:	f3ef 8811 	mrs	r8, BASEPRI
  405652:	f383 8812 	msr	BASEPRI_MAX, r3
  405656:	f3bf 8f6f 	isb	sy
	pending_current = _current;
  40565a:	4f10      	ldr	r7, [pc, #64]	; (40569c <z_tick_sleep+0x84>)
  40565c:	4b10      	ldr	r3, [pc, #64]	; (4056a0 <z_tick_sleep+0x88>)
  40565e:	68b8      	ldr	r0, [r7, #8]
  405660:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
  405662:	f7ff fea5 	bl	4053b0 <unready_thread>
	z_add_thread_timeout(_current, timeout);
  405666:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  405668:	462a      	mov	r2, r5
  40566a:	490e      	ldr	r1, [pc, #56]	; (4056a4 <z_tick_sleep+0x8c>)
  40566c:	4633      	mov	r3, r6
  40566e:	3018      	adds	r0, #24
  405670:	f000 f902 	bl	405878 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  405674:	68ba      	ldr	r2, [r7, #8]
  405676:	4640      	mov	r0, r8
  405678:	7b53      	ldrb	r3, [r2, #13]
  40567a:	f043 0310 	orr.w	r3, r3, #16
  40567e:	7353      	strb	r3, [r2, #13]
  405680:	f7fd fa94 	bl	402bac <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  405684:	f001 fbe8 	bl	406e58 <sys_clock_tick_get_32>
  405688:	1a20      	subs	r0, r4, r0
  40568a:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
  40568e:	2801      	cmp	r0, #1
  405690:	f173 0300 	sbcs.w	r3, r3, #0
  405694:	dbc9      	blt.n	40562a <z_tick_sleep+0x12>
}
  405696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40569a:	bf00      	nop
  40569c:	20400bd4 	.word	0x20400bd4
  4056a0:	20400c00 	.word	0x20400c00
  4056a4:	00406ccd 	.word	0x00406ccd

004056a8 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4056a8:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
  4056ac:	bf08      	it	eq
  4056ae:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
  4056b2:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4056b4:	d106      	bne.n	4056c4 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
  4056b6:	4b07      	ldr	r3, [pc, #28]	; (4056d4 <z_impl_k_sleep+0x2c>)
  4056b8:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
  4056ba:	f7ff ff13 	bl	4054e4 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
  4056be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
  4056c2:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
  4056c4:	f7ff ffa8 	bl	405618 <z_tick_sleep>
			return t / ((uint64_t)from_hz / to_hz);
  4056c8:	220a      	movs	r2, #10
  4056ca:	2300      	movs	r3, #0
  4056cc:	17c1      	asrs	r1, r0, #31
  4056ce:	f7fb fc09 	bl	400ee4 <__aeabi_uldivmod>
	return ret;
  4056d2:	e7f6      	b.n	4056c2 <z_impl_k_sleep+0x1a>
  4056d4:	20400bd4 	.word	0x20400bd4

004056d8 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  4056d8:	4b01      	ldr	r3, [pc, #4]	; (4056e0 <z_impl_z_current_get+0x8>)
  4056da:	6898      	ldr	r0, [r3, #8]
  4056dc:	4770      	bx	lr
  4056de:	bf00      	nop
  4056e0:	20400bd4 	.word	0x20400bd4

004056e4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
  4056e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4056e8:	4604      	mov	r4, r0
  4056ea:	f04f 0320 	mov.w	r3, #32
  4056ee:	f3ef 8611 	mrs	r6, BASEPRI
  4056f2:	f383 8812 	msr	BASEPRI_MAX, r3
  4056f6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  4056fa:	7b43      	ldrb	r3, [r0, #13]
  4056fc:	071a      	lsls	r2, r3, #28
  4056fe:	d505      	bpl.n	40570c <z_thread_abort+0x28>
	__asm__ volatile(
  405700:	f386 8811 	msr	BASEPRI, r6
  405704:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
  405708:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
  40570c:	f023 0220 	bic.w	r2, r3, #32
  405710:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
  405714:	09d2      	lsrs	r2, r2, #7
  405716:	d120      	bne.n	40575a <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  405718:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
  40571a:	68a3      	ldr	r3, [r4, #8]
  40571c:	b113      	cbz	r3, 405724 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
  40571e:	4620      	mov	r0, r4
  405720:	f001 fa8e 	bl	406c40 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  405724:	f104 0758 	add.w	r7, r4, #88	; 0x58
  405728:	f04f 0800 	mov.w	r8, #0
	return z_abort_timeout(&thread->base.timeout);
  40572c:	f104 0018 	add.w	r0, r4, #24
  405730:	f001 fb62 	bl	406df8 <z_abort_timeout>
	return list->head == list;
  405734:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405736:	42bd      	cmp	r5, r7
  405738:	d000      	beq.n	40573c <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  40573a:	b9b5      	cbnz	r5, 40576a <z_thread_abort+0x86>
		update_cache(1);
  40573c:	2001      	movs	r0, #1
  40573e:	f7ff fd49 	bl	4051d4 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
  405742:	4b10      	ldr	r3, [pc, #64]	; (405784 <z_thread_abort+0xa0>)
  405744:	689b      	ldr	r3, [r3, #8]
  405746:	42a3      	cmp	r3, r4
  405748:	d1da      	bne.n	405700 <z_thread_abort+0x1c>
  40574a:	f3ef 8305 	mrs	r3, IPSR
  40574e:	2b00      	cmp	r3, #0
  405750:	d1d6      	bne.n	405700 <z_thread_abort+0x1c>
  405752:	4630      	mov	r0, r6
  405754:	f7fd fa2a 	bl	402bac <arch_swap>
	return ret;
  405758:	e7d2      	b.n	405700 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  40575a:	f003 035f 	and.w	r3, r3, #95	; 0x5f
  40575e:	f043 0308 	orr.w	r3, r3, #8
  405762:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
  405764:	f001 fa64 	bl	406c30 <sys_dlist_remove>
}
  405768:	e7d7      	b.n	40571a <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
  40576a:	4628      	mov	r0, r5
  40576c:	f001 fa68 	bl	406c40 <unpend_thread_no_timeout>
  405770:	f105 0018 	add.w	r0, r5, #24
  405774:	f001 fb40 	bl	406df8 <z_abort_timeout>
		ready_thread(thread);
  405778:	4628      	mov	r0, r5
  40577a:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
  40577e:	f7ff fdc3 	bl	405308 <ready_thread>
  405782:	e7d7      	b.n	405734 <z_thread_abort+0x50>
  405784:	20400bd4 	.word	0x20400bd4

00405788 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  405788:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  40578a:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
  40578e:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  405790:	e9cd 6700 	strd	r6, r7, [sp]
  405794:	f7ff fe4a 	bl	40542c <z_pend_curr>

	if (data != NULL) {
  405798:	b11c      	cbz	r4, 4057a2 <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
  40579a:	4b03      	ldr	r3, [pc, #12]	; (4057a8 <z_sched_wait+0x20>)
  40579c:	689b      	ldr	r3, [r3, #8]
  40579e:	695b      	ldr	r3, [r3, #20]
  4057a0:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
  4057a2:	b002      	add	sp, #8
  4057a4:	bdd0      	pop	{r4, r6, r7, pc}
  4057a6:	bf00      	nop
  4057a8:	20400bd4 	.word	0x20400bd4

004057ac <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
  4057ac:	4806      	ldr	r0, [pc, #24]	; (4057c8 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
  4057ae:	4a07      	ldr	r2, [pc, #28]	; (4057cc <z_data_copy+0x20>)
  4057b0:	4907      	ldr	r1, [pc, #28]	; (4057d0 <z_data_copy+0x24>)
  4057b2:	1a12      	subs	r2, r2, r0
{
  4057b4:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
  4057b6:	f000 fed2 	bl	40655e <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
  4057ba:	4a06      	ldr	r2, [pc, #24]	; (4057d4 <z_data_copy+0x28>)
  4057bc:	4906      	ldr	r1, [pc, #24]	; (4057d8 <z_data_copy+0x2c>)
  4057be:	4807      	ldr	r0, [pc, #28]	; (4057dc <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
  4057c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
  4057c4:	f000 becb 	b.w	40655e <memcpy>
  4057c8:	20400000 	.word	0x20400000
  4057cc:	20400050 	.word	0x20400050
  4057d0:	00408020 	.word	0x00408020
  4057d4:	00000000 	.word	0x00000000
  4057d8:	00408020 	.word	0x00408020
  4057dc:	20400000 	.word	0x20400000

004057e0 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  4057e0:	4b03      	ldr	r3, [pc, #12]	; (4057f0 <elapsed+0x10>)
  4057e2:	681b      	ldr	r3, [r3, #0]
  4057e4:	b90b      	cbnz	r3, 4057ea <elapsed+0xa>
  4057e6:	f7ff b863 	b.w	4048b0 <sys_clock_elapsed>
}
  4057ea:	2000      	movs	r0, #0
  4057ec:	4770      	bx	lr
  4057ee:	bf00      	nop
  4057f0:	20400c0c 	.word	0x20400c0c

004057f4 <next_timeout>:
	return list->head == list;
  4057f4:	4b11      	ldr	r3, [pc, #68]	; (40583c <next_timeout+0x48>)

static int32_t next_timeout(void)
{
  4057f6:	b510      	push	{r4, lr}
  4057f8:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4057fa:	429c      	cmp	r4, r3
  4057fc:	bf08      	it	eq
  4057fe:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  405800:	f7ff ffee 	bl	4057e0 <elapsed>
  405804:	4603      	mov	r3, r0
	int32_t ret = to == NULL ? MAX_WAIT
  405806:	b16c      	cbz	r4, 405824 <next_timeout+0x30>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
  405808:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
  40580c:	1ac0      	subs	r0, r0, r3
  40580e:	eb62 73e3 	sbc.w	r3, r2, r3, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
  405812:	2801      	cmp	r0, #1
  405814:	f173 0200 	sbcs.w	r2, r3, #0
  405818:	db0d      	blt.n	405836 <next_timeout+0x42>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
  40581a:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
  40581e:	f173 0300 	sbcs.w	r3, r3, #0
  405822:	db01      	blt.n	405828 <next_timeout+0x34>
	int32_t ret = to == NULL ? MAX_WAIT
  405824:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
  405828:	4b05      	ldr	r3, [pc, #20]	; (405840 <next_timeout+0x4c>)
  40582a:	691b      	ldr	r3, [r3, #16]
  40582c:	b113      	cbz	r3, 405834 <next_timeout+0x40>
  40582e:	4298      	cmp	r0, r3
  405830:	bfa8      	it	ge
  405832:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
  405834:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
  405836:	2000      	movs	r0, #0
  405838:	e7f6      	b.n	405828 <next_timeout+0x34>
  40583a:	bf00      	nop
  40583c:	20400014 	.word	0x20400014
  405840:	20400bd4 	.word	0x20400bd4

00405844 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
  405844:	6803      	ldr	r3, [r0, #0]
{
  405846:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  405848:	b168      	cbz	r0, 405866 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
  40584a:	4a0a      	ldr	r2, [pc, #40]	; (405874 <remove_timeout+0x30>)
  40584c:	6852      	ldr	r2, [r2, #4]
  40584e:	4290      	cmp	r0, r2
  405850:	d009      	beq.n	405866 <remove_timeout+0x22>
	if (next(t) != NULL) {
  405852:	b143      	cbz	r3, 405866 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
  405854:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
  405858:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  40585c:	1912      	adds	r2, r2, r4
  40585e:	eb41 0105 	adc.w	r1, r1, r5
  405862:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
  405866:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
  405868:	6013      	str	r3, [r2, #0]
	next->prev = prev;
  40586a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
  40586c:	2300      	movs	r3, #0
	node->prev = NULL;
  40586e:	e9c0 3300 	strd	r3, r3, [r0]
}
  405872:	bd30      	pop	{r4, r5, pc}
  405874:	20400014 	.word	0x20400014

00405878 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  405878:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
  40587c:	bf08      	it	eq
  40587e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
  405882:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  405884:	4604      	mov	r4, r0
  405886:	461f      	mov	r7, r3
  405888:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  40588a:	d067      	beq.n	40595c <z_add_timeout+0xe4>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
  40588c:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
  40588e:	f04f 0320 	mov.w	r3, #32
  405892:	f3ef 8611 	mrs	r6, BASEPRI
  405896:	f383 8812 	msr	BASEPRI_MAX, r3
  40589a:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
  40589e:	f06f 0201 	mvn.w	r2, #1
  4058a2:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  4058a6:	1b53      	subs	r3, r2, r5
  4058a8:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  4058ac:	2b00      	cmp	r3, #0
  4058ae:	db1b      	blt.n	4058e8 <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  4058b0:	4b2b      	ldr	r3, [pc, #172]	; (405960 <z_add_timeout+0xe8>)
  4058b2:	e9d3 1300 	ldrd	r1, r3, [r3]
  4058b6:	1a52      	subs	r2, r2, r1
  4058b8:	eb6c 0303 	sbc.w	r3, ip, r3
  4058bc:	1b55      	subs	r5, r2, r5

			to->dticks = MAX(1, ticks);
  4058be:	eb63 0307 	sbc.w	r3, r3, r7
  4058c2:	2d01      	cmp	r5, #1
  4058c4:	f173 0200 	sbcs.w	r2, r3, #0
  4058c8:	bfbc      	itt	lt
  4058ca:	2501      	movlt	r5, #1
  4058cc:	2300      	movlt	r3, #0
  4058ce:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
  4058d2:	4824      	ldr	r0, [pc, #144]	; (405964 <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
  4058d4:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4058d8:	4283      	cmp	r3, r0
  4058da:	d118      	bne.n	40590e <z_add_timeout+0x96>
	node->prev = tail;
  4058dc:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
  4058e0:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
  4058e4:	6044      	str	r4, [r0, #4]
}
  4058e6:	e026      	b.n	405936 <z_add_timeout+0xbe>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
  4058e8:	f7ff ff7a 	bl	4057e0 <elapsed>
  4058ec:	3501      	adds	r5, #1
  4058ee:	f147 0700 	adc.w	r7, r7, #0
  4058f2:	182d      	adds	r5, r5, r0
  4058f4:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
  4058f8:	e9c4 5704 	strd	r5, r7, [r4, #16]
  4058fc:	e7e9      	b.n	4058d2 <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
  4058fe:	1a52      	subs	r2, r2, r1
  405900:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
  405904:	459c      	cmp	ip, r3
  405906:	e9c4 2504 	strd	r2, r5, [r4, #16]
  40590a:	d0e7      	beq.n	4058dc <z_add_timeout+0x64>
  40590c:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
  40590e:	2b00      	cmp	r3, #0
  405910:	d0e4      	beq.n	4058dc <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
  405912:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
  405916:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
  40591a:	428a      	cmp	r2, r1
  40591c:	eb75 0e07 	sbcs.w	lr, r5, r7
  405920:	daed      	bge.n	4058fe <z_add_timeout+0x86>
				t->dticks -= to->dticks;
  405922:	1a8a      	subs	r2, r1, r2
  405924:	eb67 0505 	sbc.w	r5, r7, r5
  405928:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
  40592c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
  40592e:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
  405932:	6014      	str	r4, [r2, #0]
	successor->prev = node;
  405934:	605c      	str	r4, [r3, #4]
	return list->head == list;
  405936:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405938:	4283      	cmp	r3, r0
  40593a:	d00b      	beq.n	405954 <z_add_timeout+0xdc>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  40593c:	429c      	cmp	r4, r3
  40593e:	d109      	bne.n	405954 <z_add_timeout+0xdc>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
  405940:	f7ff ff58 	bl	4057f4 <next_timeout>

			if (next_time == 0 ||
  405944:	b118      	cbz	r0, 40594e <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
  405946:	4b08      	ldr	r3, [pc, #32]	; (405968 <z_add_timeout+0xf0>)
			if (next_time == 0 ||
  405948:	691b      	ldr	r3, [r3, #16]
  40594a:	4283      	cmp	r3, r0
  40594c:	d002      	beq.n	405954 <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
  40594e:	2100      	movs	r1, #0
  405950:	f7fe ff3c 	bl	4047cc <sys_clock_set_timeout>
	__asm__ volatile(
  405954:	f386 8811 	msr	BASEPRI, r6
  405958:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
  40595c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40595e:	bf00      	nop
  405960:	20400608 	.word	0x20400608
  405964:	20400014 	.word	0x20400014
  405968:	20400bd4 	.word	0x20400bd4

0040596c <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
  40596c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  405970:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
  405972:	f7ff fc89 	bl	405288 <z_time_slice>
	__asm__ volatile(
  405976:	f04f 0320 	mov.w	r3, #32
  40597a:	f3ef 8411 	mrs	r4, BASEPRI
  40597e:	f383 8812 	msr	BASEPRI_MAX, r3
  405982:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
  405986:	4e24      	ldr	r6, [pc, #144]	; (405a18 <sys_clock_announce+0xac>)
	return list->head == list;
  405988:	f8df 8090 	ldr.w	r8, [pc, #144]	; 405a1c <sys_clock_announce+0xb0>
  40598c:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
  40598e:	4d24      	ldr	r5, [pc, #144]	; (405a20 <sys_clock_announce+0xb4>)
  405990:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
  405994:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405996:	4540      	cmp	r0, r8
  405998:	ea4f 77e2 	mov.w	r7, r2, asr #31
		curr_tick += dt;
  40599c:	e9d5 1e00 	ldrd	r1, lr, [r5]
  4059a0:	d00b      	beq.n	4059ba <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
  4059a2:	b150      	cbz	r0, 4059ba <sys_clock_announce+0x4e>
  4059a4:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
  4059a8:	429a      	cmp	r2, r3
  4059aa:	eb77 090c 	sbcs.w	r9, r7, ip
  4059ae:	da16      	bge.n	4059de <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
  4059b0:	1a9b      	subs	r3, r3, r2
  4059b2:	eb6c 0c07 	sbc.w	ip, ip, r7
  4059b6:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
  4059ba:	1852      	adds	r2, r2, r1
  4059bc:	eb4e 0707 	adc.w	r7, lr, r7
  4059c0:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
  4059c4:	2500      	movs	r5, #0
  4059c6:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
  4059c8:	f7ff ff14 	bl	4057f4 <next_timeout>
  4059cc:	4629      	mov	r1, r5
  4059ce:	f7fe fefd 	bl	4047cc <sys_clock_set_timeout>
	__asm__ volatile(
  4059d2:	f384 8811 	msr	BASEPRI, r4
  4059d6:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
  4059da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
  4059de:	1859      	adds	r1, r3, r1
  4059e0:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
  4059e4:	1ad3      	subs	r3, r2, r3
		t->dticks = 0;
  4059e6:	2200      	movs	r2, #0
		announce_remaining -= dt;
  4059e8:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
  4059ea:	2300      	movs	r3, #0
  4059ec:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
  4059f0:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
  4059f4:	f7ff ff26 	bl	405844 <remove_timeout>
  4059f8:	f384 8811 	msr	BASEPRI, r4
  4059fc:	f3bf 8f6f 	isb	sy
		t->fn(t);
  405a00:	6883      	ldr	r3, [r0, #8]
  405a02:	4798      	blx	r3
	__asm__ volatile(
  405a04:	f04f 0320 	mov.w	r3, #32
  405a08:	f3ef 8411 	mrs	r4, BASEPRI
  405a0c:	f383 8812 	msr	BASEPRI_MAX, r3
  405a10:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
  405a14:	e7bc      	b.n	405990 <sys_clock_announce+0x24>
  405a16:	bf00      	nop
  405a18:	20400c0c 	.word	0x20400c0c
  405a1c:	20400014 	.word	0x20400014
  405a20:	20400608 	.word	0x20400608

00405a24 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  405a24:	b510      	push	{r4, lr}
  405a26:	f04f 0320 	mov.w	r3, #32
  405a2a:	f3ef 8411 	mrs	r4, BASEPRI
  405a2e:	f383 8812 	msr	BASEPRI_MAX, r3
  405a32:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
  405a36:	f7fe ff3b 	bl	4048b0 <sys_clock_elapsed>
  405a3a:	4a05      	ldr	r2, [pc, #20]	; (405a50 <sys_clock_tick_get+0x2c>)
  405a3c:	e9d2 3100 	ldrd	r3, r1, [r2]
  405a40:	18c0      	adds	r0, r0, r3
  405a42:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
  405a46:	f384 8811 	msr	BASEPRI, r4
  405a4a:	f3bf 8f6f 	isb	sy
	}
	return t;
}
  405a4e:	bd10      	pop	{r4, pc}
  405a50:	20400608 	.word	0x20400608

00405a54 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  405a54:	b570      	push	{r4, r5, r6, lr}
  405a56:	4604      	mov	r4, r0
	__asm__ volatile(
  405a58:	f04f 0320 	mov.w	r3, #32
  405a5c:	f3ef 8511 	mrs	r5, BASEPRI
  405a60:	f383 8812 	msr	BASEPRI_MAX, r3
  405a64:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  405a68:	e9d0 320a 	ldrd	r3, r2, [r0, #40]	; 0x28
  405a6c:	3301      	adds	r3, #1
  405a6e:	f142 0200 	adc.w	r2, r2, #0
  405a72:	2b02      	cmp	r3, #2
  405a74:	f172 0300 	sbcs.w	r3, r2, #0
  405a78:	d304      	bcc.n	405a84 <z_timer_expiration_handler+0x30>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  405a7a:	4918      	ldr	r1, [pc, #96]	; (405adc <z_timer_expiration_handler+0x88>)
  405a7c:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
  405a80:	f7ff fefa 	bl	405878 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
  405a84:	6b23      	ldr	r3, [r4, #48]	; 0x30
  405a86:	3301      	adds	r3, #1
  405a88:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  405a8a:	6a23      	ldr	r3, [r4, #32]
  405a8c:	b173      	cbz	r3, 405aac <z_timer_expiration_handler+0x58>
	__asm__ volatile(
  405a8e:	f385 8811 	msr	BASEPRI, r5
  405a92:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
  405a96:	6a23      	ldr	r3, [r4, #32]
  405a98:	4620      	mov	r0, r4
  405a9a:	4798      	blx	r3
	__asm__ volatile(
  405a9c:	f04f 0320 	mov.w	r3, #32
  405aa0:	f3ef 8511 	mrs	r5, BASEPRI
  405aa4:	f383 8812 	msr	BASEPRI_MAX, r3
  405aa8:	f3bf 8f6f 	isb	sy
	return list->head == list;
  405aac:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  405ab0:	42a6      	cmp	r6, r4
  405ab2:	d000      	beq.n	405ab6 <z_timer_expiration_handler+0x62>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  405ab4:	b926      	cbnz	r6, 405ac0 <z_timer_expiration_handler+0x6c>
	__asm__ volatile(
  405ab6:	f385 8811 	msr	BASEPRI, r5
  405aba:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
  405abe:	bd70      	pop	{r4, r5, r6, pc}
	z_unpend_thread_no_timeout(thread);
  405ac0:	4630      	mov	r0, r6
  405ac2:	f001 f8c7 	bl	406c54 <z_unpend_thread_no_timeout>
  405ac6:	2300      	movs	r3, #0
  405ac8:	67b3      	str	r3, [r6, #120]	; 0x78
  405aca:	f385 8811 	msr	BASEPRI, r5
  405ace:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
  405ad2:	4630      	mov	r0, r6
}
  405ad4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
  405ad8:	f001 b8e8 	b.w	406cac <z_ready_thread>
  405adc:	00405a55 	.word	0x00405a55

00405ae0 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
  405ae0:	4611      	mov	r1, r2
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  405ae2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
  405ae6:	bf08      	it	eq
  405ae8:	f1b1 3fff 	cmpeq.w	r1, #4294967295	; 0xffffffff
{
  405aec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  405af0:	4606      	mov	r6, r0
  405af2:	461c      	mov	r4, r3
  405af4:	4689      	mov	r9, r1
  405af6:	4698      	mov	r8, r3
  405af8:	e9dd 2008 	ldrd	r2, r0, [sp, #32]
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  405afc:	d03e      	beq.n	405b7c <z_impl_k_timer_start+0x9c>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
  405afe:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
  405b02:	bf08      	it	eq
  405b04:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
  405b08:	4615      	mov	r5, r2
  405b0a:	4607      	mov	r7, r0
  405b0c:	d014      	beq.n	405b38 <z_impl_k_timer_start+0x58>
  405b0e:	ea50 0302 	orrs.w	r3, r0, r2
  405b12:	d011      	beq.n	405b38 <z_impl_k_timer_start+0x58>
	    Z_TICK_ABS(period.ticks) < 0) {
  405b14:	f06f 0301 	mvn.w	r3, #1
  405b18:	1a9b      	subs	r3, r3, r2
  405b1a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  405b1e:	eb63 0300 	sbc.w	r3, r3, r0
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
  405b22:	2b00      	cmp	r3, #0
  405b24:	da08      	bge.n	405b38 <z_impl_k_timer_start+0x58>
		period.ticks = MAX(period.ticks - 1, 1);
  405b26:	2a02      	cmp	r2, #2
  405b28:	f170 0300 	sbcs.w	r3, r0, #0
  405b2c:	bfbc      	itt	lt
  405b2e:	2502      	movlt	r5, #2
  405b30:	2700      	movlt	r7, #0
  405b32:	3d01      	subs	r5, #1
  405b34:	f147 37ff 	adc.w	r7, r7, #4294967295	; 0xffffffff
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
  405b38:	f06f 0301 	mvn.w	r3, #1
  405b3c:	1a5b      	subs	r3, r3, r1
  405b3e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  405b42:	eb63 0304 	sbc.w	r3, r3, r4
  405b46:	2b00      	cmp	r3, #0
  405b48:	da09      	bge.n	405b5e <z_impl_k_timer_start+0x7e>
		duration.ticks = MAX(duration.ticks - 1, 0);
  405b4a:	2901      	cmp	r1, #1
  405b4c:	f174 0300 	sbcs.w	r3, r4, #0
  405b50:	bfbc      	itt	lt
  405b52:	2101      	movlt	r1, #1
  405b54:	2400      	movlt	r4, #0
  405b56:	f111 39ff 	adds.w	r9, r1, #4294967295	; 0xffffffff
  405b5a:	f144 38ff 	adc.w	r8, r4, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
  405b5e:	4630      	mov	r0, r6
  405b60:	f001 f94a 	bl	406df8 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
  405b64:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  405b66:	464a      	mov	r2, r9
  405b68:	4630      	mov	r0, r6
	timer->status = 0U;
  405b6a:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  405b6c:	4643      	mov	r3, r8
  405b6e:	4904      	ldr	r1, [pc, #16]	; (405b80 <z_impl_k_timer_start+0xa0>)
	timer->period = period;
  405b70:	e9c6 570a 	strd	r5, r7, [r6, #40]	; 0x28
		     duration);
}
  405b74:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  405b78:	f7ff be7e 	b.w	405878 <z_add_timeout>
}
  405b7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  405b80:	00405a55 	.word	0x00405a55

00405b84 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
  405b84:	4a02      	ldr	r2, [pc, #8]	; (405b90 <boot_banner+0xc>)
  405b86:	4903      	ldr	r1, [pc, #12]	; (405b94 <boot_banner+0x10>)
  405b88:	4803      	ldr	r0, [pc, #12]	; (405b98 <boot_banner+0x14>)
  405b8a:	f000 b872 	b.w	405c72 <printk>
  405b8e:	bf00      	nop
  405b90:	004075fa 	.word	0x004075fa
  405b94:	00407fd1 	.word	0x00407fd1
  405b98:	00407fee 	.word	0x00407fee

00405b9c <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
  405b9c:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
  405b9e:	4c06      	ldr	r4, [pc, #24]	; (405bb8 <statics_init+0x1c>)
  405ba0:	4d06      	ldr	r5, [pc, #24]	; (405bbc <statics_init+0x20>)
  405ba2:	42ac      	cmp	r4, r5
  405ba4:	d301      	bcc.n	405baa <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
  405ba6:	2000      	movs	r0, #0
  405ba8:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  405baa:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
  405bae:	4620      	mov	r0, r4
	STRUCT_SECTION_FOREACH(k_heap, h) {
  405bb0:	3414      	adds	r4, #20
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  405bb2:	f001 f980 	bl	406eb6 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  405bb6:	e7f4      	b.n	405ba2 <statics_init+0x6>
  405bb8:	20400040 	.word	0x20400040
  405bbc:	20400040 	.word	0x20400040

00405bc0 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
  405bc0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
  405bc2:	4b09      	ldr	r3, [pc, #36]	; (405be8 <k_sys_work_q_init+0x28>)
  405bc4:	2400      	movs	r4, #0
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  405bc6:	f44f 6280 	mov.w	r2, #1024	; 0x400
  405bca:	4908      	ldr	r1, [pc, #32]	; (405bec <k_sys_work_q_init+0x2c>)
	struct k_work_queue_config cfg = {
  405bcc:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
  405bce:	ab02      	add	r3, sp, #8
  405bd0:	4807      	ldr	r0, [pc, #28]	; (405bf0 <k_sys_work_q_init+0x30>)
  405bd2:	9300      	str	r3, [sp, #0]
  405bd4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	struct k_work_queue_config cfg = {
  405bd8:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
  405bdc:	f7ff fa5e 	bl	40509c <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  405be0:	4620      	mov	r0, r4
  405be2:	b004      	add	sp, #16
  405be4:	bd10      	pop	{r4, pc}
  405be6:	bf00      	nop
  405be8:	00408015 	.word	0x00408015
  405bec:	20401ce0 	.word	0x20401ce0
  405bf0:	20400610 	.word	0x20400610

00405bf4 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
  405bf4:	4770      	bx	lr

00405bf6 <cbpprintf>:
	va_end(ap);
	return ret;
}

int cbpprintf(cbprintf_cb out, void *ctx, void *packaged)
{
  405bf6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  405bfa:	4606      	mov	r6, r0
  405bfc:	460f      	mov	r7, r1
	uint8_t *buf = packaged;
	char *fmt, *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, s_idx;

	if (buf == NULL) {
  405bfe:	4615      	mov	r5, r2
  405c00:	b1fa      	cbz	r2, 405c42 <cbpprintf+0x4c>
	args_size = buf[0] * sizeof(int);
	s_nbr     = buf[1];
	ros_nbr   = buf[2];

	/* Locate the string table */
	s = (char *)(buf + args_size + ros_nbr);
  405c02:	7810      	ldrb	r0, [r2, #0]

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
  405c04:	f04f 0800 	mov.w	r8, #0
	s = (char *)(buf + args_size + ros_nbr);
  405c08:	7894      	ldrb	r4, [r2, #2]
	s_nbr     = buf[1];
  405c0a:	f892 9001 	ldrb.w	r9, [r2, #1]
	s = (char *)(buf + args_size + ros_nbr);
  405c0e:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  405c12:	4414      	add	r4, r2
	for (i = 0; i < s_nbr; i++) {
  405c14:	45c8      	cmp	r8, r9
  405c16:	d308      	bcc.n	405c2a <cbpprintf+0x34>
	return cbvprintf(out, ctx, fmt, u.ap);
  405c18:	f105 0308 	add.w	r3, r5, #8
  405c1c:	686a      	ldr	r2, [r5, #4]
  405c1e:	4639      	mov	r1, r7
  405c20:	4630      	mov	r0, r6
	/* skip past format string pointer */
	buf += sizeof(char *) * 2;

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, ctx, fmt, buf);
}
  405c22:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return cbvprintf(out, ctx, fmt, u.ap);
  405c26:	f7fb bdf9 	b.w	40181c <cbvprintf>
		ps = (char **)(buf + s_idx * sizeof(int));
  405c2a:	f814 3b01 	ldrb.w	r3, [r4], #1
	for (i = 0; i < s_nbr; i++) {
  405c2e:	f108 0801 	add.w	r8, r8, #1
		s += strlen(s) + 1;
  405c32:	4620      	mov	r0, r4
		*ps = s;
  405c34:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
		s += strlen(s) + 1;
  405c38:	f000 fc81 	bl	40653e <strlen>
  405c3c:	3001      	adds	r0, #1
  405c3e:	4404      	add	r4, r0
	for (i = 0; i < s_nbr; i++) {
  405c40:	e7e8      	b.n	405c14 <cbpprintf+0x1e>
}
  405c42:	f06f 0015 	mvn.w	r0, #21
  405c46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00405c4a <arch_printk_char_out>:
}
  405c4a:	2000      	movs	r0, #0
  405c4c:	4770      	bx	lr

00405c4e <str_out>:
{
  405c4e:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
  405c50:	688a      	ldr	r2, [r1, #8]
  405c52:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
  405c54:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
  405c56:	b114      	cbz	r4, 405c5e <str_out+0x10>
  405c58:	684b      	ldr	r3, [r1, #4]
  405c5a:	4293      	cmp	r3, r2
  405c5c:	dc01      	bgt.n	405c62 <str_out+0x14>
		ctx->count++;
  405c5e:	608d      	str	r5, [r1, #8]
}
  405c60:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
  405c62:	3b01      	subs	r3, #1
		ctx->str[ctx->count++] = '\0';
  405c64:	608d      	str	r5, [r1, #8]
	if (ctx->count == ctx->max - 1) {
  405c66:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
  405c68:	bf0a      	itet	eq
  405c6a:	2200      	moveq	r2, #0
		ctx->str[ctx->count++] = c;
  405c6c:	54a0      	strbne	r0, [r4, r2]
		ctx->str[ctx->count++] = '\0';
  405c6e:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
  405c70:	e7f6      	b.n	405c60 <str_out+0x12>

00405c72 <printk>:
{
  405c72:	b40f      	push	{r0, r1, r2, r3}
  405c74:	b507      	push	{r0, r1, r2, lr}
  405c76:	a904      	add	r1, sp, #16
  405c78:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
  405c7c:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
  405c7e:	f7fb fdab 	bl	4017d8 <vprintk>
}
  405c82:	b003      	add	sp, #12
  405c84:	f85d eb04 	ldr.w	lr, [sp], #4
  405c88:	b004      	add	sp, #16
  405c8a:	4770      	bx	lr

00405c8c <snprintk>:
{
  405c8c:	b40c      	push	{r2, r3}
  405c8e:	b507      	push	{r0, r1, r2, lr}
  405c90:	ab04      	add	r3, sp, #16
  405c92:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
  405c96:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
  405c98:	f7fb fdac 	bl	4017f4 <vsnprintk>
}
  405c9c:	b003      	add	sp, #12
  405c9e:	f85d eb04 	ldr.w	lr, [sp], #4
  405ca2:	b002      	add	sp, #8
  405ca4:	4770      	bx	lr

00405ca6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  405ca6:	4604      	mov	r4, r0
  405ca8:	4608      	mov	r0, r1
  405caa:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  405cac:	461a      	mov	r2, r3
{
  405cae:	b508      	push	{r3, lr}
	entry(p1, p2, p3);
  405cb0:	47a0      	blx	r4
	return z_impl_z_current_get();
  405cb2:	f7ff fd11 	bl	4056d8 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
  405cb6:	f7fd fb2b 	bl	403310 <z_impl_k_thread_abort>

00405cba <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
  405cba:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
  405cbc:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
  405cc0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((uint32_t *)cmem)[f];
  405cc4:	bf2c      	ite	cs
  405cc6:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((uint16_t *)cmem)[f];
  405cca:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
  405cce:	4770      	bx	lr

00405cd0 <chunk_set>:
			     enum chunk_fields f, chunkid_t val)
{
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
  405cd0:	eb00 01c1 	add.w	r1, r0, r1, lsl #3

	if (big_heap(h)) {
  405cd4:	6880      	ldr	r0, [r0, #8]
  405cd6:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
  405cda:	bf2c      	ite	cs
  405cdc:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
  405ce0:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
  405ce4:	4770      	bx	lr

00405ce6 <chunk_size>:
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  405ce6:	2201      	movs	r2, #1
{
  405ce8:	b508      	push	{r3, lr}
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  405cea:	f7ff ffe6 	bl	405cba <chunk_field>
}
  405cee:	40d0      	lsrs	r0, r2
  405cf0:	bd08      	pop	{r3, pc}

00405cf2 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
  405cf2:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
  405cf4:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
  405cf8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  405cfc:	d308      	bcc.n	405d10 <set_chunk_used+0x1e>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  405cfe:	684b      	ldr	r3, [r1, #4]
		if (used) {
  405d00:	b11a      	cbz	r2, 405d0a <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  405d02:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  405d06:	604b      	str	r3, [r1, #4]
  405d08:	4770      	bx	lr
  405d0a:	f023 0301 	bic.w	r3, r3, #1
  405d0e:	e7fa      	b.n	405d06 <set_chunk_used+0x14>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
  405d10:	884b      	ldrh	r3, [r1, #2]
		if (used) {
  405d12:	b11a      	cbz	r2, 405d1c <set_chunk_used+0x2a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
  405d14:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
  405d18:	804b      	strh	r3, [r1, #2]
		}
	}
}
  405d1a:	4770      	bx	lr
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
  405d1c:	f023 0301 	bic.w	r3, r3, #1
  405d20:	e7fa      	b.n	405d18 <set_chunk_used+0x26>

00405d22 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  405d22:	0053      	lsls	r3, r2, #1
  405d24:	2201      	movs	r2, #1
  405d26:	f7ff bfd3 	b.w	405cd0 <chunk_set>

00405d2a <bucket_idx.isra.0>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
  405d2a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  405d2e:	f101 0101 	add.w	r1, r1, #1
	return big_heap(h) ? 8 : 4;
  405d32:	bf2c      	ite	cs
  405d34:	2008      	movcs	r0, #8
  405d36:	2004      	movcc	r0, #4
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  405d38:	3008      	adds	r0, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  405d3a:	eba1 00d0 	sub.w	r0, r1, r0, lsr #3
	return 31 - __builtin_clz(usable_sz);
  405d3e:	fab0 f080 	clz	r0, r0
}
  405d42:	f1c0 001f 	rsb	r0, r0, #31
  405d46:	4770      	bx	lr

00405d48 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
  405d48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return big_heap_chunks(h->end_chunk);
  405d4c:	6886      	ldr	r6, [r0, #8]
  405d4e:	460d      	mov	r5, r1
  405d50:	4604      	mov	r4, r0
	return big_heap(h) && chunk_size(h, c) == 1U;
  405d52:	f7ff ffc8 	bl	405ce6 <chunk_size>
  405d56:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
  405d5a:	4601      	mov	r1, r0
  405d5c:	d301      	bcc.n	405d62 <free_list_add+0x1a>
	if (!solo_free_header(h, c)) {
  405d5e:	2801      	cmp	r0, #1
  405d60:	d033      	beq.n	405dca <free_list_add+0x82>
		int bidx = bucket_idx(h, chunk_size(h, c));
  405d62:	4630      	mov	r0, r6
  405d64:	f7ff ffe1 	bl	405d2a <bucket_idx.isra.0>
	if (b->next == 0U) {
  405d68:	eb04 0280 	add.w	r2, r4, r0, lsl #2
  405d6c:	6916      	ldr	r6, [r2, #16]
  405d6e:	b99e      	cbnz	r6, 405d98 <free_list_add+0x50>
		h->avail_buckets |= BIT(bidx);
  405d70:	2301      	movs	r3, #1
	chunk_set(h, c, FREE_PREV, prev);
  405d72:	4629      	mov	r1, r5
  405d74:	fa03 f000 	lsl.w	r0, r3, r0
  405d78:	68e3      	ldr	r3, [r4, #12]
  405d7a:	4303      	orrs	r3, r0
  405d7c:	4620      	mov	r0, r4
  405d7e:	60e3      	str	r3, [r4, #12]
  405d80:	462b      	mov	r3, r5
		b->next = c;
  405d82:	6115      	str	r5, [r2, #16]
  405d84:	2202      	movs	r2, #2
  405d86:	f7ff ffa3 	bl	405cd0 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
  405d8a:	2203      	movs	r2, #3
  405d8c:	4629      	mov	r1, r5
	chunk_set(h, c, FREE_PREV, prev);
  405d8e:	4620      	mov	r0, r4
		free_list_add_bidx(h, c, bidx);
	}
}
  405d90:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  405d94:	f7ff bf9c 	b.w	405cd0 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
  405d98:	2202      	movs	r2, #2
  405d9a:	4631      	mov	r1, r6
  405d9c:	4620      	mov	r0, r4
  405d9e:	f7ff ff8c 	bl	405cba <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
  405da2:	4629      	mov	r1, r5
  405da4:	4603      	mov	r3, r0
	return chunk_field(h, c, FREE_PREV);
  405da6:	4607      	mov	r7, r0
	chunk_set(h, c, FREE_PREV, prev);
  405da8:	4620      	mov	r0, r4
  405daa:	f7ff ff91 	bl	405cd0 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
  405dae:	2203      	movs	r2, #3
  405db0:	4633      	mov	r3, r6
  405db2:	4629      	mov	r1, r5
  405db4:	4620      	mov	r0, r4
  405db6:	f7ff ff8b 	bl	405cd0 <chunk_set>
  405dba:	4639      	mov	r1, r7
  405dbc:	462b      	mov	r3, r5
  405dbe:	4620      	mov	r0, r4
  405dc0:	f7ff ff86 	bl	405cd0 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
  405dc4:	2202      	movs	r2, #2
  405dc6:	4631      	mov	r1, r6
  405dc8:	e7e1      	b.n	405d8e <free_list_add+0x46>
  405dca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00405dce <sys_heap_init>:
	return big_heap_bytes(size) ? 8 : 4;
  405dce:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  405dd2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  405dd4:	bf2c      	ite	cs
  405dd6:	2408      	movcs	r4, #8
  405dd8:	2404      	movcc	r4, #4
	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  405dda:	1dce      	adds	r6, r1, #7
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
  405ddc:	2300      	movs	r3, #0
	bytes -= heap_footer_bytes(bytes);
  405dde:	1b14      	subs	r4, r2, r4
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  405de0:	f026 0607 	bic.w	r6, r6, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  405de4:	440c      	add	r4, r1
	heap->heap = h;
  405de6:	6006      	str	r6, [r0, #0]
  405de8:	f106 0210 	add.w	r2, r6, #16
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  405dec:	f024 0407 	bic.w	r4, r4, #7
	h->avail_buckets = 0;
  405df0:	60f3      	str	r3, [r6, #12]
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  405df2:	1ba4      	subs	r4, r4, r6
  405df4:	08e4      	lsrs	r4, r4, #3
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
  405df6:	4621      	mov	r1, r4
  405df8:	4620      	mov	r0, r4
	h->end_chunk = heap_sz;
  405dfa:	60b4      	str	r4, [r6, #8]
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
  405dfc:	f7ff ff95 	bl	405d2a <bucket_idx.isra.0>
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
  405e00:	4619      	mov	r1, r3
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
  405e02:	0085      	lsls	r5, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  405e04:	351b      	adds	r5, #27
  405e06:	08ed      	lsrs	r5, r5, #3
	for (int i = 0; i < nb_buckets; i++) {
  405e08:	4298      	cmp	r0, r3
  405e0a:	da2e      	bge.n	405e6a <sys_heap_init+0x9c>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
  405e0c:	462a      	mov	r2, r5
  405e0e:	4630      	mov	r0, r6
  405e10:	2100      	movs	r1, #0
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  405e12:	1b67      	subs	r7, r4, r5
	set_chunk_size(h, 0, chunk0_size);
  405e14:	f7ff ff85 	bl	405d22 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
  405e18:	2300      	movs	r3, #0
  405e1a:	4630      	mov	r0, r6
  405e1c:	461a      	mov	r2, r3
  405e1e:	4619      	mov	r1, r3
  405e20:	f7ff ff56 	bl	405cd0 <chunk_set>
	set_chunk_used(h, 0, true);
  405e24:	4619      	mov	r1, r3
  405e26:	4630      	mov	r0, r6
  405e28:	2201      	movs	r2, #1
  405e2a:	f7ff ff62 	bl	405cf2 <set_chunk_used>
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  405e2e:	463a      	mov	r2, r7
  405e30:	4629      	mov	r1, r5
  405e32:	f7ff ff76 	bl	405d22 <set_chunk_size>
  405e36:	462b      	mov	r3, r5
  405e38:	2200      	movs	r2, #0
  405e3a:	4629      	mov	r1, r5
  405e3c:	4630      	mov	r0, r6
  405e3e:	f7ff ff47 	bl	405cd0 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
  405e42:	4621      	mov	r1, r4
  405e44:	4630      	mov	r0, r6
  405e46:	f7ff ff6c 	bl	405d22 <set_chunk_size>
  405e4a:	463b      	mov	r3, r7
  405e4c:	4621      	mov	r1, r4
  405e4e:	4630      	mov	r0, r6
  405e50:	2200      	movs	r2, #0
  405e52:	f7ff ff3d 	bl	405cd0 <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
  405e56:	4621      	mov	r1, r4
  405e58:	4630      	mov	r0, r6
  405e5a:	2201      	movs	r2, #1
  405e5c:	f7ff ff49 	bl	405cf2 <set_chunk_used>

	free_list_add(h, chunk0_size);
  405e60:	4629      	mov	r1, r5
}
  405e62:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, chunk0_size);
  405e66:	f7ff bf6f 	b.w	405d48 <free_list_add>
	for (int i = 0; i < nb_buckets; i++) {
  405e6a:	3301      	adds	r3, #1
		h->buckets[i].next = 0;
  405e6c:	f842 1b04 	str.w	r1, [r2], #4
	for (int i = 0; i < nb_buckets; i++) {
  405e70:	e7ca      	b.n	405e08 <sys_heap_init+0x3a>

00405e72 <encode_uint>:
{
  405e72:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405e76:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
  405e78:	78d3      	ldrb	r3, [r2, #3]
{
  405e7a:	4680      	mov	r8, r0
  405e7c:	460f      	mov	r7, r1
	switch (specifier) {
  405e7e:	2b6f      	cmp	r3, #111	; 0x6f
{
  405e80:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  405e82:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
  405e86:	d029      	beq.n	405edc <encode_uint+0x6a>
  405e88:	d824      	bhi.n	405ed4 <encode_uint+0x62>
		return 16;
  405e8a:	2b58      	cmp	r3, #88	; 0x58
  405e8c:	bf14      	ite	ne
  405e8e:	260a      	movne	r6, #10
  405e90:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
  405e92:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
  405e96:	4632      	mov	r2, r6
  405e98:	2300      	movs	r3, #0
  405e9a:	4640      	mov	r0, r8
  405e9c:	4639      	mov	r1, r7
  405e9e:	f7fb f821 	bl	400ee4 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  405ea2:	2a09      	cmp	r2, #9
  405ea4:	b2d4      	uxtb	r4, r2
  405ea6:	d81e      	bhi.n	405ee6 <encode_uint+0x74>
  405ea8:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
  405eaa:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
  405eac:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
  405eae:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
  405eb2:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
  405eb6:	d301      	bcc.n	405ebc <encode_uint+0x4a>
  405eb8:	45d1      	cmp	r9, sl
  405eba:	d811      	bhi.n	405ee0 <encode_uint+0x6e>
	if (conv->flag_hash) {
  405ebc:	782b      	ldrb	r3, [r5, #0]
  405ebe:	069b      	lsls	r3, r3, #26
  405ec0:	d505      	bpl.n	405ece <encode_uint+0x5c>
		if (radix == 8) {
  405ec2:	2e08      	cmp	r6, #8
  405ec4:	d115      	bne.n	405ef2 <encode_uint+0x80>
			conv->altform_0 = true;
  405ec6:	78ab      	ldrb	r3, [r5, #2]
  405ec8:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
  405ecc:	70ab      	strb	r3, [r5, #2]
}
  405ece:	4648      	mov	r0, r9
  405ed0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
  405ed4:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
  405ed8:	2b70      	cmp	r3, #112	; 0x70
  405eda:	e7d7      	b.n	405e8c <encode_uint+0x1a>
	switch (specifier) {
  405edc:	2608      	movs	r6, #8
  405ede:	e7d8      	b.n	405e92 <encode_uint+0x20>
		value /= radix;
  405ee0:	4680      	mov	r8, r0
  405ee2:	460f      	mov	r7, r1
  405ee4:	e7d7      	b.n	405e96 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  405ee6:	f1bb 0f19 	cmp.w	fp, #25
  405eea:	bf94      	ite	ls
  405eec:	3437      	addls	r4, #55	; 0x37
  405eee:	3457      	addhi	r4, #87	; 0x57
  405ef0:	e7db      	b.n	405eaa <encode_uint+0x38>
		} else if (radix == 16) {
  405ef2:	2e10      	cmp	r6, #16
  405ef4:	d1eb      	bne.n	405ece <encode_uint+0x5c>
			conv->altform_0c = true;
  405ef6:	78ab      	ldrb	r3, [r5, #2]
  405ef8:	f043 0310 	orr.w	r3, r3, #16
  405efc:	e7e6      	b.n	405ecc <encode_uint+0x5a>

00405efe <outs>:
{
  405efe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  405f02:	4607      	mov	r7, r0
  405f04:	4688      	mov	r8, r1
  405f06:	4615      	mov	r5, r2
  405f08:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  405f0a:	4614      	mov	r4, r2
  405f0c:	42b4      	cmp	r4, r6
  405f0e:	eba4 0005 	sub.w	r0, r4, r5
  405f12:	d302      	bcc.n	405f1a <outs+0x1c>
  405f14:	b93e      	cbnz	r6, 405f26 <outs+0x28>
  405f16:	7823      	ldrb	r3, [r4, #0]
  405f18:	b12b      	cbz	r3, 405f26 <outs+0x28>
		int rc = out((int)*sp++, ctx);
  405f1a:	4641      	mov	r1, r8
  405f1c:	f814 0b01 	ldrb.w	r0, [r4], #1
  405f20:	47b8      	blx	r7
		if (rc < 0) {
  405f22:	2800      	cmp	r0, #0
  405f24:	daf2      	bge.n	405f0c <outs+0xe>
}
  405f26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00405f2a <free_space>:
	err = k_sem_init(&buffer->sem, 0, 1);
	__ASSERT_NO_MSG(err == 0);
}

static inline bool free_space(struct mpsc_pbuf_buffer *buffer, uint32_t *res)
{
  405f2a:	4602      	mov	r2, r0
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
  405f2c:	68c0      	ldr	r0, [r0, #12]
{
  405f2e:	b510      	push	{r4, lr}
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
  405f30:	6814      	ldr	r4, [r2, #0]
  405f32:	42a0      	cmp	r0, r4
  405f34:	d904      	bls.n	405f40 <free_space+0x16>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
  405f36:	3801      	subs	r0, #1
  405f38:	1b00      	subs	r0, r0, r4
  405f3a:	6008      	str	r0, [r1, #0]

		return false;
  405f3c:	2000      	movs	r0, #0
	}

	*res = buffer->size - buffer->tmp_wr_idx;

	return true;
}
  405f3e:	bd10      	pop	{r4, pc}
		*res = buffer->size - buffer->tmp_wr_idx - 1;
  405f40:	6a13      	ldr	r3, [r2, #32]
	} else if (!buffer->rd_idx) {
  405f42:	b918      	cbnz	r0, 405f4c <free_space+0x22>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
  405f44:	3b01      	subs	r3, #1
  405f46:	1b1b      	subs	r3, r3, r4
  405f48:	600b      	str	r3, [r1, #0]
		return false;
  405f4a:	e7f8      	b.n	405f3e <free_space+0x14>
	*res = buffer->size - buffer->tmp_wr_idx;
  405f4c:	1b1b      	subs	r3, r3, r4
	return true;
  405f4e:	2001      	movs	r0, #1
	*res = buffer->size - buffer->tmp_wr_idx;
  405f50:	600b      	str	r3, [r1, #0]
	return true;
  405f52:	e7f4      	b.n	405f3e <free_space+0x14>

00405f54 <idx_inc>:
	return !item->hdr.valid && !item->hdr.busy;
}

static inline uint32_t idx_inc(struct mpsc_pbuf_buffer *buffer,
				uint32_t idx, uint32_t val)
{
  405f54:	b510      	push	{r4, lr}
  405f56:	4604      	mov	r4, r0
	uint32_t i = idx + val;
  405f58:	1888      	adds	r0, r1, r2

	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
  405f5a:	6922      	ldr	r2, [r4, #16]
		return i & (buffer->size - 1);
  405f5c:	6a23      	ldr	r3, [r4, #32]
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
  405f5e:	07d2      	lsls	r2, r2, #31
  405f60:	d502      	bpl.n	405f68 <idx_inc+0x14>
		return i & (buffer->size - 1);
  405f62:	3b01      	subs	r3, #1
  405f64:	4018      	ands	r0, r3
	}

	return (i >= buffer->size) ? i - buffer->size : i;
}
  405f66:	bd10      	pop	{r4, pc}
	return (i >= buffer->size) ? i - buffer->size : i;
  405f68:	4298      	cmp	r0, r3
  405f6a:	bf28      	it	cs
  405f6c:	1ac0      	subcs	r0, r0, r3
  405f6e:	e7fa      	b.n	405f66 <idx_inc+0x12>

00405f70 <add_skip_item>:

	return 0;
}

static void add_skip_item(struct mpsc_pbuf_buffer *buffer, uint32_t wlen)
{
  405f70:	b538      	push	{r3, r4, r5, lr}
	union mpsc_pbuf_generic skip = {
  405f72:	008b      	lsls	r3, r1, #2
		.skip = { .valid = 0, .busy = 1, .len = wlen }
	};

	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
  405f74:	69c2      	ldr	r2, [r0, #28]
{
  405f76:	460d      	mov	r5, r1
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
  405f78:	6801      	ldr	r1, [r0, #0]
	union mpsc_pbuf_generic skip = {
  405f7a:	f043 0302 	orr.w	r3, r3, #2
{
  405f7e:	4604      	mov	r4, r0
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
  405f80:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
  405f84:	462a      	mov	r2, r5
  405f86:	6801      	ldr	r1, [r0, #0]
  405f88:	f7ff ffe4 	bl	405f54 <idx_inc>
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
  405f8c:	6861      	ldr	r1, [r4, #4]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
  405f8e:	6020      	str	r0, [r4, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
  405f90:	462a      	mov	r2, r5
  405f92:	4620      	mov	r0, r4
  405f94:	f7ff ffde 	bl	405f54 <idx_inc>
  405f98:	6060      	str	r0, [r4, #4]
}
  405f9a:	bd38      	pop	{r3, r4, r5, pc}

00405f9c <drop_item_locked>:
 */
static union mpsc_pbuf_generic *drop_item_locked(struct mpsc_pbuf_buffer *buffer,
						 uint32_t free_wlen,
						 bool allow_drop,
						 bool *user_packet)
{
  405f9c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405fa0:	461f      	mov	r7, r3
	union mpsc_pbuf_generic *item;
	uint32_t rd_wlen;
	uint32_t skip_wlen;

	*user_packet = false;
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
  405fa2:	f8d0 a00c 	ldr.w	sl, [r0, #12]
	*user_packet = false;
  405fa6:	2300      	movs	r3, #0
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
  405fa8:	f8d0 901c 	ldr.w	r9, [r0, #28]
{
  405fac:	4604      	mov	r4, r0
  405fae:	468b      	mov	fp, r1
	*user_packet = false;
  405fb0:	703b      	strb	r3, [r7, #0]
{
  405fb2:	4690      	mov	r8, r2
	if (item->hdr.busy && !item->hdr.valid) {
  405fb4:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
  405fb8:	eb09 068a 	add.w	r6, r9, sl, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
  405fbc:	f003 0303 	and.w	r3, r3, #3
  405fc0:	2b02      	cmp	r3, #2
  405fc2:	d103      	bne.n	405fcc <drop_item_locked+0x30>
		return item->skip.len;
  405fc4:	f859 502a 	ldr.w	r5, [r9, sl, lsl #2]
	skip_wlen = get_skip(item);

	rd_wlen = skip_wlen ? skip_wlen : buffer->get_wlen(item);
  405fc8:	08ad      	lsrs	r5, r5, #2
  405fca:	d12e      	bne.n	40602a <drop_item_locked+0x8e>
  405fcc:	69a3      	ldr	r3, [r4, #24]
  405fce:	4630      	mov	r0, r6
  405fd0:	4798      	blx	r3
  405fd2:	4605      	mov	r5, r0
	if (skip_wlen) {
		allow_drop = true;
	} else if (allow_drop) {
  405fd4:	f1b8 0f00 	cmp.w	r8, #0
  405fd8:	d036      	beq.n	406048 <drop_item_locked+0xac>
		if (item->hdr.busy) {
  405fda:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
  405fde:	079b      	lsls	r3, r3, #30
  405fe0:	d52f      	bpl.n	406042 <drop_item_locked+0xa6>
			/* item is currently processed and cannot be overwritten. */
			add_skip_item(buffer, free_wlen + 1);
  405fe2:	f10b 0101 	add.w	r1, fp, #1
  405fe6:	4620      	mov	r0, r4
  405fe8:	f7ff ffc2 	bl	405f70 <add_skip_item>
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
  405fec:	6861      	ldr	r1, [r4, #4]
  405fee:	462a      	mov	r2, r5
  405ff0:	4620      	mov	r0, r4
  405ff2:	f7ff ffaf 	bl	405f54 <idx_inc>
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
  405ff6:	6821      	ldr	r1, [r4, #0]
  405ff8:	462a      	mov	r2, r5
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
  405ffa:	6060      	str	r0, [r4, #4]
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
  405ffc:	4620      	mov	r0, r4
  405ffe:	f7ff ffa9 	bl	405f54 <idx_inc>

			/* Get next itme followed the busy one. */
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
  406002:	462a      	mov	r2, r5
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
  406004:	6020      	str	r0, [r4, #0]
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
  406006:	4620      	mov	r0, r4
  406008:	68e1      	ldr	r1, [r4, #12]
  40600a:	f7ff ffa3 	bl	405f54 <idx_inc>

			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
  40600e:	69e3      	ldr	r3, [r4, #28]
	if (item->hdr.busy && !item->hdr.valid) {
  406010:	f813 2020 	ldrb.w	r2, [r3, r0, lsl #2]
			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
  406014:	eb03 0680 	add.w	r6, r3, r0, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
  406018:	f002 0203 	and.w	r2, r2, #3
  40601c:	2a02      	cmp	r2, #2
  40601e:	d10c      	bne.n	40603a <drop_item_locked+0x9e>
		return item->skip.len;
  406020:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			skip_wlen = get_skip(item);
			if (skip_wlen) {
  406024:	089b      	lsrs	r3, r3, #2
  406026:	d008      	beq.n	40603a <drop_item_locked+0x9e>
				rd_wlen += skip_wlen;
  406028:	441d      	add	r5, r3
	} else {
		item = NULL;
	}

	if (allow_drop) {
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
  40602a:	68e1      	ldr	r1, [r4, #12]
  40602c:	462a      	mov	r2, r5
  40602e:	4620      	mov	r0, r4
  406030:	f7ff ff90 	bl	405f54 <idx_inc>
		buffer->tmp_rd_idx = buffer->rd_idx;
  406034:	e9c4 0002 	strd	r0, r0, [r4, #8]
  406038:	e007      	b.n	40604a <drop_item_locked+0xae>
				rd_wlen += buffer->get_wlen(item);
  40603a:	69a3      	ldr	r3, [r4, #24]
  40603c:	4630      	mov	r0, r6
  40603e:	4798      	blx	r3
  406040:	4405      	add	r5, r0
			*user_packet = true;
  406042:	2301      	movs	r3, #1
  406044:	703b      	strb	r3, [r7, #0]
  406046:	e7f0      	b.n	40602a <drop_item_locked+0x8e>
		item = NULL;
  406048:	4646      	mov	r6, r8
	}

	return item;
}
  40604a:	4630      	mov	r0, r6
  40604c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00406050 <mpsc_pbuf_init>:
{
  406050:	b538      	push	{r3, r4, r5, lr}
  406052:	460d      	mov	r5, r1
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
  406054:	221c      	movs	r2, #28
  406056:	2100      	movs	r1, #0
{
  406058:	4604      	mov	r4, r0
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
  40605a:	f000 fa8b 	bl	406574 <memset>
	buffer->get_wlen = cfg->get_wlen;
  40605e:	68eb      	ldr	r3, [r5, #12]
	buffer->size = cfg->size;
  406060:	686a      	ldr	r2, [r5, #4]
	buffer->get_wlen = cfg->get_wlen;
  406062:	61a3      	str	r3, [r4, #24]
	buffer->notify_drop = cfg->notify_drop;
  406064:	68ab      	ldr	r3, [r5, #8]
  406066:	6163      	str	r3, [r4, #20]
	buffer->buf = cfg->buf;
  406068:	682b      	ldr	r3, [r5, #0]
	buffer->size = cfg->size;
  40606a:	6222      	str	r2, [r4, #32]
	buffer->buf = cfg->buf;
  40606c:	61e3      	str	r3, [r4, #28]
	buffer->flags = cfg->flags;
  40606e:	692b      	ldr	r3, [r5, #16]
 * @param x value to check
 * @return true if @p x is a power of two, false otherwise
 */
static inline bool is_power_of_two(unsigned int x)
{
	return (x != 0U) && ((x & (x - 1U)) == 0U);
  406070:	b122      	cbz	r2, 40607c <mpsc_pbuf_init+0x2c>
  406072:	1e51      	subs	r1, r2, #1
  406074:	4211      	tst	r1, r2
		buffer->flags |= MPSC_PBUF_SIZE_POW2;
  406076:	bf08      	it	eq
  406078:	f043 0301 	orreq.w	r3, r3, #1
	buffer->flags = cfg->flags;
  40607c:	6123      	str	r3, [r4, #16]
	return z_impl_k_sem_init(sem, initial_count, limit);
  40607e:	2201      	movs	r2, #1
  406080:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406084:	2100      	movs	r1, #0
}
  406086:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40608a:	f000 bdba 	b.w	406c02 <z_impl_k_sem_init>

0040608e <mpsc_pbuf_alloc>:

}

union mpsc_pbuf_generic *mpsc_pbuf_alloc(struct mpsc_pbuf_buffer *buffer,
					 size_t wlen, k_timeout_t timeout)
{
  40608e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406092:	4699      	mov	r9, r3
	uint32_t free_wlen;
	bool valid_drop;

	MPSC_PBUF_DBG(buffer, "alloc %d words, ", (int)wlen);

	if (wlen > (buffer->size - 1)) {
  406094:	6a03      	ldr	r3, [r0, #32]
{
  406096:	b085      	sub	sp, #20
  406098:	4604      	mov	r4, r0
	if (wlen > (buffer->size - 1)) {
  40609a:	3b01      	subs	r3, #1
{
  40609c:	460f      	mov	r7, r1
  40609e:	4690      	mov	r8, r2
	if (wlen > (buffer->size - 1)) {
  4060a0:	428b      	cmp	r3, r1
  4060a2:	d364      	bcc.n	40616e <mpsc_pbuf_alloc+0xe0>
	union mpsc_pbuf_generic *dropped_item = NULL;
  4060a4:	2500      	movs	r5, #0
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
			   !k_is_in_isr()) {
			int err;

			k_spin_unlock(&buffer->lock, key);
			err = k_sem_take(&buffer->sem, timeout);
  4060a6:	f100 0b24 	add.w	fp, r0, #36	; 0x24
	union mpsc_pbuf_generic *item = NULL;
  4060aa:	46aa      	mov	sl, r5
	__asm__ volatile(
  4060ac:	f04f 0320 	mov.w	r3, #32
  4060b0:	f3ef 8611 	mrs	r6, BASEPRI
  4060b4:	f383 8812 	msr	BASEPRI_MAX, r3
  4060b8:	f3bf 8f6f 	isb	sy
		wrap = free_space(buffer, &free_wlen);
  4060bc:	a903      	add	r1, sp, #12
  4060be:	4620      	mov	r0, r4
  4060c0:	f7ff ff33 	bl	405f2a <free_space>
		if (free_wlen >= wlen) {
  4060c4:	9903      	ldr	r1, [sp, #12]
  4060c6:	42b9      	cmp	r1, r7
  4060c8:	d321      	bcc.n	40610e <mpsc_pbuf_alloc+0x80>
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
  4060ca:	6821      	ldr	r1, [r4, #0]
			buffer->tmp_wr_idx = idx_inc(buffer,
  4060cc:	4620      	mov	r0, r4
			item =
  4060ce:	69e3      	ldr	r3, [r4, #28]
			item->hdr.valid = 0;
  4060d0:	f813 2021 	ldrb.w	r2, [r3, r1, lsl #2]
			item =
  4060d4:	eb03 0a81 	add.w	sl, r3, r1, lsl #2
			item->hdr.valid = 0;
  4060d8:	f022 0203 	bic.w	r2, r2, #3
  4060dc:	f803 2021 	strb.w	r2, [r3, r1, lsl #2]
			buffer->tmp_wr_idx = idx_inc(buffer,
  4060e0:	463a      	mov	r2, r7
  4060e2:	f7ff ff37 	bl	405f54 <idx_inc>
		cont = false;
  4060e6:	2300      	movs	r3, #0
			buffer->tmp_wr_idx = idx_inc(buffer,
  4060e8:	6020      	str	r0, [r4, #0]
	__asm__ volatile(
  4060ea:	f386 8811 	msr	BASEPRI, r6
  4060ee:	f3bf 8f6f 	isb	sy
			cont = dropped_item != NULL;
		}

		k_spin_unlock(&buffer->lock, key);

		if (cont && dropped_item && valid_drop) {
  4060f2:	2b00      	cmp	r3, #0
  4060f4:	d03d      	beq.n	406172 <mpsc_pbuf_alloc+0xe4>
  4060f6:	2d00      	cmp	r5, #0
  4060f8:	d0d8      	beq.n	4060ac <mpsc_pbuf_alloc+0x1e>
  4060fa:	f89d 300b 	ldrb.w	r3, [sp, #11]
  4060fe:	2b00      	cmp	r3, #0
  406100:	d0d4      	beq.n	4060ac <mpsc_pbuf_alloc+0x1e>
			/* Notify about item being dropped. */
			buffer->notify_drop(buffer, dropped_item);
  406102:	4629      	mov	r1, r5
  406104:	6963      	ldr	r3, [r4, #20]
  406106:	4620      	mov	r0, r4
			dropped_item = NULL;
  406108:	2500      	movs	r5, #0
			buffer->notify_drop(buffer, dropped_item);
  40610a:	4798      	blx	r3
			dropped_item = NULL;
  40610c:	e7ce      	b.n	4060ac <mpsc_pbuf_alloc+0x1e>
		} else if (wrap) {
  40610e:	b128      	cbz	r0, 40611c <mpsc_pbuf_alloc+0x8e>
  406110:	9001      	str	r0, [sp, #4]
			add_skip_item(buffer, free_wlen);
  406112:	4620      	mov	r0, r4
  406114:	f7ff ff2c 	bl	405f70 <add_skip_item>
			cont = true;
  406118:	9b01      	ldr	r3, [sp, #4]
  40611a:	e7e6      	b.n	4060ea <mpsc_pbuf_alloc+0x5c>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  40611c:	ea58 0309 	orrs.w	r3, r8, r9
  406120:	d017      	beq.n	406152 <mpsc_pbuf_alloc+0xc4>
			   !k_is_in_isr()) {
  406122:	f000 fd46 	bl	406bb2 <k_is_in_isr>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  406126:	b9a0      	cbnz	r0, 406152 <mpsc_pbuf_alloc+0xc4>
  406128:	f386 8811 	msr	BASEPRI, r6
  40612c:	f3bf 8f6f 	isb	sy
	return z_impl_k_sem_take(sem, timeout);
  406130:	4642      	mov	r2, r8
  406132:	464b      	mov	r3, r9
  406134:	4658      	mov	r0, fp
  406136:	f7fe fef3 	bl	404f20 <z_impl_k_sem_take>
	__asm__ volatile(
  40613a:	f04f 0320 	mov.w	r3, #32
  40613e:	f3ef 8611 	mrs	r6, BASEPRI
  406142:	f383 8812 	msr	BASEPRI_MAX, r3
  406146:	f3bf 8f6f 	isb	sy
			if (err == 0) {
  40614a:	fab0 f380 	clz	r3, r0
  40614e:	095b      	lsrs	r3, r3, #5
  406150:	e7cb      	b.n	4060ea <mpsc_pbuf_alloc+0x5c>
			bool user_drop = buffer->flags & MPSC_PBUF_MODE_OVERWRITE;
  406152:	6922      	ldr	r2, [r4, #16]
			dropped_item = drop_item_locked(buffer, free_wlen,
  406154:	f10d 030b 	add.w	r3, sp, #11
  406158:	9903      	ldr	r1, [sp, #12]
  40615a:	4620      	mov	r0, r4
  40615c:	f3c2 0240 	ubfx	r2, r2, #1, #1
  406160:	f7ff ff1c 	bl	405f9c <drop_item_locked>
			cont = dropped_item != NULL;
  406164:	1e03      	subs	r3, r0, #0
  406166:	4605      	mov	r5, r0
  406168:	bf18      	it	ne
  40616a:	2301      	movne	r3, #1
  40616c:	e7bd      	b.n	4060ea <mpsc_pbuf_alloc+0x5c>
		return NULL;
  40616e:	f04f 0a00 	mov.w	sl, #0
		/* During test fill with 0's to simplify message comparison */
		memset(item, 0, sizeof(int) * wlen);
	}

	return item;
}
  406172:	4650      	mov	r0, sl
  406174:	b005      	add	sp, #20
  406176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0040617a <mpsc_pbuf_commit>:

void mpsc_pbuf_commit(struct mpsc_pbuf_buffer *buffer,
		       union mpsc_pbuf_generic *item)
{
  40617a:	b570      	push	{r4, r5, r6, lr}
	uint32_t wlen = buffer->get_wlen(item);
  40617c:	6983      	ldr	r3, [r0, #24]
{
  40617e:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
  406180:	4608      	mov	r0, r1
{
  406182:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
  406184:	4798      	blx	r3
  406186:	4602      	mov	r2, r0
  406188:	f04f 0320 	mov.w	r3, #32
  40618c:	f3ef 8611 	mrs	r6, BASEPRI
  406190:	f383 8812 	msr	BASEPRI_MAX, r3
  406194:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&buffer->lock);

	item->hdr.valid = 1;
  406198:	782b      	ldrb	r3, [r5, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
  40619a:	4620      	mov	r0, r4
	item->hdr.valid = 1;
  40619c:	f043 0301 	orr.w	r3, r3, #1
  4061a0:	702b      	strb	r3, [r5, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
  4061a2:	6861      	ldr	r1, [r4, #4]
  4061a4:	f7ff fed6 	bl	405f54 <idx_inc>
  4061a8:	6060      	str	r0, [r4, #4]
	__asm__ volatile(
  4061aa:	f386 8811 	msr	BASEPRI, r6
  4061ae:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&buffer->lock, key);
	MPSC_PBUF_DBG(buffer, "committed %p ", item);
}
  4061b2:	bd70      	pop	{r4, r5, r6, pc}

004061b4 <mpsc_pbuf_claim>:
		}
	} while (cont);
}

const union mpsc_pbuf_generic *mpsc_pbuf_claim(struct mpsc_pbuf_buffer *buffer)
{
  4061b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4061b8:	4604      	mov	r4, r0
	__asm__ volatile(
  4061ba:	f04f 0320 	mov.w	r3, #32
  4061be:	f3ef 8611 	mrs	r6, BASEPRI
  4061c2:	f383 8812 	msr	BASEPRI_MAX, r3
  4061c6:	f3bf 8f6f 	isb	sy
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
  4061ca:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
  4061ce:	429f      	cmp	r7, r3
	*res = buffer->size - buffer->tmp_rd_idx;
  4061d0:	bf88      	it	hi
  4061d2:	6a23      	ldrhi	r3, [r4, #32]
  4061d4:	1bdb      	subs	r3, r3, r7
		key = k_spin_lock(&buffer->lock);
		wrap = available(buffer, &a);
		item = (union mpsc_pbuf_generic *)
			&buffer->buf[buffer->tmp_rd_idx];

		if (!a || is_invalid(item)) {
  4061d6:	b1f3      	cbz	r3, 406216 <mpsc_pbuf_claim+0x62>
		item = (union mpsc_pbuf_generic *)
  4061d8:	69e1      	ldr	r1, [r4, #28]
	return !item->hdr.valid && !item->hdr.busy;
  4061da:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
		item = (union mpsc_pbuf_generic *)
  4061de:	eb01 0887 	add.w	r8, r1, r7, lsl #2
		if (!a || is_invalid(item)) {
  4061e2:	f012 0303 	ands.w	r3, r2, #3
  4061e6:	d016      	beq.n	406216 <mpsc_pbuf_claim+0x62>
	if (item->hdr.busy && !item->hdr.valid) {
  4061e8:	2b02      	cmp	r3, #2
  4061ea:	d103      	bne.n	4061f4 <mpsc_pbuf_claim+0x40>
		return item->skip.len;
  4061ec:	f851 5027 	ldr.w	r5, [r1, r7, lsl #2]
			item = NULL;
		} else {
			uint32_t skip = get_skip(item);

			if (skip || !is_valid(item)) {
  4061f0:	08ad      	lsrs	r5, r5, #2
  4061f2:	d115      	bne.n	406220 <mpsc_pbuf_claim+0x6c>
  4061f4:	07d0      	lsls	r0, r2, #31
				cont = true;
			} else {
				item->hdr.busy = 1;
				buffer->tmp_rd_idx =
					idx_inc(buffer, buffer->tmp_rd_idx,
						buffer->get_wlen(item));
  4061f6:	69a3      	ldr	r3, [r4, #24]
			if (skip || !is_valid(item)) {
  4061f8:	d50f      	bpl.n	40621a <mpsc_pbuf_claim+0x66>
				item->hdr.busy = 1;
  4061fa:	f042 0202 	orr.w	r2, r2, #2
					idx_inc(buffer, buffer->tmp_rd_idx,
  4061fe:	4640      	mov	r0, r8
				item->hdr.busy = 1;
  406200:	f801 2027 	strb.w	r2, [r1, r7, lsl #2]
					idx_inc(buffer, buffer->tmp_rd_idx,
  406204:	4798      	blx	r3
  406206:	4639      	mov	r1, r7
  406208:	4602      	mov	r2, r0
  40620a:	4620      	mov	r0, r4
  40620c:	f7ff fea2 	bl	405f54 <idx_inc>
		cont = false;
  406210:	2300      	movs	r3, #0
				buffer->tmp_rd_idx =
  406212:	60a0      	str	r0, [r4, #8]
  406214:	e011      	b.n	40623a <mpsc_pbuf_claim+0x86>
			item = NULL;
  406216:	4698      	mov	r8, r3
  406218:	e00f      	b.n	40623a <mpsc_pbuf_claim+0x86>
					skip ? skip : buffer->get_wlen(item);
  40621a:	4640      	mov	r0, r8
  40621c:	4798      	blx	r3
  40621e:	4605      	mov	r5, r0
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
  406220:	68a1      	ldr	r1, [r4, #8]
  406222:	462a      	mov	r2, r5
  406224:	4620      	mov	r0, r4
  406226:	f7ff fe95 	bl	405f54 <idx_inc>
					idx_inc(buffer, buffer->rd_idx, inc);
  40622a:	68e1      	ldr	r1, [r4, #12]
				buffer->tmp_rd_idx =
  40622c:	60a0      	str	r0, [r4, #8]
					idx_inc(buffer, buffer->rd_idx, inc);
  40622e:	462a      	mov	r2, r5
  406230:	4620      	mov	r0, r4
  406232:	f7ff fe8f 	bl	405f54 <idx_inc>
				cont = true;
  406236:	2301      	movs	r3, #1
				buffer->rd_idx =
  406238:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
  40623a:	f386 8811 	msr	BASEPRI, r6
  40623e:	f3bf 8f6f 	isb	sy

		if (!cont) {
			MPSC_PBUF_DBG(buffer, "claimed: %p ", item);
		}
		k_spin_unlock(&buffer->lock, key);
	} while (cont);
  406242:	2b00      	cmp	r3, #0
  406244:	d1b9      	bne.n	4061ba <mpsc_pbuf_claim+0x6>

	return item;
}
  406246:	4640      	mov	r0, r8
  406248:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0040624c <mpsc_pbuf_free>:

void mpsc_pbuf_free(struct mpsc_pbuf_buffer *buffer,
		     const union mpsc_pbuf_generic *item)
{
  40624c:	b570      	push	{r4, r5, r6, lr}
	uint32_t wlen = buffer->get_wlen(item);
  40624e:	6983      	ldr	r3, [r0, #24]
{
  406250:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
  406252:	4608      	mov	r0, r1
{
  406254:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
  406256:	4798      	blx	r3
  406258:	4602      	mov	r2, r0
	__asm__ volatile(
  40625a:	f04f 0320 	mov.w	r3, #32
  40625e:	f3ef 8611 	mrs	r6, BASEPRI
  406262:	f383 8812 	msr	BASEPRI_MAX, r3
  406266:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
	union mpsc_pbuf_generic *witem = (union mpsc_pbuf_generic *)item;

	witem->hdr.valid = 0;
  40626a:	782b      	ldrb	r3, [r5, #0]
  40626c:	f36f 0300 	bfc	r3, #0, #1
  406270:	702b      	strb	r3, [r5, #0]
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
  406272:	6923      	ldr	r3, [r4, #16]
  406274:	079b      	lsls	r3, r3, #30
  406276:	d505      	bpl.n	406284 <mpsc_pbuf_free+0x38>
		 ((uint32_t *)item == &buffer->buf[buffer->rd_idx])) {
  406278:	68e1      	ldr	r1, [r4, #12]
  40627a:	69e3      	ldr	r3, [r4, #28]
  40627c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
  406280:	429d      	cmp	r5, r3
  406282:	d112      	bne.n	4062aa <mpsc_pbuf_free+0x5e>
		witem->hdr.busy = 0;
  406284:	782b      	ldrb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
  406286:	4620      	mov	r0, r4
		witem->hdr.busy = 0;
  406288:	f36f 0341 	bfc	r3, #1, #1
  40628c:	702b      	strb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
  40628e:	68e1      	ldr	r1, [r4, #12]
  406290:	f7ff fe60 	bl	405f54 <idx_inc>
  406294:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
  406296:	f386 8811 	msr	BASEPRI, r6
  40629a:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
  40629e:	f104 0024 	add.w	r0, r4, #36	; 0x24
	}
	MPSC_PBUF_DBG(buffer, "freed: %p ", item);

	k_spin_unlock(&buffer->lock, key);
	k_sem_give(&buffer->sem);
}
  4062a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  4062a6:	f7fe be1b 	b.w	404ee0 <z_impl_k_sem_give>
		witem->skip.len = wlen;
  4062aa:	682b      	ldr	r3, [r5, #0]
  4062ac:	f360 039f 	bfi	r3, r0, #2, #30
  4062b0:	602b      	str	r3, [r5, #0]
  4062b2:	e7f0      	b.n	406296 <mpsc_pbuf_free+0x4a>

004062b4 <mpsc_pbuf_is_pending>:
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
  4062b4:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
  4062b8:	4293      	cmp	r3, r2
	*res = buffer->size - buffer->tmp_rd_idx;
  4062ba:	bf8a      	itet	hi
  4062bc:	6a00      	ldrhi	r0, [r0, #32]
		*res = (buffer->wr_idx - buffer->tmp_rd_idx);
  4062be:	1ad3      	subls	r3, r2, r3
	*res = buffer->size - buffer->tmp_rd_idx;
  4062c0:	1ac3      	subhi	r3, r0, r3
	uint32_t a;

	(void)available(buffer, &a);

	return a ? true : false;
}
  4062c2:	1e18      	subs	r0, r3, #0
  4062c4:	bf18      	it	ne
  4062c6:	2001      	movne	r0, #1
  4062c8:	4770      	bx	lr

004062ca <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  4062ca:	4770      	bx	lr

004062cc <soc_gpio_configure>:
	/* Enable control of the I/O line by the PIO_ODSR register */
	pio->PIO_OWER = mask;
}

void soc_gpio_configure(const struct soc_gpio_pin *pin)
{
  4062cc:	4603      	mov	r3, r0
  4062ce:	b570      	push	{r4, r5, r6, lr}
	uint32_t mask = pin->mask;
	Pio *pio = pin->regs;
	uint8_t periph_id = pin->periph_id;
	uint32_t flags = pin->flags;
  4062d0:	68de      	ldr	r6, [r3, #12]
	Pio *pio = pin->regs;
  4062d2:	e9d0 5400 	ldrd	r5, r4, [r0]
	if (flags & SOC_GPIO_PULLUP) {
  4062d6:	07f1      	lsls	r1, r6, #31
	uint8_t periph_id = pin->periph_id;
  4062d8:	7a00      	ldrb	r0, [r0, #8]
	uint32_t type = pin->flags & SOC_GPIO_FUNC_MASK;
  4062da:	f406 2370 	and.w	r3, r6, #983040	; 0xf0000
	pio->PIO_IDR = mask;
  4062de:	6465      	str	r5, [r4, #68]	; 0x44
	if (flags & SOC_GPIO_PULLUP) {
  4062e0:	d513      	bpl.n	40630a <soc_gpio_configure+0x3e>
		pio->PIO_PUER = mask;
  4062e2:	6665      	str	r5, [r4, #100]	; 0x64
	if (flags & SOC_GPIO_PULLDOWN) {
  4062e4:	07b2      	lsls	r2, r6, #30
  4062e6:	d512      	bpl.n	40630e <soc_gpio_configure+0x42>
		pio->PIO_PPDER = mask;
  4062e8:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
	if (flags & SOC_GPIO_OPENDRAIN) {
  4062ec:	0771      	lsls	r1, r6, #29
  4062ee:	d511      	bpl.n	406314 <soc_gpio_configure+0x48>
		pio->PIO_MDER = mask;
  4062f0:	6525      	str	r5, [r4, #80]	; 0x50

	/* Configure pin attributes common to all functions */
	configure_common_attr(pio, mask, flags);

	switch (type) {
  4062f2:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
  4062f6:	d042      	beq.n	40637e <soc_gpio_configure+0xb2>
  4062f8:	d80e      	bhi.n	406318 <soc_gpio_configure+0x4c>
  4062fa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  4062fe:	d034      	beq.n	40636a <soc_gpio_configure+0x9e>
  406300:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  406304:	d034      	beq.n	406370 <soc_gpio_configure+0xa4>
  406306:	b333      	cbz	r3, 406356 <soc_gpio_configure+0x8a>

	default:
		__ASSERT(0, "Unsupported pin function, check pin.flags value");
		return;
	}
}
  406308:	bd70      	pop	{r4, r5, r6, pc}
		pio->PIO_PUDR = mask;
  40630a:	6625      	str	r5, [r4, #96]	; 0x60
  40630c:	e7ea      	b.n	4062e4 <soc_gpio_configure+0x18>
		pio->PIO_PPDDR = mask;
  40630e:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
  406312:	e7eb      	b.n	4062ec <soc_gpio_configure+0x20>
		pio->PIO_MDDR = mask;
  406314:	6565      	str	r5, [r4, #84]	; 0x54
  406316:	e7ec      	b.n	4062f2 <soc_gpio_configure+0x26>
	switch (type) {
  406318:	f5b3 2f10 	cmp.w	r3, #589824	; 0x90000
  40631c:	d04d      	beq.n	4063ba <soc_gpio_configure+0xee>
  40631e:	f5b3 2f20 	cmp.w	r3, #655360	; 0xa0000
  406322:	d045      	beq.n	4063b0 <soc_gpio_configure+0xe4>
  406324:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
  406328:	d1ee      	bne.n	406308 <soc_gpio_configure+0x3c>
		soc_pmc_peripheral_enable(periph_id);
  40632a:	f7fb ff09 	bl	402140 <soc_pmc_peripheral_enable>
	if ((flags & SOC_GPIO_IN_FILTER_MASK) != 0U) {
  40632e:	f016 0318 	ands.w	r3, r6, #24
  406332:	d02a      	beq.n	40638a <soc_gpio_configure+0xbe>
		if ((flags & SOC_GPIO_IN_FILTER_MASK) == SOC_GPIO_IN_FILTER_DEBOUNCE) {
  406334:	2b08      	cmp	r3, #8
  406336:	d125      	bne.n	406384 <soc_gpio_configure+0xb8>
			pio->PIO_IFSCER = mask;
  406338:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
		pio->PIO_IFER = mask;
  40633c:	6225      	str	r5, [r4, #32]
	if (flags & SOC_GPIO_INT_ENABLE) {
  40633e:	06b2      	lsls	r2, r6, #26
  406340:	d506      	bpl.n	406350 <soc_gpio_configure+0x84>
		if ((flags & SOC_GPIO_INT_TRIG_MASK) == SOC_GPIO_INT_TRIG_DOUBLE_EDGE) {
  406342:	f006 03c0 	and.w	r3, r6, #192	; 0xc0
  406346:	2b80      	cmp	r3, #128	; 0x80
  406348:	d121      	bne.n	40638e <soc_gpio_configure+0xc2>
			pio->PIO_AIMDR = mask;
  40634a:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
		pio->PIO_IER = mask;
  40634e:	6425      	str	r5, [r4, #64]	; 0x40
		pio->PIO_ODR = mask;
  406350:	6165      	str	r5, [r4, #20]
		pio->PIO_PER = mask;
  406352:	6025      	str	r5, [r4, #0]
		break;
  406354:	e7d8      	b.n	406308 <soc_gpio_configure+0x3c>
		pio->PIO_ABCDSR[0] &= ~mask;
  406356:	6f23      	ldr	r3, [r4, #112]	; 0x70
  406358:	ea23 0305 	bic.w	r3, r3, r5
		pio->PIO_ABCDSR[0] |= mask;
  40635c:	6723      	str	r3, [r4, #112]	; 0x70
		pio->PIO_ABCDSR[1] &= ~mask;
  40635e:	6f63      	ldr	r3, [r4, #116]	; 0x74
  406360:	ea23 0305 	bic.w	r3, r3, r5
		pio->PIO_ABCDSR[1] |= mask;
  406364:	6763      	str	r3, [r4, #116]	; 0x74
		pio->PIO_PDR = mask;
  406366:	6065      	str	r5, [r4, #4]
		break;
  406368:	e7ce      	b.n	406308 <soc_gpio_configure+0x3c>
		pio->PIO_ABCDSR[0] |= mask;
  40636a:	6f23      	ldr	r3, [r4, #112]	; 0x70
  40636c:	432b      	orrs	r3, r5
  40636e:	e7f5      	b.n	40635c <soc_gpio_configure+0x90>
		pio->PIO_ABCDSR[0] &= ~mask;
  406370:	6f23      	ldr	r3, [r4, #112]	; 0x70
  406372:	ea23 0305 	bic.w	r3, r3, r5
		pio->PIO_ABCDSR[0] |= mask;
  406376:	6723      	str	r3, [r4, #112]	; 0x70
		pio->PIO_ABCDSR[1] |= mask;
  406378:	6f63      	ldr	r3, [r4, #116]	; 0x74
  40637a:	432b      	orrs	r3, r5
  40637c:	e7f2      	b.n	406364 <soc_gpio_configure+0x98>
		pio->PIO_ABCDSR[0] |= mask;
  40637e:	6f23      	ldr	r3, [r4, #112]	; 0x70
  406380:	432b      	orrs	r3, r5
  406382:	e7f8      	b.n	406376 <soc_gpio_configure+0xaa>
			pio->PIO_IFSCDR = mask;
  406384:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
  406388:	e7d8      	b.n	40633c <soc_gpio_configure+0x70>
		pio->PIO_IFDR = mask;
  40638a:	6265      	str	r5, [r4, #36]	; 0x24
  40638c:	e7d7      	b.n	40633e <soc_gpio_configure+0x72>
			if ((flags & SOC_GPIO_INT_TRIG_MASK) == SOC_GPIO_INT_TRIG_EDGE) {
  40638e:	2b40      	cmp	r3, #64	; 0x40
  406390:	d108      	bne.n	4063a4 <soc_gpio_configure+0xd8>
				pio->PIO_ESR = mask;
  406392:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
			if (flags & SOC_GPIO_INT_ACTIVE_HIGH) {
  406396:	05f3      	lsls	r3, r6, #23
  406398:	d507      	bpl.n	4063aa <soc_gpio_configure+0xde>
				pio->PIO_REHLSR = mask;
  40639a:	f8c4 50d4 	str.w	r5, [r4, #212]	; 0xd4
			pio->PIO_AIMER = mask;
  40639e:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
  4063a2:	e7d4      	b.n	40634e <soc_gpio_configure+0x82>
				pio->PIO_LSR = mask;
  4063a4:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
  4063a8:	e7f5      	b.n	406396 <soc_gpio_configure+0xca>
				pio->PIO_FELLSR = mask;
  4063aa:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
  4063ae:	e7f6      	b.n	40639e <soc_gpio_configure+0xd2>
			pio->PIO_SODR = mask;
  4063b0:	6325      	str	r5, [r4, #48]	; 0x30
	pio->PIO_OWER = mask;
  4063b2:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
		pio->PIO_OER = mask;
  4063b6:	6125      	str	r5, [r4, #16]
  4063b8:	e7cb      	b.n	406352 <soc_gpio_configure+0x86>
			pio->PIO_CODR = mask;
  4063ba:	6365      	str	r5, [r4, #52]	; 0x34
  4063bc:	e7f9      	b.n	4063b2 <soc_gpio_configure+0xe6>

004063be <soc_gpio_list_configure>:

void soc_gpio_list_configure(const struct soc_gpio_pin pins[],
			     unsigned int size)
{
  4063be:	b570      	push	{r4, r5, r6, lr}
  4063c0:	4606      	mov	r6, r0
  4063c2:	460d      	mov	r5, r1
	for (int i = 0; i < size; i++) {
  4063c4:	2400      	movs	r4, #0
  4063c6:	42ac      	cmp	r4, r5
  4063c8:	d100      	bne.n	4063cc <soc_gpio_list_configure+0xe>
		soc_gpio_configure(&pins[i]);
	}
}
  4063ca:	bd70      	pop	{r4, r5, r6, pc}
		soc_gpio_configure(&pins[i]);
  4063cc:	eb06 1004 	add.w	r0, r6, r4, lsl #4
	for (int i = 0; i < size; i++) {
  4063d0:	3401      	adds	r4, #1
		soc_gpio_configure(&pins[i]);
  4063d2:	f7ff ff7b 	bl	4062cc <soc_gpio_configure>
	for (int i = 0; i < size; i++) {
  4063d6:	e7f6      	b.n	4063c6 <soc_gpio_list_configure+0x8>

004063d8 <log_msg2_generic_get_wlen>:
	return msg->generic.type == Z_LOG_MSG2_LOG;
  4063d8:	7803      	ldrb	r3, [r0, #0]
	if (z_log_item_is_msg(generic_msg)) {
  4063da:	075b      	lsls	r3, r3, #29
  4063dc:	d40b      	bmi.n	4063f6 <log_msg2_generic_get_wlen+0x1e>
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
  4063de:	6803      	ldr	r3, [r0, #0]
  4063e0:	8840      	ldrh	r0, [r0, #2]
  4063e2:	f3c3 2349 	ubfx	r3, r3, #9, #10
  4063e6:	f3c0 00cb 	ubfx	r0, r0, #3, #12
  4063ea:	4418      	add	r0, r3
  4063ec:	3013      	adds	r0, #19
  4063ee:	f020 0007 	bic.w	r0, r0, #7
  4063f2:	0880      	lsrs	r0, r0, #2
		return log_msg2_get_total_wlen(msg->hdr.desc);
  4063f4:	4770      	bx	lr
	return 0;
  4063f6:	2000      	movs	r0, #0
}
  4063f8:	4770      	bx	lr

004063fa <default_lf_get_timestamp>:
{
  4063fa:	b508      	push	{r3, lr}
	return z_impl_k_uptime_ticks();
  4063fc:	f000 fd30 	bl	406e60 <z_impl_k_uptime_ticks>
  406400:	220a      	movs	r2, #10
  406402:	2300      	movs	r3, #0
  406404:	f7fa fd6e 	bl	400ee4 <__aeabi_uldivmod>
}
  406408:	bd08      	pop	{r3, pc}

0040640a <dummy_timestamp>:
  40640a:	2000      	movs	r0, #0
  40640c:	4770      	bx	lr

0040640e <notify_drop>:
	z_log_dropped(true);
  40640e:	2001      	movs	r0, #1
  406410:	f7fb bf1a 	b.w	402248 <z_log_dropped>

00406414 <get_msg>:
{
  406414:	b508      	push	{r3, lr}
		msg.msg2 = z_log_msg2_claim();
  406416:	f7fb ff8b 	bl	402330 <z_log_msg2_claim>
}
  40641a:	bd08      	pop	{r3, pc}

0040641c <z_log_get_tag>:
}
  40641c:	2000      	movs	r0, #0
  40641e:	4770      	bx	lr

00406420 <buffer_write>:
{
  406420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406422:	4606      	mov	r6, r0
  406424:	460d      	mov	r5, r1
  406426:	4614      	mov	r4, r2
  406428:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
  40642a:	4621      	mov	r1, r4
  40642c:	4628      	mov	r0, r5
  40642e:	463a      	mov	r2, r7
  406430:	47b0      	blx	r6
	} while (len != 0);
  406432:	1a24      	subs	r4, r4, r0
		buf += processed;
  406434:	4405      	add	r5, r0
	} while (len != 0);
  406436:	d1f8      	bne.n	40642a <buffer_write+0xa>
}
  406438:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0040643a <log_output_flush>:
		     output->control_block->offset,
  40643a:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
  40643c:	6881      	ldr	r1, [r0, #8]
{
  40643e:	b510      	push	{r4, lr}
  406440:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
  406442:	6800      	ldr	r0, [r0, #0]
  406444:	e9d2 2300 	ldrd	r2, r3, [r2]
  406448:	f7ff ffea 	bl	406420 <buffer_write>
	output->control_block->offset = 0;
  40644c:	6863      	ldr	r3, [r4, #4]
  40644e:	2200      	movs	r2, #0
  406450:	601a      	str	r2, [r3, #0]
}
  406452:	bd10      	pop	{r4, pc}

00406454 <out_func>:
{
  406454:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
  406456:	684b      	ldr	r3, [r1, #4]
{
  406458:	4605      	mov	r5, r0
  40645a:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
  40645c:	681a      	ldr	r2, [r3, #0]
  40645e:	68cb      	ldr	r3, [r1, #12]
  406460:	429a      	cmp	r2, r3
  406462:	d102      	bne.n	40646a <out_func+0x16>
		log_output_flush(out_ctx);
  406464:	4608      	mov	r0, r1
  406466:	f7ff ffe8 	bl	40643a <log_output_flush>
  40646a:	6863      	ldr	r3, [r4, #4]
  40646c:	f3bf 8f5b 	dmb	ish
  406470:	e853 2f00 	ldrex	r2, [r3]
  406474:	1c51      	adds	r1, r2, #1
  406476:	e843 1000 	strex	r0, r1, [r3]
  40647a:	2800      	cmp	r0, #0
  40647c:	d1f8      	bne.n	406470 <out_func+0x1c>
  40647e:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (uint8_t)c;
  406482:	68a3      	ldr	r3, [r4, #8]
}
  406484:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
  406486:	549d      	strb	r5, [r3, r2]
}
  406488:	bd38      	pop	{r3, r4, r5, pc}

0040648a <cr_out_func>:
{
  40648a:	b538      	push	{r3, r4, r5, lr}
  40648c:	4605      	mov	r5, r0
  40648e:	460c      	mov	r4, r1
	out_func(c, ctx);
  406490:	f7ff ffe0 	bl	406454 <out_func>
	if (c == '\n') {
  406494:	2d0a      	cmp	r5, #10
  406496:	d103      	bne.n	4064a0 <cr_out_func+0x16>
		out_func((int)'\r', ctx);
  406498:	4621      	mov	r1, r4
  40649a:	200d      	movs	r0, #13
  40649c:	f7ff ffda 	bl	406454 <out_func>
}
  4064a0:	2000      	movs	r0, #0
  4064a2:	bd38      	pop	{r3, r4, r5, pc}

004064a4 <z_log_msg2_finalize>:
{
  4064a4:	b570      	push	{r4, r5, r6, lr}
  4064a6:	460e      	mov	r6, r1
  4064a8:	4615      	mov	r5, r2
  4064aa:	4619      	mov	r1, r3
	if (!msg) {
  4064ac:	4604      	mov	r4, r0
  4064ae:	b918      	cbnz	r0, 4064b8 <z_log_msg2_finalize+0x14>
}
  4064b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_log_dropped(false);
  4064b4:	f7fb bec8 	b.w	402248 <z_log_dropped>
	if (data) {
  4064b8:	b143      	cbz	r3, 4064cc <z_log_msg2_finalize+0x28>
		uint8_t *d = msg->data + desc.package_len;
  4064ba:	f100 030c 	add.w	r3, r0, #12
  4064be:	f3c2 2049 	ubfx	r0, r2, #9, #10
		memcpy(d, data, desc.data_len);
  4064c2:	f3c2 42cb 	ubfx	r2, r2, #19, #12
  4064c6:	4418      	add	r0, r3
  4064c8:	f000 f849 	bl	40655e <memcpy>
	z_log_msg2_commit(msg);
  4064cc:	4620      	mov	r0, r4
	msg->hdr.source = source;
  4064ce:	e9c4 5600 	strd	r5, r6, [r4]
}
  4064d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_log_msg2_commit(msg);
  4064d6:	f7fb bfed 	b.w	4024b4 <z_log_msg2_commit>

004064da <z_impl_z_log_msg2_static_create>:
{
  4064da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
  4064de:	f3c1 2949 	ubfx	r9, r1, #9, #10
  4064e2:	f3c1 44cb 	ubfx	r4, r1, #19, #12
  4064e6:	4606      	mov	r6, r0
  4064e8:	460d      	mov	r5, r1
  4064ea:	444c      	add	r4, r9
  4064ec:	4690      	mov	r8, r2
  4064ee:	461f      	mov	r7, r3
  4064f0:	3413      	adds	r4, #19
  4064f2:	f024 0407 	bic.w	r4, r4, #7
	struct log_msg2 *msg = z_log_msg2_alloc(msg_wlen);
  4064f6:	08a0      	lsrs	r0, r4, #2
  4064f8:	f7fb ff12 	bl	402320 <z_log_msg2_alloc>
	if (msg) {
  4064fc:	4604      	mov	r4, r0
  4064fe:	b120      	cbz	r0, 40650a <z_impl_z_log_msg2_static_create+0x30>
		memcpy(msg->data, package, desc.package_len);
  406500:	464a      	mov	r2, r9
  406502:	4641      	mov	r1, r8
  406504:	300c      	adds	r0, #12
  406506:	f000 f82a 	bl	40655e <memcpy>
	z_log_msg2_finalize(msg, source, desc, data);
  40650a:	463b      	mov	r3, r7
  40650c:	462a      	mov	r2, r5
  40650e:	4631      	mov	r1, r6
  406510:	4620      	mov	r0, r4
}
  406512:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_log_msg2_finalize(msg, source, desc, data);
  406516:	f7ff bfc5 	b.w	4064a4 <z_log_msg2_finalize>

0040651a <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
  40651a:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
  40651c:	6800      	ldr	r0, [r0, #0]
  40651e:	f7fc ba91 	b.w	402a44 <z_arm_fatal_error>

00406522 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
  406522:	2100      	movs	r1, #0
  406524:	2001      	movs	r0, #1
  406526:	f7fc ba8d 	b.w	402a44 <z_arm_fatal_error>

0040652a <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
  40652a:	b508      	push	{r3, lr}
	handler();
  40652c:	f7fc fb16 	bl	402b5c <z_SysNmiOnReset>
	z_arm_int_exit();
}
  406530:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
  406534:	f7fc bbe4 	b.w	402d00 <z_arm_exc_exit>

00406538 <z_log_msg2_static_create.constprop.0>:
  406538:	2300      	movs	r3, #0
  40653a:	f7ff bfce 	b.w	4064da <z_impl_z_log_msg2_static_create>

0040653e <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
  40653e:	4603      	mov	r3, r0
	size_t n = 0;
  406540:	2000      	movs	r0, #0

	while (*s != '\0') {
  406542:	5c1a      	ldrb	r2, [r3, r0]
  406544:	b902      	cbnz	r2, 406548 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
  406546:	4770      	bx	lr
		n++;
  406548:	3001      	adds	r0, #1
  40654a:	e7fa      	b.n	406542 <strlen+0x4>

0040654c <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
  40654c:	4603      	mov	r3, r0
	size_t n = 0;
  40654e:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
  406550:	5c1a      	ldrb	r2, [r3, r0]
  406552:	b10a      	cbz	r2, 406558 <strnlen+0xc>
  406554:	4288      	cmp	r0, r1
  406556:	d100      	bne.n	40655a <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
  406558:	4770      	bx	lr
		n++;
  40655a:	3001      	adds	r0, #1
  40655c:	e7f8      	b.n	406550 <strnlen+0x4>

0040655e <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
  40655e:	1e43      	subs	r3, r0, #1
  406560:	440a      	add	r2, r1
{
  406562:	b510      	push	{r4, lr}
	while (n > 0) {
  406564:	4291      	cmp	r1, r2
  406566:	d100      	bne.n	40656a <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
  406568:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
  40656a:	f811 4b01 	ldrb.w	r4, [r1], #1
  40656e:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
  406572:	e7f7      	b.n	406564 <memcpy+0x6>

00406574 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
  406574:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
  406576:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
  406578:	4603      	mov	r3, r0
	while (n > 0) {
  40657a:	4293      	cmp	r3, r2
  40657c:	d100      	bne.n	406580 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
  40657e:	4770      	bx	lr
		*(d_byte++) = c_byte;
  406580:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
  406584:	e7f9      	b.n	40657a <memset+0x6>

00406586 <_stdout_hook_default>:
}
  406586:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  40658a:	4770      	bx	lr

0040658c <sam_e70_xplained_init>:
	soc_gpio_configure(&pwm_ext2_pin7);
	soc_gpio_configure(&pwm_ext2_pin8);
#endif

	return 0;
}
  40658c:	2000      	movs	r0, #0
  40658e:	4770      	bx	lr

00406590 <gpio_sam_port_get_raw>:
}

static int gpio_sam_port_get_raw(const struct device *dev, uint32_t *value)
{
	const struct gpio_sam_config * const cfg = dev->config;
	Pio * const pio = cfg->regs;
  406590:	6843      	ldr	r3, [r0, #4]

	*value = pio->PIO_PDSR;

	return 0;
}
  406592:	2000      	movs	r0, #0
	Pio * const pio = cfg->regs;
  406594:	685b      	ldr	r3, [r3, #4]
	*value = pio->PIO_PDSR;
  406596:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  406598:	600b      	str	r3, [r1, #0]
}
  40659a:	4770      	bx	lr

0040659c <gpio_sam_port_set_masked_raw>:
static int gpio_sam_port_set_masked_raw(const struct device *dev,
					uint32_t mask,
					uint32_t value)
{
	const struct gpio_sam_config * const cfg = dev->config;
	Pio * const pio = cfg->regs;
  40659c:	6843      	ldr	r3, [r0, #4]
  40659e:	685b      	ldr	r3, [r3, #4]

	pio->PIO_ODSR = (pio->PIO_ODSR & ~mask) | (mask & value);
  4065a0:	6b98      	ldr	r0, [r3, #56]	; 0x38
  4065a2:	4042      	eors	r2, r0
  4065a4:	400a      	ands	r2, r1
  4065a6:	4042      	eors	r2, r0

	return 0;
}
  4065a8:	2000      	movs	r0, #0
	pio->PIO_ODSR = (pio->PIO_ODSR & ~mask) | (mask & value);
  4065aa:	639a      	str	r2, [r3, #56]	; 0x38
}
  4065ac:	4770      	bx	lr

004065ae <gpio_sam_port_set_bits_raw>:

static int gpio_sam_port_set_bits_raw(const struct device *dev, uint32_t mask)
{
	const struct gpio_sam_config * const cfg = dev->config;
	Pio * const pio = cfg->regs;
  4065ae:	6843      	ldr	r3, [r0, #4]

	/* Set pins. */
	pio->PIO_SODR = mask;

	return 0;
}
  4065b0:	2000      	movs	r0, #0
	Pio * const pio = cfg->regs;
  4065b2:	685b      	ldr	r3, [r3, #4]
	pio->PIO_SODR = mask;
  4065b4:	6319      	str	r1, [r3, #48]	; 0x30
}
  4065b6:	4770      	bx	lr

004065b8 <gpio_sam_port_clear_bits_raw>:

static int gpio_sam_port_clear_bits_raw(const struct device *dev,
					uint32_t mask)
{
	const struct gpio_sam_config * const cfg = dev->config;
	Pio * const pio = cfg->regs;
  4065b8:	6843      	ldr	r3, [r0, #4]

	/* Clear pins. */
	pio->PIO_CODR = mask;

	return 0;
}
  4065ba:	2000      	movs	r0, #0
	Pio * const pio = cfg->regs;
  4065bc:	685b      	ldr	r3, [r3, #4]
	pio->PIO_CODR = mask;
  4065be:	6359      	str	r1, [r3, #52]	; 0x34
}
  4065c0:	4770      	bx	lr

004065c2 <gpio_sam_port_toggle_bits>:

static int gpio_sam_port_toggle_bits(const struct device *dev, uint32_t mask)
{
	const struct gpio_sam_config * const cfg = dev->config;
	Pio * const pio = cfg->regs;
  4065c2:	6843      	ldr	r3, [r0, #4]

	/* Toggle pins. */
	pio->PIO_ODSR ^= mask;

	return 0;
}
  4065c4:	2000      	movs	r0, #0
	Pio * const pio = cfg->regs;
  4065c6:	685a      	ldr	r2, [r3, #4]
	pio->PIO_ODSR ^= mask;
  4065c8:	6b93      	ldr	r3, [r2, #56]	; 0x38
  4065ca:	404b      	eors	r3, r1
  4065cc:	6393      	str	r3, [r2, #56]	; 0x38
}
  4065ce:	4770      	bx	lr

004065d0 <gpio_sam_manage_callback>:

static int gpio_sam_manage_callback(const struct device *port,
				    struct gpio_callback *callback,
				    bool set)
{
	struct gpio_sam_runtime *context = port->data;
  4065d0:	6903      	ldr	r3, [r0, #16]
	return list->head;
  4065d2:	6858      	ldr	r0, [r3, #4]
{
  4065d4:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
  4065d6:	b158      	cbz	r0, 4065f0 <gpio_sam_manage_callback+0x20>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4065d8:	2400      	movs	r4, #0
  4065da:	4281      	cmp	r1, r0
  4065dc:	d112      	bne.n	406604 <gpio_sam_manage_callback+0x34>
	return node->next;
  4065de:	6808      	ldr	r0, [r1, #0]
	return list->tail;
  4065e0:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
  4065e2:	b954      	cbnz	r4, 4065fa <gpio_sam_manage_callback+0x2a>
  4065e4:	428d      	cmp	r5, r1
	list->head = node;
  4065e6:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
  4065e8:	d100      	bne.n	4065ec <gpio_sam_manage_callback+0x1c>
	list->tail = node;
  4065ea:	6098      	str	r0, [r3, #8]
	parent->next = child;
  4065ec:	2000      	movs	r0, #0
  4065ee:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
  4065f0:	b96a      	cbnz	r2, 40660e <gpio_sam_manage_callback+0x3e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
  4065f2:	2000      	movs	r0, #0

	return gpio_manage_callback(&context->cb, callback, set);
}
  4065f4:	bd30      	pop	{r4, r5, pc}
  4065f6:	4628      	mov	r0, r5
  4065f8:	e7ef      	b.n	4065da <gpio_sam_manage_callback+0xa>
Z_GENLIST_REMOVE(slist, snode)
  4065fa:	428d      	cmp	r5, r1
	parent->next = child;
  4065fc:	6020      	str	r0, [r4, #0]
	list->tail = node;
  4065fe:	bf08      	it	eq
  406600:	609c      	streq	r4, [r3, #8]
}
  406602:	e7f3      	b.n	4065ec <gpio_sam_manage_callback+0x1c>
	return node->next;
  406604:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  406606:	4604      	mov	r4, r0
  406608:	2d00      	cmp	r5, #0
  40660a:	d1f4      	bne.n	4065f6 <gpio_sam_manage_callback+0x26>
			if (!set) {
  40660c:	b13a      	cbz	r2, 40661e <gpio_sam_manage_callback+0x4e>
	parent->next = child;
  40660e:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
  406610:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
  406612:	600a      	str	r2, [r1, #0]
	list->head = node;
  406614:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
  406616:	2800      	cmp	r0, #0
  406618:	d1eb      	bne.n	4065f2 <gpio_sam_manage_callback+0x22>
	list->tail = node;
  40661a:	6099      	str	r1, [r3, #8]
}
  40661c:	e7ea      	b.n	4065f4 <gpio_sam_manage_callback+0x24>
				return -EINVAL;
  40661e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&context->cb, callback, set);
  406622:	e7e7      	b.n	4065f4 <gpio_sam_manage_callback+0x24>

00406624 <gpio_sam_init>:
	.pin_interrupt_configure = gpio_sam_pin_interrupt_configure,
	.manage_callback = gpio_sam_manage_callback,
};

int gpio_sam_init(const struct device *dev)
{
  406624:	b538      	push	{r3, r4, r5, lr}
	const struct gpio_sam_config * const cfg = dev->config;
  406626:	6845      	ldr	r5, [r0, #4]
{
  406628:	4604      	mov	r4, r0

	/* The peripheral clock must be enabled for the interrupts to work. */
	soc_pmc_peripheral_enable(cfg->periph_id);
  40662a:	68e8      	ldr	r0, [r5, #12]
  40662c:	f7fb fd88 	bl	402140 <soc_pmc_peripheral_enable>

	cfg->config_func(dev);
  406630:	4620      	mov	r0, r4
  406632:	68ab      	ldr	r3, [r5, #8]
  406634:	4798      	blx	r3

	return 0;
}
  406636:	2000      	movs	r0, #0
  406638:	bd38      	pop	{r3, r4, r5, pc}

0040663a <port_0_sam_config_func>:
			    gpio_sam_isr,				\
			    DEVICE_DT_INST_GET(n), 0);			\
		irq_enable(DT_INST_IRQN(n));				\
	}

DT_INST_FOREACH_STATUS_OKAY(GPIO_SAM_INIT)
  40663a:	200a      	movs	r0, #10
  40663c:	2200      	movs	r2, #0
  40663e:	2101      	movs	r1, #1
  406640:	b508      	push	{r3, lr}
  406642:	f7fc fa75 	bl	402b30 <z_arm_irq_priority_set>
  406646:	200a      	movs	r0, #10
  406648:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  40664c:	f7fc ba60 	b.w	402b10 <arch_irq_enable>

00406650 <port_1_sam_config_func>:
  406650:	200b      	movs	r0, #11
  406652:	2200      	movs	r2, #0
  406654:	2101      	movs	r1, #1
  406656:	b508      	push	{r3, lr}
  406658:	f7fc fa6a 	bl	402b30 <z_arm_irq_priority_set>
  40665c:	200b      	movs	r0, #11
  40665e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  406662:	f7fc ba55 	b.w	402b10 <arch_irq_enable>

00406666 <port_2_sam_config_func>:
  406666:	200c      	movs	r0, #12
  406668:	2200      	movs	r2, #0
  40666a:	2101      	movs	r1, #1
  40666c:	b508      	push	{r3, lr}
  40666e:	f7fc fa5f 	bl	402b30 <z_arm_irq_priority_set>
  406672:	200c      	movs	r0, #12
  406674:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  406678:	f7fc ba4a 	b.w	402b10 <arch_irq_enable>

0040667c <port_3_sam_config_func>:
  40667c:	2010      	movs	r0, #16
  40667e:	2200      	movs	r2, #0
  406680:	2101      	movs	r1, #1
  406682:	b508      	push	{r3, lr}
  406684:	f7fc fa54 	bl	402b30 <z_arm_irq_priority_set>
  406688:	2010      	movs	r0, #16
  40668a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  40668e:	f7fc ba3f 	b.w	402b10 <arch_irq_enable>

00406692 <port_4_sam_config_func>:
  406692:	2011      	movs	r0, #17
  406694:	2200      	movs	r2, #0
  406696:	2101      	movs	r1, #1
  406698:	b508      	push	{r3, lr}
  40669a:	f7fc fa49 	bl	402b30 <z_arm_irq_priority_set>
  40669e:	2011      	movs	r0, #17
  4066a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  4066a4:	f7fc ba34 	b.w	402b10 <arch_irq_enable>

004066a8 <gpio_sam_pin_interrupt_configure>:
{
  4066a8:	b510      	push	{r4, lr}
	Pio * const pio = cfg->regs;
  4066aa:	6840      	ldr	r0, [r0, #4]
	return gpio_sam_port_interrupt_configure(dev, BIT(pin), mode, trig);
  4066ac:	2401      	movs	r4, #1
	if (trig != GPIO_INT_TRIG_BOTH) {
  4066ae:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
	return gpio_sam_port_interrupt_configure(dev, BIT(pin), mode, trig);
  4066b2:	fa04 f101 	lsl.w	r1, r4, r1
	Pio * const pio = cfg->regs;
  4066b6:	6840      	ldr	r0, [r0, #4]
	pio->PIO_IDR = mask;
  4066b8:	6441      	str	r1, [r0, #68]	; 0x44
	pio->PIO_AIMDR = mask;
  4066ba:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
	if (trig != GPIO_INT_TRIG_BOTH) {
  4066be:	d013      	beq.n	4066e8 <gpio_sam_pin_interrupt_configure+0x40>
		if (mode == GPIO_INT_MODE_EDGE) {
  4066c0:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
		pio->PIO_AIMER = mask;
  4066c4:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
		if (mode == GPIO_INT_MODE_EDGE) {
  4066c8:	d115      	bne.n	4066f6 <gpio_sam_pin_interrupt_configure+0x4e>
			pio->PIO_ESR = mask;
  4066ca:	f8c0 10c0 	str.w	r1, [r0, #192]	; 0xc0
		if (trig == GPIO_INT_TRIG_HIGH) {
  4066ce:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
			rising_edge = ~mask;
  4066d2:	bf14      	ite	ne
  4066d4:	43cb      	mvnne	r3, r1
			rising_edge = mask;
  4066d6:	460b      	moveq	r3, r1
		pio->PIO_REHLSR = rising_edge & mask;
  4066d8:	ea01 0403 	and.w	r4, r1, r3
		pio->PIO_FELLSR = ~rising_edge & mask;
  4066dc:	ea21 0303 	bic.w	r3, r1, r3
		pio->PIO_REHLSR = rising_edge & mask;
  4066e0:	f8c0 40d4 	str.w	r4, [r0, #212]	; 0xd4
		pio->PIO_FELLSR = ~rising_edge & mask;
  4066e4:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
	if (mode != GPIO_INT_MODE_DISABLED) {
  4066e8:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  4066ec:	d001      	beq.n	4066f2 <gpio_sam_pin_interrupt_configure+0x4a>
		(void)pio->PIO_ISR;
  4066ee:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
		pio->PIO_IER = mask;
  4066f0:	6401      	str	r1, [r0, #64]	; 0x40
}
  4066f2:	2000      	movs	r0, #0
  4066f4:	bd10      	pop	{r4, pc}
			pio->PIO_LSR = mask;
  4066f6:	f8c0 10c4 	str.w	r1, [r0, #196]	; 0xc4
  4066fa:	e7e8      	b.n	4066ce <gpio_sam_pin_interrupt_configure+0x26>

004066fc <gpio_sam_config>:
	return gpio_sam_port_configure(dev, BIT(pin), flags);
  4066fc:	2301      	movs	r3, #1
  4066fe:	fa03 f101 	lsl.w	r1, r3, r1
	Pio * const pio = cfg->regs;
  406702:	6843      	ldr	r3, [r0, #4]
	if (flags & GPIO_SINGLE_ENDED) {
  406704:	0790      	lsls	r0, r2, #30
	Pio * const pio = cfg->regs;
  406706:	685b      	ldr	r3, [r3, #4]
	if (flags & GPIO_SINGLE_ENDED) {
  406708:	d42b      	bmi.n	406762 <gpio_sam_config+0x66>
	if (!(flags & (GPIO_OUTPUT | GPIO_INPUT))) {
  40670a:	f412 7040 	ands.w	r0, r2, #768	; 0x300
  40670e:	d106      	bne.n	40671e <gpio_sam_config+0x22>
		pio->PIO_IDR = mask;
  406710:	6459      	str	r1, [r3, #68]	; 0x44
		pio->PIO_PUDR = mask;
  406712:	6619      	str	r1, [r3, #96]	; 0x60
		pio->PIO_PPDDR = mask;
  406714:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
		pio->PIO_PER = mask;
  406718:	6019      	str	r1, [r3, #0]
		pio->PIO_ODR = mask;
  40671a:	6159      	str	r1, [r3, #20]
		return 0;
  40671c:	4770      	bx	lr
	if (flags & GPIO_OUTPUT) {
  40671e:	0590      	lsls	r0, r2, #22
  406720:	d515      	bpl.n	40674e <gpio_sam_config+0x52>
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
  406722:	0510      	lsls	r0, r2, #20
  406724:	d500      	bpl.n	406728 <gpio_sam_config+0x2c>
			pio->PIO_SODR = mask;
  406726:	6319      	str	r1, [r3, #48]	; 0x30
		if (flags & GPIO_OUTPUT_INIT_LOW) {
  406728:	0550      	lsls	r0, r2, #21
  40672a:	d500      	bpl.n	40672e <gpio_sam_config+0x32>
			pio->PIO_CODR = mask;
  40672c:	6359      	str	r1, [r3, #52]	; 0x34
		pio->PIO_OER = mask;
  40672e:	6119      	str	r1, [r3, #16]
		pio->PIO_OWER = mask;
  406730:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0
	if (flags & GPIO_PULL_UP) {
  406734:	06d0      	lsls	r0, r2, #27
	pio->PIO_PUDR = mask;
  406736:	6619      	str	r1, [r3, #96]	; 0x60
	pio->PIO_PPDDR = mask;
  406738:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
	if (flags & GPIO_PULL_UP) {
  40673c:	d509      	bpl.n	406752 <gpio_sam_config+0x56>
		pio->PIO_PUER = mask;
  40673e:	6659      	str	r1, [r3, #100]	; 0x64
	if (flags & GPIO_INT_DEBOUNCE) {
  406740:	0312      	lsls	r2, r2, #12
  406742:	d50b      	bpl.n	40675c <gpio_sam_config+0x60>
		pio->PIO_IFSCER = mask;
  406744:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	return 0;
  406748:	2000      	movs	r0, #0
	pio->PIO_PER = mask;
  40674a:	6019      	str	r1, [r3, #0]
	return 0;
  40674c:	4770      	bx	lr
		pio->PIO_ODR = mask;
  40674e:	6159      	str	r1, [r3, #20]
  406750:	e7f0      	b.n	406734 <gpio_sam_config+0x38>
	} else if (flags & GPIO_PULL_DOWN) {
  406752:	0690      	lsls	r0, r2, #26
  406754:	d5f4      	bpl.n	406740 <gpio_sam_config+0x44>
		pio->PIO_PPDER = mask;
  406756:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
  40675a:	e7f1      	b.n	406740 <gpio_sam_config+0x44>
		pio->PIO_IFSCDR = mask;
  40675c:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
  406760:	e7f2      	b.n	406748 <gpio_sam_config+0x4c>
		return -ENOTSUP;
  406762:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
  406766:	4770      	bx	lr

00406768 <gpio_sam_isr>:
	Pio * const pio = cfg->regs;
  406768:	6843      	ldr	r3, [r0, #4]
  40676a:	685b      	ldr	r3, [r3, #4]
{
  40676c:	b570      	push	{r4, r5, r6, lr}
	int_stat = pio->PIO_ISR;
  40676e:	6cde      	ldr	r6, [r3, #76]	; 0x4c
{
  406770:	4604      	mov	r4, r0
  406772:	6903      	ldr	r3, [r0, #16]
  406774:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
  406776:	b151      	cbz	r1, 40678e <gpio_sam_isr+0x26>
	return node->next;
  406778:	680d      	ldr	r5, [r1, #0]
		if (cb->pin_mask & pins) {
  40677a:	688a      	ldr	r2, [r1, #8]
  40677c:	4032      	ands	r2, r6
  40677e:	d002      	beq.n	406786 <gpio_sam_isr+0x1e>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
  406780:	684b      	ldr	r3, [r1, #4]
  406782:	4620      	mov	r0, r4
  406784:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
  406786:	b115      	cbz	r5, 40678e <gpio_sam_isr+0x26>
  406788:	4629      	mov	r1, r5
  40678a:	682d      	ldr	r5, [r5, #0]
  40678c:	e7f5      	b.n	40677a <gpio_sam_isr+0x12>
}
  40678e:	bd70      	pop	{r4, r5, r6, pc}

00406790 <i2c0_sam_irq_config>:
			    NULL,					\
			    &i2c##n##_sam_data, &i2c##n##_sam_config,	\
			    POST_KERNEL, CONFIG_I2C_INIT_PRIORITY,	\
			    &i2c_sam_twihs_driver_api);

DT_INST_FOREACH_STATUS_OKAY(I2C_TWIHS_SAM_INIT)
  406790:	2200      	movs	r2, #0
  406792:	2013      	movs	r0, #19
  406794:	4611      	mov	r1, r2
  406796:	f7fc b9cb 	b.w	402b30 <z_arm_irq_priority_set>

0040679a <i2c_sam_twihs_isr>:
{
  40679a:	4603      	mov	r3, r0
	struct i2c_sam_twihs_dev_data *const dev_data = dev->data;
  40679c:	6900      	ldr	r0, [r0, #16]
	Twihs *const twihs = dev_cfg->regs;
  40679e:	685b      	ldr	r3, [r3, #4]
  4067a0:	681b      	ldr	r3, [r3, #0]
	isr_status = twihs->TWIHS_SR & twihs->TWIHS_IMR;
  4067a2:	6a19      	ldr	r1, [r3, #32]
  4067a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4067a6:	400a      	ands	r2, r1
{
  4067a8:	b470      	push	{r4, r5, r6}
	if (isr_status & TWIHS_SR_NACK) {
  4067aa:	05d6      	lsls	r6, r2, #23
  4067ac:	d505      	bpl.n	4067ba <i2c_sam_twihs_isr+0x20>
		msg->twihs_sr = isr_status;
  4067ae:	61c2      	str	r2, [r0, #28]
	twihs->TWIHS_IDR = twihs->TWIHS_IMR;
  4067b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4067b2:	629a      	str	r2, [r3, #40]	; 0x28
}
  4067b4:	bc70      	pop	{r4, r5, r6}
	z_impl_k_sem_give(sem);
  4067b6:	f7fe bb93 	b.w	404ee0 <z_impl_k_sem_give>
	if (isr_status & TWIHS_SR_RXRDY) {
  4067ba:	0795      	lsls	r5, r2, #30
  4067bc:	d50c      	bpl.n	4067d8 <i2c_sam_twihs_isr+0x3e>
		msg->buf[msg->idx++] = twihs->TWIHS_RHR;
  4067be:	6981      	ldr	r1, [r0, #24]
  4067c0:	6b1d      	ldr	r5, [r3, #48]	; 0x30
  4067c2:	6904      	ldr	r4, [r0, #16]
  4067c4:	1c4e      	adds	r6, r1, #1
  4067c6:	6186      	str	r6, [r0, #24]
  4067c8:	5465      	strb	r5, [r4, r1]
		if (msg->idx == msg->len - 1U) {
  4067ca:	6941      	ldr	r1, [r0, #20]
  4067cc:	6984      	ldr	r4, [r0, #24]
  4067ce:	3901      	subs	r1, #1
  4067d0:	428c      	cmp	r4, r1
  4067d2:	d101      	bne.n	4067d8 <i2c_sam_twihs_isr+0x3e>
			twihs->TWIHS_CR = TWIHS_CR_STOP;
  4067d4:	2102      	movs	r1, #2
  4067d6:	6019      	str	r1, [r3, #0]
	if (isr_status & TWIHS_SR_TXRDY) {
  4067d8:	0754      	lsls	r4, r2, #29
  4067da:	d50b      	bpl.n	4067f4 <i2c_sam_twihs_isr+0x5a>
		if (msg->idx == msg->len) {
  4067dc:	e9d0 4105 	ldrd	r4, r1, [r0, #20]
  4067e0:	42a1      	cmp	r1, r4
  4067e2:	d10b      	bne.n	4067fc <i2c_sam_twihs_isr+0x62>
			if (msg->flags & I2C_MSG_STOP) {
  4067e4:	f890 1020 	ldrb.w	r1, [r0, #32]
  4067e8:	0789      	lsls	r1, r1, #30
  4067ea:	d5e1      	bpl.n	4067b0 <i2c_sam_twihs_isr+0x16>
				twihs->TWIHS_CR = TWIHS_CR_STOP;
  4067ec:	2102      	movs	r1, #2
  4067ee:	6019      	str	r1, [r3, #0]
				twihs->TWIHS_IDR = TWIHS_IDR_TXRDY;
  4067f0:	2104      	movs	r1, #4
  4067f2:	6299      	str	r1, [r3, #40]	; 0x28
	if (isr_status & TWIHS_SR_TXCOMP) {
  4067f4:	07d2      	lsls	r2, r2, #31
  4067f6:	d4db      	bmi.n	4067b0 <i2c_sam_twihs_isr+0x16>
}
  4067f8:	bc70      	pop	{r4, r5, r6}
  4067fa:	4770      	bx	lr
			twihs->TWIHS_THR = msg->buf[msg->idx++];
  4067fc:	6904      	ldr	r4, [r0, #16]
  4067fe:	1c4d      	adds	r5, r1, #1
  406800:	6185      	str	r5, [r0, #24]
  406802:	5c61      	ldrb	r1, [r4, r1]
  406804:	6359      	str	r1, [r3, #52]	; 0x34
  406806:	e7f5      	b.n	4067f4 <i2c_sam_twihs_isr+0x5a>

00406808 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
  406808:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
  40680a:	ab0a      	add	r3, sp, #40	; 0x28
  40680c:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
  40680e:	9302      	str	r3, [sp, #8]
  406810:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406812:	9301      	str	r3, [sp, #4]
  406814:	2300      	movs	r3, #0
  406816:	4618      	mov	r0, r3
  406818:	9300      	str	r3, [sp, #0]
  40681a:	f7fc f883 	bl	402924 <z_impl_z_log_msg2_runtime_vcreate>
}
  40681e:	b007      	add	sp, #28
  406820:	f85d fb04 	ldr.w	pc, [sp], #4

00406824 <i2c_sam_twihs_transfer>:
{
  406824:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406828:	460c      	mov	r4, r1
	if (!num_msgs) {
  40682a:	4691      	mov	r9, r2
  40682c:	b91a      	cbnz	r2, 406836 <i2c_sam_twihs_transfer+0x12>
		return 0;
  40682e:	2000      	movs	r0, #0
}
  406830:	b003      	add	sp, #12
  406832:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	Twihs *const twihs = dev_cfg->regs;
  406836:	6842      	ldr	r2, [r0, #4]
	twihs->TWIHS_MMR = TWIHS_MMR_DADR(daddr);
  406838:	041b      	lsls	r3, r3, #16
	twihs->TWIHS_THR = msg->buf[msg->idx++];
  40683a:	f04f 0b01 	mov.w	fp, #1
	twihs->TWIHS_IER = TWIHS_IER_TXRDY | TWIHS_IER_TXCOMP | TWIHS_IER_NACK;
  40683e:	f240 1105 	movw	r1, #261	; 0x105
	Twihs *const twihs = dev_cfg->regs;
  406842:	6816      	ldr	r6, [r2, #0]
	twihs->TWIHS_MMR = TWIHS_MMR_DADR(daddr);
  406844:	f403 07fe 	and.w	r7, r3, #8323072	; 0x7f0000
	struct i2c_sam_twihs_dev_data *const dev_data = dev->data;
  406848:	6905      	ldr	r5, [r0, #16]
	(void)twihs->TWIHS_SR;
  40684a:	6a32      	ldr	r2, [r6, #32]
	twihs->TWIHS_IADR = 0;
  40684c:	2200      	movs	r2, #0
	twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(daddr);
  40684e:	f447 5380 	orr.w	r3, r7, #4096	; 0x1000
	for (int i = 0; i < num_msgs; i++) {
  406852:	4690      	mov	r8, r2
		dev_data->msg.idx = 0U;
  406854:	4692      	mov	sl, r2
	twihs->TWIHS_IADR = 0;
  406856:	60f2      	str	r2, [r6, #12]
	twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(daddr);
  406858:	9301      	str	r3, [sp, #4]
		dev_data->msg.buf = msgs[i].buf;
  40685a:	6823      	ldr	r3, [r4, #0]
		dev_data->msg.len = msgs[i].len;
  40685c:	6862      	ldr	r2, [r4, #4]
		dev_data->msg.buf = msgs[i].buf;
  40685e:	612b      	str	r3, [r5, #16]
		dev_data->msg.twihs_sr = 0U;
  406860:	f8c5 a01c 	str.w	sl, [r5, #28]
		dev_data->msg.idx = 0U;
  406864:	e9c5 2a05 	strd	r2, sl, [r5, #20]
		dev_data->msg.flags = msgs[i].flags;
  406868:	7a20      	ldrb	r0, [r4, #8]
  40686a:	f885 0020 	strb.w	r0, [r5, #32]
		if ((msgs[i].flags & I2C_MSG_RW_MASK) == I2C_MSG_READ) {
  40686e:	07c0      	lsls	r0, r0, #31
  406870:	d51c      	bpl.n	4068ac <i2c_sam_twihs_transfer+0x88>
	twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(daddr);
  406872:	9b01      	ldr	r3, [sp, #4]
	twihs_cr_stop = (msg->len == 1U) ? TWIHS_CR_STOP : 0;
  406874:	2a01      	cmp	r2, #1
	twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(daddr);
  406876:	6073      	str	r3, [r6, #4]
	twihs->TWIHS_IER = TWIHS_IER_RXRDY | TWIHS_IER_TXCOMP | TWIHS_IER_NACK;
  406878:	f240 1303 	movw	r3, #259	; 0x103
  40687c:	6273      	str	r3, [r6, #36]	; 0x24
	twihs_cr_stop = (msg->len == 1U) ? TWIHS_CR_STOP : 0;
  40687e:	bf0c      	ite	eq
  406880:	2302      	moveq	r3, #2
  406882:	2300      	movne	r3, #0
	twihs->TWIHS_CR = TWIHS_CR_START | twihs_cr_stop;
  406884:	f043 0301 	orr.w	r3, r3, #1
  406888:	6033      	str	r3, [r6, #0]
	return z_impl_k_sem_take(sem, timeout);
  40688a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  40688e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  406892:	4628      	mov	r0, r5
  406894:	f7fe fb44 	bl	404f20 <z_impl_k_sem_take>
		if (dev_data->msg.twihs_sr > 0) {
  406898:	69eb      	ldr	r3, [r5, #28]
  40689a:	b973      	cbnz	r3, 4068ba <i2c_sam_twihs_transfer+0x96>
	for (int i = 0; i < num_msgs; i++) {
  40689c:	f108 0801 	add.w	r8, r8, #1
  4068a0:	340c      	adds	r4, #12
  4068a2:	f240 1105 	movw	r1, #261	; 0x105
  4068a6:	45c1      	cmp	r9, r8
  4068a8:	dcd7      	bgt.n	40685a <i2c_sam_twihs_transfer+0x36>
  4068aa:	e7c0      	b.n	40682e <i2c_sam_twihs_transfer+0xa>
	twihs->TWIHS_MMR = TWIHS_MMR_DADR(daddr);
  4068ac:	6077      	str	r7, [r6, #4]
	twihs->TWIHS_THR = msg->buf[msg->idx++];
  4068ae:	f8c5 b018 	str.w	fp, [r5, #24]
  4068b2:	781b      	ldrb	r3, [r3, #0]
  4068b4:	6373      	str	r3, [r6, #52]	; 0x34
	twihs->TWIHS_IER = TWIHS_IER_TXRDY | TWIHS_IER_TXCOMP | TWIHS_IER_NACK;
  4068b6:	6271      	str	r1, [r6, #36]	; 0x24
}
  4068b8:	e7e7      	b.n	40688a <i2c_sam_twihs_transfer+0x66>
			return -EIO;
  4068ba:	f06f 0004 	mvn.w	r0, #4
  4068be:	e7b7      	b.n	406830 <i2c_sam_twihs_transfer+0xc>

004068c0 <wdt_sam_isr>:
	Wdt * const wdt = config->regs;
  4068c0:	6842      	ldr	r2, [r0, #4]
	data->cb(dev, 0);
  4068c2:	2100      	movs	r1, #0
  4068c4:	6903      	ldr	r3, [r0, #16]
	Wdt * const wdt = config->regs;
  4068c6:	6812      	ldr	r2, [r2, #0]
	data->cb(dev, 0);
  4068c8:	681b      	ldr	r3, [r3, #0]
	wdt_sr = wdt->WDT_SR;
  4068ca:	6892      	ldr	r2, [r2, #8]
	data->cb(dev, 0);
  4068cc:	4718      	bx	r3

004068ce <wdt_sam_disable>:
	struct wdt_sam_dev_data *data = dev->data;
  4068ce:	6902      	ldr	r2, [r0, #16]
	Wdt * const wdt = config->regs;
  4068d0:	6843      	ldr	r3, [r0, #4]
	if (data->mode_set) {
  4068d2:	7a50      	ldrb	r0, [r2, #9]
	Wdt * const wdt = config->regs;
  4068d4:	6819      	ldr	r1, [r3, #0]
	if (data->mode_set) {
  4068d6:	b930      	cbnz	r0, 4068e6 <wdt_sam_disable+0x18>
	wdt->WDT_MR |= WDT_MR_WDDIS;
  4068d8:	684b      	ldr	r3, [r1, #4]
  4068da:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4068de:	604b      	str	r3, [r1, #4]
	data->mode_set = true;
  4068e0:	2301      	movs	r3, #1
  4068e2:	7253      	strb	r3, [r2, #9]
	return 0;
  4068e4:	4770      	bx	lr
		return -EPERM;
  4068e6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  4068ea:	4770      	bx	lr

004068ec <wdt_sam_feed>:
	/*
	 * On watchdog restart the Watchdog counter is immediately
	 * reloaded/feeded with the 12-bit watchdog counter
	 * value from WDT_MR and restarted
	 */
	Wdt * const wdt = config->regs;
  4068ec:	6843      	ldr	r3, [r0, #4]

	wdt->WDT_CR |= WDT_CR_KEY_PASSWD | WDT_CR_WDRSTT;

	return 0;
}
  4068ee:	2000      	movs	r0, #0
	Wdt * const wdt = config->regs;
  4068f0:	681a      	ldr	r2, [r3, #0]
	wdt->WDT_CR |= WDT_CR_KEY_PASSWD | WDT_CR_WDRSTT;
  4068f2:	6813      	ldr	r3, [r2, #0]
  4068f4:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  4068f8:	f043 0301 	orr.w	r3, r3, #1
  4068fc:	6013      	str	r3, [r2, #0]
}
  4068fe:	4770      	bx	lr

00406900 <wdt_sam_init>:
		    DEVICE_DT_INST_GET(0), 0);
	irq_enable(DT_INST_IRQN(0));
}

static int wdt_sam_init(const struct device *dev)
{
  406900:	b508      	push	{r3, lr}
#ifdef CONFIG_WDT_DISABLE_AT_BOOT
	wdt_sam_disable(dev);
  406902:	f7ff ffe4 	bl	4068ce <wdt_sam_disable>
	IRQ_CONNECT(DT_INST_IRQN(0),
  406906:	2200      	movs	r2, #0
  406908:	2004      	movs	r0, #4
  40690a:	4611      	mov	r1, r2
  40690c:	f7fc f910 	bl	402b30 <z_arm_irq_priority_set>
	irq_enable(DT_INST_IRQN(0));
  406910:	2004      	movs	r0, #4
  406912:	f7fc f8fd 	bl	402b10 <arch_irq_enable>
#endif

	wdt_sam_irq_config();
	return 0;
}
  406916:	2000      	movs	r0, #0
  406918:	bd08      	pop	{r3, pc}

0040691a <can_get_core_clock>:
	return api->get_core_clock(dev, rate);
  40691a:	6883      	ldr	r3, [r0, #8]
  40691c:	69db      	ldr	r3, [r3, #28]
  40691e:	4718      	bx	r3

00406920 <can_calc_timing>:

int can_calc_timing(const struct device *dev, struct can_timing *res,
		    uint32_t bitrate, uint16_t sample_pnt)
{
  406920:	b5f0      	push	{r4, r5, r6, r7, lr}
  406922:	b085      	sub	sp, #20
  406924:	460c      	mov	r4, r1
  406926:	4615      	mov	r5, r2
  406928:	461e      	mov	r6, r3
	const struct can_driver_api *api = dev->api;
	uint32_t core_clock;
	int ret;

	ret = can_get_core_clock(dev, &core_clock);
  40692a:	a903      	add	r1, sp, #12
	const struct can_driver_api *api = dev->api;
  40692c:	6887      	ldr	r7, [r0, #8]
	ret = can_get_core_clock(dev, &core_clock);
  40692e:	f7ff fff4 	bl	40691a <can_get_core_clock>
	if (ret != 0) {
  406932:	b948      	cbnz	r0, 406948 <can_calc_timing+0x28>
		return ret;
	}

	return can_calc_timing_int(core_clock, res, &api->timing_min,
  406934:	f107 032e 	add.w	r3, r7, #46	; 0x2e
  406938:	f107 0224 	add.w	r2, r7, #36	; 0x24
  40693c:	4621      	mov	r1, r4
  40693e:	9803      	ldr	r0, [sp, #12]
  406940:	e9cd 5600 	strd	r5, r6, [sp]
  406944:	f7fc ffac 	bl	4038a0 <can_calc_timing_int>
				   &api->timing_max, bitrate, sample_pnt);
}
  406948:	b005      	add	sp, #20
  40694a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0040694c <can_calc_timing_data>:

#ifdef CONFIG_CAN_FD_MODE
int can_calc_timing_data(const struct device *dev, struct can_timing *res,
			 uint32_t bitrate, uint16_t sample_pnt)
{
  40694c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40694e:	b085      	sub	sp, #20
  406950:	460c      	mov	r4, r1
  406952:	4615      	mov	r5, r2
  406954:	461e      	mov	r6, r3
	const struct can_driver_api *api = dev->api;
	uint32_t core_clock;
	int ret;

	ret = can_get_core_clock(dev, &core_clock);
  406956:	a903      	add	r1, sp, #12
	const struct can_driver_api *api = dev->api;
  406958:	6887      	ldr	r7, [r0, #8]
	ret = can_get_core_clock(dev, &core_clock);
  40695a:	f7ff ffde 	bl	40691a <can_get_core_clock>
	if (ret != 0) {
  40695e:	b948      	cbnz	r0, 406974 <can_calc_timing_data+0x28>
		return ret;
	}

	return can_calc_timing_int(core_clock, res, &api->timing_min_data,
  406960:	f107 0342 	add.w	r3, r7, #66	; 0x42
  406964:	f107 0238 	add.w	r2, r7, #56	; 0x38
  406968:	4621      	mov	r1, r4
  40696a:	9803      	ldr	r0, [sp, #12]
  40696c:	e9cd 5600 	strd	r5, r6, [sp]
  406970:	f7fc ff96 	bl	4038a0 <can_calc_timing_int>
				   &api->timing_max_data, bitrate, sample_pnt);
}
  406974:	b005      	add	sp, #20
  406976:	bdf0      	pop	{r4, r5, r6, r7, pc}

00406978 <can_calc_prescaler>:
#endif

int can_calc_prescaler(const struct device *dev, struct can_timing *timing,
		       uint32_t bitrate)
{
  406978:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  40697c:	460d      	mov	r5, r1
	uint32_t ts = timing->prop_seg + timing->phase_seg1 + timing->phase_seg2 +
  40697e:	884e      	ldrh	r6, [r1, #2]
  406980:	f8b1 8004 	ldrh.w	r8, [r1, #4]
{
  406984:	4614      	mov	r4, r2
	uint32_t ts = timing->prop_seg + timing->phase_seg1 + timing->phase_seg2 +
  406986:	88cf      	ldrh	r7, [r1, #6]
		   CAN_SYNC_SEG;
	uint32_t core_clock;
	int ret;

	ret = can_get_core_clock(dev, &core_clock);
  406988:	a901      	add	r1, sp, #4
  40698a:	f7ff ffc6 	bl	40691a <can_get_core_clock>
	if (ret != 0) {
  40698e:	b978      	cbnz	r0, 4069b0 <can_calc_prescaler+0x38>
	uint32_t ts = timing->prop_seg + timing->phase_seg1 + timing->phase_seg2 +
  406990:	eb06 0008 	add.w	r0, r6, r8
		return ret;
	}

	timing->prescaler = core_clock / (bitrate * ts);
  406994:	9b01      	ldr	r3, [sp, #4]
	uint32_t ts = timing->prop_seg + timing->phase_seg1 + timing->phase_seg2 +
  406996:	19c2      	adds	r2, r0, r7
	timing->prescaler = core_clock / (bitrate * ts);
  406998:	fb02 4404 	mla	r4, r2, r4, r4
  40699c:	fbb3 f0f4 	udiv	r0, r3, r4
  4069a0:	8128      	strh	r0, [r5, #8]

	return core_clock % (ts * timing->prescaler);
  4069a2:	b280      	uxth	r0, r0
  4069a4:	fb02 0000 	mla	r0, r2, r0, r0
  4069a8:	fbb3 f2f0 	udiv	r2, r3, r0
  4069ac:	fb00 3012 	mls	r0, r0, r2, r3
}
  4069b0:	b002      	add	sp, #8
  4069b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

004069b6 <memcpy32_volatile>:
	while (len--) {
  4069b6:	f022 0203 	bic.w	r2, r2, #3
  4069ba:	440a      	add	r2, r1
  4069bc:	4291      	cmp	r1, r2
  4069be:	d100      	bne.n	4069c2 <memcpy32_volatile+0xc>
}
  4069c0:	4770      	bx	lr
		*dst = *src;
  4069c2:	f851 3b04 	ldr.w	r3, [r1], #4
  4069c6:	f840 3b04 	str.w	r3, [r0], #4
		++src;
  4069ca:	e7f7      	b.n	4069bc <memcpy32_volatile+0x6>

004069cc <z_log_msg2_static_create.constprop.0>:
	z_impl_z_log_msg2_static_create(source, desc, package, data);
  4069cc:	2300      	movs	r3, #0
  4069ce:	f7ff bd84 	b.w	4064da <z_impl_z_log_msg2_static_create>

004069d2 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
  4069d2:	f7fe ba43 	b.w	404e5c <z_impl_k_mutex_unlock>

004069d6 <can_enter_init_mode.constprop.0>:
static int can_enter_init_mode(struct can_mcan_reg  *can, k_timeout_t timeout)
  4069d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	can->cccr |= CAN_MCAN_CCCR_INIT;
  4069d8:	6983      	ldr	r3, [r0, #24]
static int can_enter_init_mode(struct can_mcan_reg  *can, k_timeout_t timeout)
  4069da:	4604      	mov	r4, r0
	can->cccr |= CAN_MCAN_CCCR_INIT;
  4069dc:	f043 0301 	orr.w	r3, r3, #1
  4069e0:	6183      	str	r3, [r0, #24]
	return z_impl_k_uptime_ticks();
  4069e2:	f000 fa3d 	bl	406e60 <z_impl_k_uptime_ticks>
		if (k_uptime_ticks() - start_time > timeout.ticks) {
  4069e6:	f240 37e9 	movw	r7, #1001	; 0x3e9
  4069ea:	4605      	mov	r5, r0
  4069ec:	460e      	mov	r6, r1
	while ((can->cccr & CAN_MCAN_CCCR_INIT) == 0U) {
  4069ee:	69a3      	ldr	r3, [r4, #24]
  4069f0:	07db      	lsls	r3, r3, #31
  4069f2:	d501      	bpl.n	4069f8 <can_enter_init_mode.constprop.0+0x22>
	return 0;
  4069f4:	2000      	movs	r0, #0
  4069f6:	e00e      	b.n	406a16 <can_enter_init_mode.constprop.0+0x40>
  4069f8:	f000 fa32 	bl	406e60 <z_impl_k_uptime_ticks>
		if (k_uptime_ticks() - start_time > timeout.ticks) {
  4069fc:	1b40      	subs	r0, r0, r5
  4069fe:	eb61 0106 	sbc.w	r1, r1, r6
  406a02:	42b8      	cmp	r0, r7
  406a04:	f171 0300 	sbcs.w	r3, r1, #0
  406a08:	dbf1      	blt.n	4069ee <can_enter_init_mode.constprop.0+0x18>
			can->cccr &= ~CAN_MCAN_CCCR_INIT;
  406a0a:	69a3      	ldr	r3, [r4, #24]
			return -EAGAIN;
  406a0c:	f06f 000a 	mvn.w	r0, #10
			can->cccr &= ~CAN_MCAN_CCCR_INIT;
  406a10:	f023 0301 	bic.w	r3, r3, #1
  406a14:	61a3      	str	r3, [r4, #24]
}
  406a16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00406a18 <can_leave_init_mode.constprop.0>:
static int can_leave_init_mode(struct can_mcan_reg  *can, k_timeout_t timeout)
  406a18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	can->cccr &= ~CAN_MCAN_CCCR_INIT;
  406a1a:	6983      	ldr	r3, [r0, #24]
static int can_leave_init_mode(struct can_mcan_reg  *can, k_timeout_t timeout)
  406a1c:	4604      	mov	r4, r0
	can->cccr &= ~CAN_MCAN_CCCR_INIT;
  406a1e:	f023 0301 	bic.w	r3, r3, #1
  406a22:	6183      	str	r3, [r0, #24]
  406a24:	f000 fa1c 	bl	406e60 <z_impl_k_uptime_ticks>
		if (k_uptime_ticks() - start_time > timeout.ticks) {
  406a28:	f240 37e9 	movw	r7, #1001	; 0x3e9
  406a2c:	4605      	mov	r5, r0
  406a2e:	460e      	mov	r6, r1
	while ((can->cccr & CAN_MCAN_CCCR_INIT) != 0U) {
  406a30:	69a0      	ldr	r0, [r4, #24]
  406a32:	f010 0001 	ands.w	r0, r0, #1
  406a36:	d100      	bne.n	406a3a <can_leave_init_mode.constprop.0+0x22>
}
  406a38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406a3a:	f000 fa11 	bl	406e60 <z_impl_k_uptime_ticks>
		if (k_uptime_ticks() - start_time > timeout.ticks) {
  406a3e:	1b40      	subs	r0, r0, r5
  406a40:	eb61 0106 	sbc.w	r1, r1, r6
  406a44:	42b8      	cmp	r0, r7
  406a46:	f171 0300 	sbcs.w	r3, r1, #0
  406a4a:	dbf1      	blt.n	406a30 <can_leave_init_mode.constprop.0+0x18>
			return -EAGAIN;
  406a4c:	f06f 000a 	mvn.w	r0, #10
  406a50:	e7f2      	b.n	406a38 <can_leave_init_mode.constprop.0+0x20>

00406a52 <can_mcan_get_state>:
	struct can_mcan_reg *can = cfg->can;
  406a52:	6803      	ldr	r3, [r0, #0]
	if (state != NULL) {
  406a54:	b121      	cbz	r1, 406a60 <can_mcan_get_state+0xe>
		if (can->psr & CAN_MCAN_PSR_BO) {
  406a56:	6c58      	ldr	r0, [r3, #68]	; 0x44
  406a58:	0600      	lsls	r0, r0, #24
  406a5a:	d509      	bpl.n	406a70 <can_mcan_get_state+0x1e>
			*state = CAN_BUS_OFF;
  406a5c:	2003      	movs	r0, #3
			*state = CAN_ERROR_ACTIVE;
  406a5e:	7008      	strb	r0, [r1, #0]
	if (err_cnt != NULL) {
  406a60:	b122      	cbz	r2, 406a6c <can_mcan_get_state+0x1a>
		err_cnt->rx_err_cnt = (can->ecr & CAN_MCAN_ECR_TEC_MSK) <<
  406a62:	6c19      	ldr	r1, [r3, #64]	; 0x40
  406a64:	7051      	strb	r1, [r2, #1]
		err_cnt->tx_err_cnt = (can->ecr & CAN_MCAN_ECR_REC_MSK) <<
  406a66:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  406a68:	2300      	movs	r3, #0
  406a6a:	7013      	strb	r3, [r2, #0]
}
  406a6c:	2000      	movs	r0, #0
  406a6e:	4770      	bx	lr
		} else if (can->psr & CAN_MCAN_PSR_EP) {
  406a70:	6c58      	ldr	r0, [r3, #68]	; 0x44
  406a72:	0680      	lsls	r0, r0, #26
  406a74:	d501      	bpl.n	406a7a <can_mcan_get_state+0x28>
			*state = CAN_ERROR_PASSIVE;
  406a76:	2002      	movs	r0, #2
  406a78:	e7f1      	b.n	406a5e <can_mcan_get_state+0xc>
		} else if (can->psr & CAN_MCAN_PSR_EW) {
  406a7a:	6c58      	ldr	r0, [r3, #68]	; 0x44
  406a7c:	f010 0040 	ands.w	r0, r0, #64	; 0x40
			*state = CAN_ERROR_WARNING;
  406a80:	bf18      	it	ne
  406a82:	2001      	movne	r0, #1
  406a84:	e7eb      	b.n	406a5e <can_mcan_get_state+0xc>

00406a86 <can_sam_set_state_change_callback>:
	struct can_sam_data *data = dev->data;
  406a86:	6903      	ldr	r3, [r0, #16]
	data->mcan_data.state_change_cb = cb;
  406a88:	e9c3 125c 	strd	r1, r2, [r3, #368]	; 0x170
}
  406a8c:	4770      	bx	lr

00406a8e <can_sam_get_state>:
			     struct can_bus_err_cnt *err_cnt)
{
	const struct can_sam_config *cfg = dev->config;
	const struct can_mcan_config *mcan_cfg = &cfg->mcan_cfg;

	return can_mcan_get_state(mcan_cfg, state, err_cnt);
  406a8e:	6840      	ldr	r0, [r0, #4]
  406a90:	f7ff bfdf 	b.w	406a52 <can_mcan_get_state>

00406a94 <can_sam_remove_rx_filter>:
	return can_mcan_add_rx_filter(mcan_data, msg_ram, cb, cb_arg, filter);
}

static void can_sam_remove_rx_filter(const struct device *dev, int filter_id)
{
	struct can_sam_data *data = dev->data;
  406a94:	6900      	ldr	r0, [r0, #16]
{
  406a96:	460a      	mov	r2, r1
	struct can_mcan_data *mcan_data = &data->mcan_data;
	struct can_mcan_msg_sram *msg_ram = &data->msg_ram;

	can_mcan_remove_rx_filter(mcan_data, msg_ram, filter_id);
  406a98:	f500 71c2 	add.w	r1, r0, #388	; 0x184
  406a9c:	f7fd bd90 	b.w	4045c0 <can_mcan_remove_rx_filter>

00406aa0 <can_sam_add_rx_filter>:
{
  406aa0:	b507      	push	{r0, r1, r2, lr}
	struct can_sam_data *data = dev->data;
  406aa2:	6900      	ldr	r0, [r0, #16]
	return can_mcan_add_rx_filter(mcan_data, msg_ram, cb, cb_arg, filter);
  406aa4:	9300      	str	r3, [sp, #0]
  406aa6:	4613      	mov	r3, r2
  406aa8:	460a      	mov	r2, r1
  406aaa:	f500 71c2 	add.w	r1, r0, #388	; 0x184
  406aae:	f7fd fce7 	bl	404480 <can_mcan_add_rx_filter>
}
  406ab2:	b003      	add	sp, #12
  406ab4:	f85d fb04 	ldr.w	pc, [sp], #4

00406ab8 <can_sam_send>:
{
  406ab8:	b530      	push	{r4, r5, lr}
  406aba:	b085      	sub	sp, #20
  406abc:	460c      	mov	r4, r1
	struct can_sam_data *data = dev->data;
  406abe:	6901      	ldr	r1, [r0, #16]
	return can_mcan_send(mcan_cfg, mcan_data, msg_ram, frame, timeout, callback, user_data);
  406ac0:	9d09      	ldr	r5, [sp, #36]	; 0x24
  406ac2:	9503      	str	r5, [sp, #12]
  406ac4:	9d08      	ldr	r5, [sp, #32]
  406ac6:	e9cd 2300 	strd	r2, r3, [sp]
  406aca:	4623      	mov	r3, r4
  406acc:	f501 72c2 	add.w	r2, r1, #388	; 0x184
  406ad0:	9502      	str	r5, [sp, #8]
  406ad2:	6840      	ldr	r0, [r0, #4]
  406ad4:	f7fd fb4c 	bl	404170 <can_mcan_send>
}
  406ad8:	b005      	add	sp, #20
  406ada:	bd30      	pop	{r4, r5, pc}

00406adc <can_sam_set_timing>:
			      const struct can_timing *timing_data)
{
	const struct can_sam_config *cfg = dev->config;
	const struct can_mcan_config *mcan_cfg = &cfg->mcan_cfg;

	return can_mcan_set_timing(mcan_cfg, timing, timing_data);
  406adc:	6840      	ldr	r0, [r0, #4]
  406ade:	f7fd b883 	b.w	403be8 <can_mcan_set_timing>

00406ae2 <can_sam_set_mode>:
	return can_mcan_set_mode(mcan_cfg, mode);
  406ae2:	6840      	ldr	r0, [r0, #4]
  406ae4:	f7fd b8b4 	b.w	403c50 <can_mcan_set_mode>

00406ae8 <config_can_0_irq>:
	CAN_SAM_IRQ_CFG_FUNCTION(inst)                                         \
	CAN_SAM_CFG_INST(inst)                                                 \
	CAN_SAM_DATA_INST(inst)                                                \
	CAN_SAM_DEVICE_INST(inst)

DT_INST_FOREACH_STATUS_OKAY(CAN_SAM_INST)
  406ae8:	2200      	movs	r2, #0
  406aea:	2023      	movs	r0, #35	; 0x23
  406aec:	4611      	mov	r1, r2
  406aee:	b508      	push	{r3, lr}
  406af0:	f7fc f81e 	bl	402b30 <z_arm_irq_priority_set>
  406af4:	2023      	movs	r0, #35	; 0x23
  406af6:	f7fc f80b 	bl	402b10 <arch_irq_enable>
  406afa:	2200      	movs	r2, #0
  406afc:	2024      	movs	r0, #36	; 0x24
  406afe:	4611      	mov	r1, r2
  406b00:	f7fc f816 	bl	402b30 <z_arm_irq_priority_set>
  406b04:	2024      	movs	r0, #36	; 0x24
  406b06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  406b0a:	f7fc b801 	b.w	402b10 <arch_irq_enable>

00406b0e <can_sam_line_0_isr>:
	can_mcan_line_0_isr(mcan_cfg, msg_ram, mcan_data);
  406b0e:	6902      	ldr	r2, [r0, #16]
  406b10:	6840      	ldr	r0, [r0, #4]
  406b12:	f502 71c2 	add.w	r1, r2, #388	; 0x184
  406b16:	f7fd ba87 	b.w	404028 <can_mcan_line_0_isr>

00406b1a <can_sam_line_1_isr>:
	can_mcan_line_1_isr(mcan_cfg, msg_ram, mcan_data);
  406b1a:	6902      	ldr	r2, [r0, #16]
  406b1c:	6840      	ldr	r0, [r0, #4]
  406b1e:	f502 71c2 	add.w	r1, r2, #388	; 0x184
  406b22:	f7fd ba2d 	b.w	403f80 <can_mcan_line_1_isr>

00406b26 <uart_sam_poll_in>:
	Uart * const uart = cfg->regs;
  406b26:	6843      	ldr	r3, [r0, #4]
  406b28:	681b      	ldr	r3, [r3, #0]
	if (!(uart->UART_SR & UART_SR_RXRDY)) {
  406b2a:	695a      	ldr	r2, [r3, #20]
  406b2c:	07d2      	lsls	r2, r2, #31
  406b2e:	d503      	bpl.n	406b38 <uart_sam_poll_in+0x12>
	*c = (unsigned char)uart->UART_RHR;
  406b30:	699b      	ldr	r3, [r3, #24]
	return 0;
  406b32:	2000      	movs	r0, #0
	*c = (unsigned char)uart->UART_RHR;
  406b34:	700b      	strb	r3, [r1, #0]
	return 0;
  406b36:	4770      	bx	lr
		return -EBUSY;
  406b38:	f06f 000f 	mvn.w	r0, #15
}
  406b3c:	4770      	bx	lr

00406b3e <uart_sam_poll_out>:
	Uart * const uart = cfg->regs;
  406b3e:	6843      	ldr	r3, [r0, #4]
  406b40:	681b      	ldr	r3, [r3, #0]
	while (!(uart->UART_SR & UART_SR_TXRDY)) {
  406b42:	695a      	ldr	r2, [r3, #20]
  406b44:	0792      	lsls	r2, r2, #30
  406b46:	d5fc      	bpl.n	406b42 <uart_sam_poll_out+0x4>
	uart->UART_THR = (uint32_t)c;
  406b48:	61d9      	str	r1, [r3, #28]
}
  406b4a:	4770      	bx	lr

00406b4c <uart_sam_err_check>:
	volatile Uart * const uart = cfg->regs;
  406b4c:	6843      	ldr	r3, [r0, #4]
  406b4e:	681b      	ldr	r3, [r3, #0]
	if (uart->UART_SR & UART_SR_OVRE) {
  406b50:	6958      	ldr	r0, [r3, #20]
	if (uart->UART_SR & UART_SR_PARE) {
  406b52:	695a      	ldr	r2, [r3, #20]
	if (uart->UART_SR & UART_SR_OVRE) {
  406b54:	f3c0 1040 	ubfx	r0, r0, #5, #1
	if (uart->UART_SR & UART_SR_FRAME) {
  406b58:	695b      	ldr	r3, [r3, #20]
	if (uart->UART_SR & UART_SR_PARE) {
  406b5a:	0612      	lsls	r2, r2, #24
		errors |= UART_ERROR_PARITY;
  406b5c:	bf48      	it	mi
  406b5e:	f040 0002 	orrmi.w	r0, r0, #2
	if (uart->UART_SR & UART_SR_FRAME) {
  406b62:	065b      	lsls	r3, r3, #25
		errors |= UART_ERROR_FRAMING;
  406b64:	bf48      	it	mi
  406b66:	f040 0004 	orrmi.w	r0, r0, #4
}
  406b6a:	4770      	bx	lr

00406b6c <z_device_state_init>:
}
  406b6c:	4770      	bx	lr

00406b6e <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
  406b6e:	b138      	cbz	r0, 406b80 <z_device_is_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  406b70:	68c3      	ldr	r3, [r0, #12]
  406b72:	8818      	ldrh	r0, [r3, #0]
  406b74:	f3c0 0008 	ubfx	r0, r0, #0, #9
  406b78:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
  406b7c:	4258      	negs	r0, r3
  406b7e:	4158      	adcs	r0, r3
}
  406b80:	4770      	bx	lr

00406b82 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
  406b82:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
  406b84:	ab0a      	add	r3, sp, #40	; 0x28
  406b86:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
  406b88:	9302      	str	r3, [sp, #8]
  406b8a:	2201      	movs	r2, #1
  406b8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406b8e:	9301      	str	r3, [sp, #4]
  406b90:	2300      	movs	r3, #0
  406b92:	4618      	mov	r0, r3
  406b94:	9300      	str	r3, [sp, #0]
  406b96:	f7fb fec5 	bl	402924 <z_impl_z_log_msg2_runtime_vcreate>
}
  406b9a:	b007      	add	sp, #28
  406b9c:	f85d fb04 	ldr.w	pc, [sp], #4

00406ba0 <arch_system_halt>:
	__asm__ volatile(
  406ba0:	f04f 0220 	mov.w	r2, #32
  406ba4:	f3ef 8311 	mrs	r3, BASEPRI
  406ba8:	f382 8812 	msr	BASEPRI_MAX, r2
  406bac:	f3bf 8f6f 	isb	sy
	for (;;) {
  406bb0:	e7fe      	b.n	406bb0 <arch_system_halt+0x10>

00406bb2 <k_is_in_isr>:
  406bb2:	f3ef 8005 	mrs	r0, IPSR
}
  406bb6:	3800      	subs	r0, #0
  406bb8:	bf18      	it	ne
  406bba:	2001      	movne	r0, #1
  406bbc:	4770      	bx	lr

00406bbe <z_impl_k_thread_name_set>:
}
  406bbe:	f06f 0057 	mvn.w	r0, #87	; 0x57
  406bc2:	4770      	bx	lr

00406bc4 <k_thread_name_get>:
}
  406bc4:	2000      	movs	r0, #0
  406bc6:	4770      	bx	lr

00406bc8 <z_impl_k_thread_start>:
	z_sched_start(thread);
  406bc8:	f7fe bbd4 	b.w	405374 <z_sched_start>

00406bcc <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
  406bcc:	b508      	push	{r3, lr}
  406bce:	f04f 0220 	mov.w	r2, #32
  406bd2:	f3ef 8311 	mrs	r3, BASEPRI
  406bd6:	f382 8812 	msr	BASEPRI_MAX, r2
  406bda:	f3bf 8f6f 	isb	sy
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  406bde:	f7fb ff23 	bl	402a28 <arch_cpu_idle>
  406be2:	e7f4      	b.n	406bce <idle+0x2>

00406be4 <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
  406be4:	f990 300e 	ldrsb.w	r3, [r0, #14]
  406be8:	428b      	cmp	r3, r1
  406bea:	d001      	beq.n	406bf0 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
  406bec:	f7fe bc32 	b.w	405454 <z_set_prio>
}
  406bf0:	2000      	movs	r0, #0
  406bf2:	4770      	bx	lr

00406bf4 <z_impl_k_mutex_init>:
{
  406bf4:	4603      	mov	r3, r0
	mutex->owner = NULL;
  406bf6:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
  406bf8:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
  406bfc:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
  406c00:	4770      	bx	lr

00406c02 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  406c02:	b13a      	cbz	r2, 406c14 <z_impl_k_sem_init+0x12>
  406c04:	428a      	cmp	r2, r1
  406c06:	d305      	bcc.n	406c14 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
  406c08:	e9c0 1202 	strd	r1, r2, [r0, #8]
  406c0c:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
  406c10:	2000      	movs	r0, #0
  406c12:	4770      	bx	lr
		return -EINVAL;
  406c14:	f06f 0015 	mvn.w	r0, #21
}
  406c18:	4770      	bx	lr

00406c1a <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
  406c1a:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
  406c1c:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
  406c1e:	408b      	lsls	r3, r1
  406c20:	ea22 0303 	bic.w	r3, r2, r3
  406c24:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
  406c26:	fa22 f001 	lsr.w	r0, r2, r1
}
  406c2a:	f000 0001 	and.w	r0, r0, #1
  406c2e:	4770      	bx	lr

00406c30 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
  406c30:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
  406c34:	6013      	str	r3, [r2, #0]
	next->prev = prev;
  406c36:	605a      	str	r2, [r3, #4]
	node->next = NULL;
  406c38:	2300      	movs	r3, #0
	node->prev = NULL;
  406c3a:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
  406c3e:	4770      	bx	lr

00406c40 <unpend_thread_no_timeout>:
{
  406c40:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
  406c42:	f7ff fff5 	bl	406c30 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  406c46:	7b43      	ldrb	r3, [r0, #13]
  406c48:	f023 0302 	bic.w	r3, r3, #2
  406c4c:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
  406c4e:	2300      	movs	r3, #0
  406c50:	6083      	str	r3, [r0, #8]
}
  406c52:	bd08      	pop	{r3, pc}

00406c54 <z_unpend_thread_no_timeout>:
{
  406c54:	b508      	push	{r3, lr}
  406c56:	f04f 0320 	mov.w	r3, #32
  406c5a:	f3ef 8111 	mrs	r1, BASEPRI
  406c5e:	f383 8812 	msr	BASEPRI_MAX, r3
  406c62:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
  406c66:	f7ff ffeb 	bl	406c40 <unpend_thread_no_timeout>
	__asm__ volatile(
  406c6a:	f381 8811 	msr	BASEPRI, r1
  406c6e:	f3bf 8f6f 	isb	sy
}
  406c72:	bd08      	pop	{r3, pc}

00406c74 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  406c74:	4603      	mov	r3, r0
  406c76:	b920      	cbnz	r0, 406c82 <z_reschedule_irqlock+0xe>
  406c78:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
  406c7c:	b90a      	cbnz	r2, 406c82 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
  406c7e:	f7fb bf95 	b.w	402bac <arch_swap>
  406c82:	f383 8811 	msr	BASEPRI, r3
  406c86:	f3bf 8f6f 	isb	sy
}
  406c8a:	4770      	bx	lr

00406c8c <z_reschedule_unlocked>:
	__asm__ volatile(
  406c8c:	f04f 0320 	mov.w	r3, #32
  406c90:	f3ef 8011 	mrs	r0, BASEPRI
  406c94:	f383 8812 	msr	BASEPRI_MAX, r3
  406c98:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
  406c9c:	f7ff bfea 	b.w	406c74 <z_reschedule_irqlock>

00406ca0 <z_priq_dumb_best>:
{
  406ca0:	4603      	mov	r3, r0
	return list->head == list;
  406ca2:	6800      	ldr	r0, [r0, #0]
}
  406ca4:	4283      	cmp	r3, r0
  406ca6:	bf08      	it	eq
  406ca8:	2000      	moveq	r0, #0
  406caa:	4770      	bx	lr

00406cac <z_ready_thread>:
{
  406cac:	b510      	push	{r4, lr}
  406cae:	f04f 0320 	mov.w	r3, #32
  406cb2:	f3ef 8411 	mrs	r4, BASEPRI
  406cb6:	f383 8812 	msr	BASEPRI_MAX, r3
  406cba:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
  406cbe:	f7fe fb23 	bl	405308 <ready_thread>
	__asm__ volatile(
  406cc2:	f384 8811 	msr	BASEPRI, r4
  406cc6:	f3bf 8f6f 	isb	sy
}
  406cca:	bd10      	pop	{r4, pc}

00406ccc <z_thread_timeout>:
{
  406ccc:	4601      	mov	r1, r0
  406cce:	b510      	push	{r4, lr}
	__asm__ volatile(
  406cd0:	f04f 0320 	mov.w	r3, #32
  406cd4:	f3ef 8411 	mrs	r4, BASEPRI
  406cd8:	f383 8812 	msr	BASEPRI_MAX, r3
  406cdc:	f3bf 8f6f 	isb	sy
		if (!killed) {
  406ce0:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
  406ce4:	f013 0f28 	tst.w	r3, #40	; 0x28
  406ce8:	d10d      	bne.n	406d06 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
  406cea:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
  406cee:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
  406cf0:	b10b      	cbz	r3, 406cf6 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
  406cf2:	f7ff ffa5 	bl	406c40 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  406cf6:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
  406cfa:	f023 0314 	bic.w	r3, r3, #20
  406cfe:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
  406d02:	f7fe fb01 	bl	405308 <ready_thread>
	__asm__ volatile(
  406d06:	f384 8811 	msr	BASEPRI, r4
  406d0a:	f3bf 8f6f 	isb	sy
}
  406d0e:	bd10      	pop	{r4, pc}

00406d10 <add_to_waitq_locked>:
{
  406d10:	b538      	push	{r3, r4, r5, lr}
  406d12:	4604      	mov	r4, r0
  406d14:	460d      	mov	r5, r1
	unready_thread(thread);
  406d16:	f7fe fb4b 	bl	4053b0 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  406d1a:	7b63      	ldrb	r3, [r4, #13]
  406d1c:	f043 0302 	orr.w	r3, r3, #2
  406d20:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
  406d22:	b195      	cbz	r5, 406d4a <add_to_waitq_locked+0x3a>
  406d24:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
  406d26:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  406d28:	429d      	cmp	r5, r3
  406d2a:	d015      	beq.n	406d58 <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  406d2c:	b1a3      	cbz	r3, 406d58 <add_to_waitq_locked+0x48>
	int32_t b1 = thread_1->base.prio;
  406d2e:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
  406d32:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
  406d36:	4291      	cmp	r1, r2
  406d38:	d008      	beq.n	406d4c <add_to_waitq_locked+0x3c>
		return b2 - b1;
  406d3a:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
  406d3c:	2a00      	cmp	r2, #0
  406d3e:	dd05      	ble.n	406d4c <add_to_waitq_locked+0x3c>
	sys_dnode_t *const prev = successor->prev;
  406d40:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
  406d42:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
  406d46:	6014      	str	r4, [r2, #0]
	successor->prev = node;
  406d48:	605c      	str	r4, [r3, #4]
}
  406d4a:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
  406d4c:	686a      	ldr	r2, [r5, #4]
  406d4e:	4293      	cmp	r3, r2
  406d50:	d002      	beq.n	406d58 <add_to_waitq_locked+0x48>
  406d52:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  406d54:	2b00      	cmp	r3, #0
  406d56:	d1ec      	bne.n	406d32 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
  406d58:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
  406d5a:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
  406d5e:	601c      	str	r4, [r3, #0]
	list->tail = node;
  406d60:	606c      	str	r4, [r5, #4]
}
  406d62:	e7f2      	b.n	406d4a <add_to_waitq_locked+0x3a>

00406d64 <z_unpend1_no_timeout>:
{
  406d64:	b510      	push	{r4, lr}
	__asm__ volatile(
  406d66:	f04f 0320 	mov.w	r3, #32
  406d6a:	f3ef 8411 	mrs	r4, BASEPRI
  406d6e:	f383 8812 	msr	BASEPRI_MAX, r3
  406d72:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
  406d76:	f7ff ff93 	bl	406ca0 <z_priq_dumb_best>
		if (thread != NULL) {
  406d7a:	4601      	mov	r1, r0
  406d7c:	b108      	cbz	r0, 406d82 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
  406d7e:	f7ff ff5f 	bl	406c40 <unpend_thread_no_timeout>
	__asm__ volatile(
  406d82:	f384 8811 	msr	BASEPRI, r4
  406d86:	f3bf 8f6f 	isb	sy
}
  406d8a:	4608      	mov	r0, r1
  406d8c:	bd10      	pop	{r4, pc}

00406d8e <z_unpend_first_thread>:
{
  406d8e:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
  406d90:	f04f 0320 	mov.w	r3, #32
  406d94:	f3ef 8511 	mrs	r5, BASEPRI
  406d98:	f383 8812 	msr	BASEPRI_MAX, r3
  406d9c:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
  406da0:	f7ff ff7e 	bl	406ca0 <z_priq_dumb_best>
		if (thread != NULL) {
  406da4:	4604      	mov	r4, r0
  406da6:	b120      	cbz	r0, 406db2 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
  406da8:	f7ff ff4a 	bl	406c40 <unpend_thread_no_timeout>
  406dac:	3018      	adds	r0, #24
  406dae:	f000 f823 	bl	406df8 <z_abort_timeout>
	__asm__ volatile(
  406db2:	f385 8811 	msr	BASEPRI, r5
  406db6:	f3bf 8f6f 	isb	sy
}
  406dba:	4620      	mov	r0, r4
  406dbc:	bd38      	pop	{r3, r4, r5, pc}

00406dbe <z_sched_wake>:
{
  406dbe:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
  406dc0:	f04f 0320 	mov.w	r3, #32
  406dc4:	f3ef 8511 	mrs	r5, BASEPRI
  406dc8:	f383 8812 	msr	BASEPRI_MAX, r3
  406dcc:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
  406dd0:	f7ff ff66 	bl	406ca0 <z_priq_dumb_best>
		if (thread != NULL) {
  406dd4:	4604      	mov	r4, r0
  406dd6:	b150      	cbz	r0, 406dee <z_sched_wake+0x30>
  406dd8:	6781      	str	r1, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  406dda:	6142      	str	r2, [r0, #20]
			unpend_thread_no_timeout(thread);
  406ddc:	f7ff ff30 	bl	406c40 <unpend_thread_no_timeout>
  406de0:	3018      	adds	r0, #24
  406de2:	f000 f809 	bl	406df8 <z_abort_timeout>
			ready_thread(thread);
  406de6:	4620      	mov	r0, r4
  406de8:	f7fe fa8e 	bl	405308 <ready_thread>
			ret = true;
  406dec:	2001      	movs	r0, #1
	__asm__ volatile(
  406dee:	f385 8811 	msr	BASEPRI, r5
  406df2:	f3bf 8f6f 	isb	sy
}
  406df6:	bd38      	pop	{r3, r4, r5, pc}

00406df8 <z_abort_timeout>:
{
  406df8:	b510      	push	{r4, lr}
	__asm__ volatile(
  406dfa:	f04f 0220 	mov.w	r2, #32
  406dfe:	f3ef 8411 	mrs	r4, BASEPRI
  406e02:	f382 8812 	msr	BASEPRI_MAX, r2
  406e06:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
  406e0a:	6803      	ldr	r3, [r0, #0]
  406e0c:	b13b      	cbz	r3, 406e1e <z_abort_timeout+0x26>
			remove_timeout(to);
  406e0e:	f7fe fd19 	bl	405844 <remove_timeout>
			ret = 0;
  406e12:	2000      	movs	r0, #0
	__asm__ volatile(
  406e14:	f384 8811 	msr	BASEPRI, r4
  406e18:	f3bf 8f6f 	isb	sy
}
  406e1c:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
  406e1e:	f06f 0015 	mvn.w	r0, #21
  406e22:	e7f7      	b.n	406e14 <z_abort_timeout+0x1c>

00406e24 <z_set_timeout_expiry>:
{
  406e24:	b570      	push	{r4, r5, r6, lr}
  406e26:	4604      	mov	r4, r0
  406e28:	460d      	mov	r5, r1
	__asm__ volatile(
  406e2a:	f04f 0320 	mov.w	r3, #32
  406e2e:	f3ef 8611 	mrs	r6, BASEPRI
  406e32:	f383 8812 	msr	BASEPRI_MAX, r3
  406e36:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
  406e3a:	f7fe fcdb 	bl	4057f4 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
  406e3e:	2801      	cmp	r0, #1
  406e40:	dd05      	ble.n	406e4e <z_set_timeout_expiry+0x2a>
  406e42:	42a0      	cmp	r0, r4
  406e44:	db03      	blt.n	406e4e <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
  406e46:	4629      	mov	r1, r5
  406e48:	4620      	mov	r0, r4
  406e4a:	f7fd fcbf 	bl	4047cc <sys_clock_set_timeout>
	__asm__ volatile(
  406e4e:	f386 8811 	msr	BASEPRI, r6
  406e52:	f3bf 8f6f 	isb	sy
}
  406e56:	bd70      	pop	{r4, r5, r6, pc}

00406e58 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  406e58:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  406e5a:	f7fe fde3 	bl	405a24 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  406e5e:	bd08      	pop	{r3, pc}

00406e60 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  406e60:	f7fe bde0 	b.w	405a24 <sys_clock_tick_get>

00406e64 <k_timer_init>:
	timer->status = 0U;
  406e64:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
  406e66:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
  406e6a:	f100 0218 	add.w	r2, r0, #24
	timer->status = 0U;
  406e6e:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
  406e70:	6343      	str	r3, [r0, #52]	; 0x34
	list->tail = (sys_dnode_t *)list;
  406e72:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
  406e76:	e9c0 3300 	strd	r3, r3, [r0]
}
  406e7a:	4770      	bx	lr

00406e7c <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  406e7c:	b510      	push	{r4, lr}
  406e7e:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
  406e80:	f7ff ffba 	bl	406df8 <z_abort_timeout>

	if (inactive) {
  406e84:	b9b0      	cbnz	r0, 406eb4 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
  406e86:	6a63      	ldr	r3, [r4, #36]	; 0x24
  406e88:	b10b      	cbz	r3, 406e8e <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
  406e8a:	4620      	mov	r0, r4
  406e8c:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  406e8e:	f104 0018 	add.w	r0, r4, #24
  406e92:	f7ff ff67 	bl	406d64 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
  406e96:	b168      	cbz	r0, 406eb4 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
  406e98:	f7ff ff08 	bl	406cac <z_ready_thread>
	__asm__ volatile(
  406e9c:	f04f 0320 	mov.w	r3, #32
  406ea0:	f3ef 8011 	mrs	r0, BASEPRI
  406ea4:	f383 8812 	msr	BASEPRI_MAX, r3
  406ea8:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
  406eac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
  406eb0:	f7ff bee0 	b.w	406c74 <z_reschedule_irqlock>
  406eb4:	bd10      	pop	{r4, pc}

00406eb6 <k_heap_init>:
{
  406eb6:	b410      	push	{r4}
  406eb8:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
  406ebc:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
  406ec0:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
  406ec2:	f7fe bf84 	b.w	405dce <sys_heap_init>
